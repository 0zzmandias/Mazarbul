This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
client/
  src/
    components/
      club/
        ClubCard/
          ClubCard.jsx
        CreateClubModal/
          CreateClubModal.jsx
        ManageClubModal/
          ManageClubModal.jsx
      dashboard/
        ActivityCalendar/
          ActivityCalendar.jsx
        CollectionList/
          CollectionList.jsx
      layout/
        HeaderBar/
          HeaderBar.jsx
        SectionHeader/
          SectionHeader.jsx
      media/
        CommunityReviewsFeed/
          CommunityReviewsFeed.jsx
        MediaCard/
          MediaCard.jsx
        TechnicalDetails/
          TechnicalDetails.jsx
        UserReviewEditor/
          UserReviewEditor.jsx
      ui/
        AvatarStack/
          AvatarStack.jsx
        ExpandButton/
          ExpandButton.jsx
        MediaBadge/
          MediaBadge.jsx
        MediaCard/
          MediaCard.jsx
        RatingStars/
          RatingStars.jsx
        ReviewsPanel/
          ReviewsPanel.jsx
      user/
        BadgeCard/
          BadgeCard.jsx
        BadgesRibbon/
          BadgesRibbon.jsx
        FavoritesSection/
          FavoritesSection.jsx
        ProfileHeader/
          ProfileHeader.jsx
        ReviewCard/
          ReviewCard.jsx
        ReviewsPanel/
          ReviewsPanel.jsx
    constants/
      books.genres.js
      game.genres.js
      genres.js
    contexts/
      AuthContext.jsx
      UserDatabaseContext.jsx
    hooks/
      useI18n.js
      useTheme.js
      useUserProfileData.js
    pages/
      AchievementsPage/
        AchievementsPage.jsx
      ClubDetailsPage/
        ClubDetailsPage.jsx
      ClubsDiscoveryPage/
        ClubsDiscoveryPage.jsx
      ClubTopicPage/
        ClubTopicPage.jsx
      DashboardPage/
        DashboardPage.jsx
      FavoritesPage/
        FavoritesPage.jsx
      ForgotPasswordPage/
        ForgotPasswordPage.jsx
      HomePage/
        HomePage.jsx
      ListManagementPage/
        ListManagementPage.jsx
      LoginPage/
        LoginPage.jsx
      MediaDetailsPage/
        MediaDetailsPage.jsx
      ProfilePage/
        ProfilePage.jsx
      RegisterPage/
        RegisterPage.jsx
      ResetPasswordPage/
        ResetPasswordPage.jsx
      ReviewsPage/
        ReviewsPage.jsx
      SettingsPage/
        SettingsPage.jsx
    services/
      api.js
    styles/
      main.css
    utils/
      formatters.js
    App.jsx
    main.jsx
  index.html
  mazarbul@0.0.0
  package.json
  postcss.config.js
  project_tree.txt
  tailwind.config.js
  vite
  vite.config.js
server/
  prisma/
    migrations/
      20251216231129_init_user_table/
        migration.sql
      20251217004733_b2_core_schema/
        migration.sql
      20260104190000_add_media_alias/
        migration.sql
      20260104220716_npx_prisma_generate/
        migration.sql
      20260105235149_media_canonicalization/
        migration.sql
      20260106013204_media_alias_search_fields/
        migration.sql
      migration_lock.toml
    schema.prisma
  src/
    controllers/
      auth.controller.js
      media.controller.js
      review.controller.js
    lib/
      prisma.js
    middlewares/
      auth.middleware.js
    routes/
      auth.routes.js
      media.routes.js
      review.routes.js
    services/
      auth.service.js
      gamification.service.js
      mediaHydration.service.js
      mediaSearch.service.js
    utils/
      books.adapter.js
      lastfm.adapter.js
      rawg.adapter.js
      tmdb.adapter.js
      wikidata.adapter.js
    server.js
  .gitignore
  package.json
.gitignore
LICENSE
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="server/prisma/migrations/20260105235149_media_canonicalization/migration.sql">
/*
  Warnings:

  - The primary key for the `MediaAlias` table will be changed. If it partially fails, the table could be left without primary key constraint.
  - You are about to drop the column `aliasId` on the `MediaAlias` table. All the data in the column will be lost.
  - You are about to drop the column `updatedAt` on the `MediaAlias` table. All the data in the column will be lost.
  - Added the required column `id` to the `MediaAlias` table without a default value. This is not possible if the table is not empty.

*/
-- AlterTable
ALTER TABLE "MediaAlias" DROP CONSTRAINT "MediaAlias_pkey",
DROP COLUMN "aliasId",
DROP COLUMN "updatedAt",
ADD COLUMN     "id" TEXT NOT NULL,
ADD CONSTRAINT "MediaAlias_pkey" PRIMARY KEY ("id");

-- AlterTable
ALTER TABLE "MediaReference" ADD COLUMN     "canonicalCountryIso2" TEXT,
ADD COLUMN     "canonicalCountryQid" TEXT,
ADD COLUMN     "canonicalCreatorName" TEXT,
ADD COLUMN     "canonicalCreatorQid" TEXT,
ADD COLUMN     "canonicalGenreKey" TEXT,
ADD COLUMN     "canonicalGenres" JSONB,
ADD COLUMN     "canonicalYear" INTEGER,
ADD COLUMN     "isStub" BOOLEAN NOT NULL DEFAULT false,
ADD COLUMN     "lastAccessedAt" TIMESTAMP(3);

-- CreateIndex
CREATE INDEX "MediaReference_canonicalYear_idx" ON "MediaReference"("canonicalYear");

-- CreateIndex
CREATE INDEX "MediaReference_canonicalGenreKey_idx" ON "MediaReference"("canonicalGenreKey");

-- CreateIndex
CREATE INDEX "MediaReference_lastAccessedAt_idx" ON "MediaReference"("lastAccessedAt");

-- CreateIndex
CREATE INDEX "MediaReference_isStub_idx" ON "MediaReference"("isStub");
</file>

<file path="server/prisma/migrations/20260106013204_media_alias_search_fields/migration.sql">
/*
  Warnings:

  - You are about to drop the column `canonicalCountryIso2` on the `MediaReference` table. All the data in the column will be lost.
  - You are about to drop the column `canonicalCountryQid` on the `MediaReference` table. All the data in the column will be lost.
  - You are about to drop the column `canonicalCreatorName` on the `MediaReference` table. All the data in the column will be lost.
  - You are about to drop the column `canonicalCreatorQid` on the `MediaReference` table. All the data in the column will be lost.
  - You are about to drop the column `canonicalGenreKey` on the `MediaReference` table. All the data in the column will be lost.
  - You are about to drop the column `canonicalGenres` on the `MediaReference` table. All the data in the column will be lost.
  - You are about to drop the column `canonicalYear` on the `MediaReference` table. All the data in the column will be lost.
  - Added the required column `lang` to the `MediaAlias` table without a default value. This is not possible if the table is not empty.
  - Added the required column `source` to the `MediaAlias` table without a default value. This is not possible if the table is not empty.
  - Added the required column `title` to the `MediaAlias` table without a default value. This is not possible if the table is not empty.
  - Added the required column `titleNormalized` to the `MediaAlias` table without a default value. This is not possible if the table is not empty.
  - Added the required column `titleRaw` to the `MediaAlias` table without a default value. This is not possible if the table is not empty.
  - Added the required column `type` to the `MediaAlias` table without a default value. This is not possible if the table is not empty.

*/
-- DropIndex
DROP INDEX "MediaAlias_canonicalId_idx";

-- DropIndex
DROP INDEX "MediaReference_canonicalGenreKey_idx";

-- DropIndex
DROP INDEX "MediaReference_canonicalYear_idx";

-- DropIndex
DROP INDEX "MediaReference_isStub_idx";

-- AlterTable
ALTER TABLE "MediaAlias" ADD COLUMN     "lang" TEXT NOT NULL,
ADD COLUMN     "lastAccessedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN     "source" TEXT NOT NULL,
ADD COLUMN     "title" TEXT NOT NULL,
ADD COLUMN     "titleNormalized" TEXT NOT NULL,
ADD COLUMN     "titleRaw" TEXT NOT NULL,
ADD COLUMN     "type" TEXT NOT NULL;

-- AlterTable
ALTER TABLE "MediaReference" DROP COLUMN "canonicalCountryIso2",
DROP COLUMN "canonicalCountryQid",
DROP COLUMN "canonicalCreatorName",
DROP COLUMN "canonicalCreatorQid",
DROP COLUMN "canonicalGenreKey",
DROP COLUMN "canonicalGenres",
DROP COLUMN "canonicalYear",
ADD COLUMN     "countrySource" TEXT,
ADD COLUMN     "lastFetchedAt" TIMESTAMP(3);

-- CreateTable
CREATE TABLE "Genre" (
    "id" TEXT NOT NULL,
    "slug" TEXT NOT NULL,
    "titles" JSONB NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Genre_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "MediaGenre" (
    "mediaId" TEXT NOT NULL,
    "genreId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "MediaGenre_pkey" PRIMARY KEY ("mediaId","genreId")
);

-- CreateIndex
CREATE UNIQUE INDEX "Genre_slug_key" ON "Genre"("slug");

-- CreateIndex
CREATE INDEX "MediaGenre_genreId_idx" ON "MediaGenre"("genreId");

-- CreateIndex
CREATE INDEX "MediaGenre_mediaId_idx" ON "MediaGenre"("mediaId");

-- CreateIndex
CREATE INDEX "MediaAlias_lastAccessedAt_idx" ON "MediaAlias"("lastAccessedAt");

-- CreateIndex
CREATE INDEX "MediaAlias_type_lang_titleNormalized_idx" ON "MediaAlias"("type", "lang", "titleNormalized");

-- CreateIndex
CREATE INDEX "MediaReference_type_releaseYear_idx" ON "MediaReference"("type", "releaseYear");

-- AddForeignKey
ALTER TABLE "MediaGenre" ADD CONSTRAINT "MediaGenre_mediaId_fkey" FOREIGN KEY ("mediaId") REFERENCES "MediaReference"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "MediaGenre" ADD CONSTRAINT "MediaGenre_genreId_fkey" FOREIGN KEY ("genreId") REFERENCES "Genre"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="server/src/services/mediaHydration.service.js">
import prisma from '../lib/prisma.js';

import * as tmdb from '../utils/tmdb.adapter.js';
import * as rawg from '../utils/rawg.adapter.js';
import * as books from '../utils/books.adapter.js';
import * as lastfm from '../utils/lastfm.adapter.js';

import { getEntities, searchEntities, buildTechnicalDetailsFromWikidata, isQid } from '../utils/wikidata.adapter.js';

const now = () => new Date();

const pickFirst = (...values) => {
    for (const v of values) {
        if (v == null) continue;
        if (typeof v === 'string' && !v.trim()) continue;
        return v;
    }
    return null;
};

const normalizeComparableName = (value) =>
String(value || '')
.toLowerCase()
.normalize('NFD')
.replace(/[\u0300-\u036f]/g, '')
.replace(/[^a-z0-9\s]/g, ' ')
.replace(/\s+/g, ' ')
.trim();

const normalizeSlug = (value) =>
String(value || '')
.toLowerCase()
.normalize('NFD')
.replace(/[\u0300-\u036f]/g, '')
.replace(/[^a-z0-9\s-]/g, ' ')
.replace(/\s+/g, ' ')
.trim()
.replace(/\s+/g, '-');

const ensureTitlesShape = (titles) => {
    const t = titles && typeof titles === 'object' ? { ...titles } : {};
    if (!('PT' in t)) t.PT = null;
    if (!('EN' in t)) t.EN = null;
    if (!('ES' in t)) t.ES = null;

    const base = pickFirst(t.DEFAULT, t.PT, t.EN, t.ES, null);
    t.DEFAULT = base;

    return t;
};

const applyTitleRulesByType = (type, titles) => {
    const t = ensureTitlesShape(titles);

    if (type === 'jogo' || type === 'album') {
        const base = pickFirst(t.EN, t.PT, t.ES, t.DEFAULT, null);
        return {
            PT: base,
            EN: base,
            ES: base,
            DEFAULT: base,
        };
    }

    const base = pickFirst(t.PT, t.EN, t.ES, t.DEFAULT, null);
    return {
        PT: t.PT || base,
        EN: t.EN || base,
        ES: t.ES || base,
        DEFAULT: base,
    };
};

const buildGenresForUi = (type, technicalGenres) => {
    const base = Array.isArray(technicalGenres) ? technicalGenres : [];

    const byLang = { PT: [], EN: [], ES: [] };
    const forceSame = type === 'jogo' || type === 'album';

    for (const g of base) {
        const titles = g?.titles && typeof g.titles === 'object' ? g.titles : null;
        const en = titles?.EN || null;
        const pt = titles?.PT || null;
        const es = titles?.ES || null;

        if (forceSame) {
            const v = pickFirst(en, pt, es, null);
            if (v) {
                byLang.PT.push(v);
                byLang.EN.push(v);
                byLang.ES.push(v);
            }
            continue;
        }

        if (pt) byLang.PT.push(pt);
        if (en) byLang.EN.push(en);
        if (es) byLang.ES.push(es);
    }

    const dedupe = (arr) => {
        const out = [];
        const seen = new Set();
        for (const v of arr || []) {
            const s = String(v || '').trim();
            if (!s) continue;
            const k = s.toLowerCase();
            if (seen.has(k)) continue;
            seen.add(k);
            out.push(s);
        }
        return out;
    };

    const limited = (arr) => dedupe(arr).slice(0, 2);

    const pt = limited(byLang.PT);
    const en = limited(byLang.EN.length ? byLang.EN : pt);
    const es = limited(byLang.ES.length ? byLang.ES : en);

    return {
        PT: pt,
        EN: en,
        ES: es,
        DEFAULT: en.length ? en : pt,
    };
};

const getFirstCountryIso2FromAdapterPayload = (payload) => {
    const c = payload?.countries;

    if (Array.isArray(c) && c.length > 0) {
        const code = String(c[0] || '').toUpperCase().trim();
        return code.length === 2 ? code : null;
    }

    if (c && typeof c === 'object') {
        const candidates = [c.EN, c.PT, c.ES, c.DEFAULT].filter(Array.isArray);
        for (const arr of candidates) {
            if (arr.length === 0) continue;
            const code = String(arr[0] || '').toUpperCase().trim();
            if (code.length === 2) return code;
        }
    }

    return null;
};

const unwrapEntitiesMap = (entitiesResponse) => {
    if (!entitiesResponse) return {};
    if (entitiesResponse.entities && typeof entitiesResponse.entities === 'object') return entitiesResponse.entities;
    if (entitiesResponse.data?.entities && typeof entitiesResponse.data.entities === 'object') return entitiesResponse.data.entities;
    return entitiesResponse;
};

const getClaimSnaks = (entity, pid) => {
    const claims = entity?.claims || {};
    const arr = claims?.[pid];
    return Array.isArray(arr) ? arr : [];
};

const extractClaimEntityQids = (entity, pid) => {
    const out = [];
    for (const snak of getClaimSnaks(entity, pid)) {
        const v = snak?.mainsnak?.datavalue?.value;
        const id = v?.id || null;
        if (isQid(id)) out.push(id);
    }
    return out;
};

const extractClaimString = (entity, pid) => {
    for (const snak of getClaimSnaks(entity, pid)) {
        const v = snak?.mainsnak?.datavalue?.value;
        if (typeof v === 'string' && v.trim()) return v.trim();
    }
    return null;
};

const resolveCountryIso2FromCountryQid = async (countryQid) => {
    if (!isQid(countryQid)) return null;

    const entitiesRes = await getEntities({
        qids: [countryQid],
        languages: ['en'],
        props: ['claims', 'labels'],
    });

    const entities = unwrapEntitiesMap(entitiesRes);
    const country = entities?.[countryQid] || null;
    if (!country) return null;

    const iso2 = extractClaimString(country, 'P297');
    if (!iso2) return null;

    const code = iso2.toUpperCase().trim();
    return code.length === 2 ? code : null;
};

const resolveCountryQidFromEntity = (entity) => {
    return pickFirst(
        extractClaimEntityQids(entity, 'P17')[0],
                     extractClaimEntityQids(entity, 'P495')[0],
                     extractClaimEntityQids(entity, 'P27')[0]
    );
};

const resolveArtistCountryIso2 = async (artistQid) => {
    if (!isQid(artistQid)) return null;

    const entitiesRes = await getEntities({
        qids: [artistQid],
        languages: ['en'],
        props: ['claims', 'labels'],
    });

    const entities = unwrapEntitiesMap(entitiesRes);
    const artist = entities?.[artistQid] || null;
    if (!artist) return null;

    const countryQid = resolveCountryQidFromEntity(artist);
    return await resolveCountryIso2FromCountryQid(countryQid);
};

const resolveGameStudioCountryIso2 = async ({ studioName }) => {
    const studio = String(studioName || '').trim();
    if (!studio) return null;

    const results = await searchEntities({ query: studio, language: 'en', limit: 6 });
    const candidates = Array.isArray(results) ? results : [];

    for (const r of candidates) {
        const qid = r?.qid || r?.id || null;
        if (!isQid(qid)) continue;

        const label = r?.label || r?.name || null;
        if (label) {
            const a = normalizeComparableName(label);
            const b = normalizeComparableName(studio);
            if (a && b && a !== b && !a.includes(b) && !b.includes(a)) continue;
        }

        const entitiesRes = await getEntities({
            qids: [qid],
            languages: ['en'],
            props: ['claims', 'labels'],
        });

        const entities = unwrapEntitiesMap(entitiesRes);
        const ent = entities?.[qid] || null;
        if (!ent) continue;

        const countryQid = pickFirst(
            extractClaimEntityQids(ent, 'P17')[0],
                                     extractClaimEntityQids(ent, 'P495')[0]
        );

        const iso2 = await resolveCountryIso2FromCountryQid(countryQid);
        if (iso2) return iso2;
    }

    return null;
};

const parseLastfmMbidFromId = (id) => {
    const s = String(id || '').trim();
    if (!s.startsWith('lastfm_')) return null;
    const mbid = s.slice('lastfm_'.length);
    return mbid && mbid.length >= 8 ? mbid : null;
};

const scoreLastfmCandidate = ({ candidateTitle, candidateArtist, title, artist }) => {
    const ct = normalizeComparableName(candidateTitle);
    const ca = normalizeComparableName(candidateArtist);
    const t = normalizeComparableName(title);
    const a = normalizeComparableName(artist);

    let score = 0;

    if (ct && t) {
        if (ct === t) score += 60;
        else if (ct.includes(t) || t.includes(ct)) score += 35;
    }

    if (ca && a) {
        if (ca === a) score += 60;
        else if (ca.includes(a) || a.includes(ca)) score += 25;
    }

    return score;
};

const resolveLastfmAlbumMbid = async ({ title, artist }) => {
    const t = String(title || '').trim();
    if (!t) return null;

    const results = await lastfm.searchAlbums(t);
    const candidates = Array.isArray(results) ? results : [];

    let best = null;
    let bestScore = -1;

    for (const c of candidates) {
        const mbid = parseLastfmMbidFromId(c?.id);
        if (!mbid) continue;

        const s = scoreLastfmCandidate({
            candidateTitle: c?.title || c?.name || '',
            candidateArtist: c?.artist || '',
            title: t,
            artist: artist || '',
        });

        if (s > bestScore) {
            bestScore = s;
            best = { mbid, score: s };
        }
    }

    if (!best) return null;

    if (artist && best.score < 80) return null;
    if (!artist && best.score < 60) return null;

    return best.mbid;
};

const enrichFromApis = async ({ type, externalIds, canonicalTitle, canonicalCreatorName }) => {
    if (type === 'filme') {
        const tmdbId = externalIds?.tmdb || null;
        if (!tmdbId) return {};
        const data = await tmdb.getMovieData(tmdbId);
        return {
            synopses: data?.synopses || null,
            posterUrl: data?.posterUrl || null,
            backdropUrl: data?.backdropUrl || null,
            runtime: data?.runtime ?? null,
            countries: data?.countries || null,
        };
    }

    if (type === 'livro') {
        const workId = externalIds?.openLibraryWorkId || externalIds?.openLibrary || null;
        if (!workId) return {};
        const data = await books.getBookData(`ol_${workId}`);
        return {
            synopses: data?.synopses || null,
            posterUrl: data?.posterUrl || null,
            backdropUrl: data?.backdropUrl || null,
            countries: data?.countries || null,
        };
    }

    if (type === 'jogo') {
        const rawgId = externalIds?.rawg || null;
        if (!rawgId) return {};
        const data = await rawg.getGameData(rawgId);
        return {
            synopses: data?.synopses || null,
            posterUrl: data?.posterUrl || null,
            backdropUrl: data?.backdropUrl || null,
            runtime: data?.runtime ?? null,
            details: data?.details || null,
            studioName: data?.director || null,
        };
    }

    if (type === 'album') {
        const directMbid = pickFirst(
            externalIds?.mbid,
            externalIds?.musicBrainzReleaseId,
            null
        );

        const mbid =
        directMbid ||
        (await resolveLastfmAlbumMbid({
            title: canonicalTitle,
            artist: canonicalCreatorName
        }));

        if (!mbid) return {};

        const data = await lastfm.getAlbumData(mbid);
        return {
            synopses: data?.synopses || null,
            posterUrl: data?.posterUrl || null,
            details: data?.details || null,
            mbidUsed: mbid
        };
    }

    return {};
};

const BLOCKED_INSTANCE_OF_QIDS = [
    'Q24856',
'Q277759',
'Q7058673',
'Q196600',
];

const GENRE_ROOT_QIDS = [
    'Q132311',
'Q24925',
'Q16575965',
'Q19765983',
'Q1762165',
'Q21802675',
'Q40831',
'Q25372'
];

export const hydrateMediaReferenceByQid = async (qid, { forceRefresh = false } = {}) => {
    const canonicalId = String(qid || '').trim();
    if (!isQid(canonicalId)) {
        throw new Error('QID inválido.');
    }

    const accessedAt = now();

    const existing = await prisma.mediaReference.findUnique({
        where: { id: canonicalId },
    });

    if (existing && existing.isStub === false && !forceRefresh) {
        await prisma.mediaReference.update({
            where: { id: canonicalId },
            data: { lastAccessedAt: accessedAt },
        });
        return existing;
    }

    const type = existing?.type || null;
    if (!type) {
        throw new Error('Tipo de mídia não definido para este QID (stub ausente).');
    }

    const technical = await buildTechnicalDetailsFromWikidata({
        qid: canonicalId,
        type,
        blockedInstanceOfQids: BLOCKED_INSTANCE_OF_QIDS,
        genreRootQids: GENRE_ROOT_QIDS,
        maxGenres: 2,
    });

    if (!technical || technical.found === false) {
        throw new Error('Item não encontrado no Wikidata.');
    }

    if (technical.blocked) {
        throw new Error(technical.reason || 'Este item não pode ser exibido.');
    }

    const titles = applyTitleRulesByType(type, technical.titles);
    const canonicalTitle = pickFirst(titles.DEFAULT, titles.EN, titles.PT, titles.ES, null);

    const externalIds = {
        ...(existing?.externalIds && typeof existing.externalIds === 'object' ? existing.externalIds : {}),
        ...(technical.externalIds && typeof technical.externalIds === 'object' ? technical.externalIds : {}),
        wikidata: canonicalId,
    };

    const creatorName = technical.primaryCreator?.name || null;

    const enrichment = await enrichFromApis({
        type,
        externalIds,
        canonicalTitle,
        canonicalCreatorName: creatorName
    });

    let countryIso2 = technical.country?.iso2 || null;
    let countrySource = countryIso2 ? 'wikidata' : null;

    if (!countryIso2) {
        const wdCountryQid = technical.country?.qid || null;
        const iso2 = await resolveCountryIso2FromCountryQid(wdCountryQid);
        if (iso2) {
            countryIso2 = iso2;
            countrySource = 'wikidata';
        }
    }

    if (!countryIso2) {
        if (type === 'filme') {
            const tmdbIso2 = getFirstCountryIso2FromAdapterPayload(enrichment);
            if (tmdbIso2) {
                countryIso2 = tmdbIso2;
                countrySource = 'tmdb';
            }
        } else if (type === 'livro') {
            const bookIso2 = getFirstCountryIso2FromAdapterPayload(enrichment);
            if (bookIso2) {
                countryIso2 = bookIso2;
                countrySource = 'openlibrary';
            }
        } else if (type === 'album') {
            const artistQid = technical.primaryCreator?.qid || null;
            const artistIso2 = await resolveArtistCountryIso2(artistQid);
            if (artistIso2) {
                countryIso2 = artistIso2;
                countrySource = 'wikidata-artist';
            }
        } else if (type === 'jogo') {
            const studioIso2 = await resolveGameStudioCountryIso2({
                studioName: enrichment?.studioName || null,
            });
            if (studioIso2) {
                countryIso2 = studioIso2;
                countrySource = 'rawg-wikidata';
            }
        }
    }

    const countries = countryIso2 ? [countryIso2] : null;
    const genresForUi = buildGenresForUi(type, technical.genres);

    const canonicalGenres = Array.isArray(technical.genres)
    ? technical.genres.slice(0, 2).map((g) => {
        const base = pickFirst(g?.titles?.EN, g?.titles?.PT, g?.titles?.ES, null);
        return {
            qid: g?.qid || null,
            slug: base ? normalizeSlug(base) : null,
                                       titles: g?.titles || null,
        };
    }).filter((g) => isQid(g.qid))
    : [];

    const previousDetails = existing?.details && typeof existing.details === 'object' ? existing.details : {};
    const enrichmentDetails = enrichment?.details && typeof enrichment.details === 'object' ? enrichment.details : {};

    const mergedDetails = {
        ...previousDetails,
        ...enrichmentDetails,
        technical: {
            qid: canonicalId,
            type,
            releaseYear: technical.year ?? null,
            creator: technical.primaryCreator || null,
            countryIso2: countryIso2 || null,
            countryQid: technical.country?.qid || null,
            genres: canonicalGenres,
        },
    };

    if (type === 'album') {
        if (creatorName) mergedDetails.Artista = creatorName;
        if (enrichment?.mbidUsed) {
            mergedDetails.external = {
                ...(mergedDetails.external || {}),
                lastfmMbid: enrichment.mbidUsed
            };
        }
    }

    const dataToSave = {
        id: canonicalId,
        type,
        titles,

        releaseYear: technical.year ?? existing?.releaseYear ?? null,
        director: creatorName ?? existing?.director ?? null,

        genres: genresForUi,
        countries: countries,

        synopses: enrichment?.synopses ?? existing?.synopses ?? null,
        posterUrl: enrichment?.posterUrl ?? existing?.posterUrl ?? null,
        backdropUrl: enrichment?.backdropUrl ?? existing?.backdropUrl ?? null,
        runtime: enrichment?.runtime ?? existing?.runtime ?? null,

        details: mergedDetails,
        externalIds: externalIds,
        tags: existing?.tags ?? [],

        isStub: false,
        lastFetchedAt: accessedAt,
        lastAccessedAt: accessedAt,
        countrySource: countrySource,
    };

    if (existing) {
        const updateData = { ...dataToSave };
        delete updateData.id;

        return await prisma.mediaReference.update({
            where: { id: canonicalId },
            data: updateData,
        });
    }

    return await prisma.mediaReference.create({ data: dataToSave });
};
</file>

<file path="server/src/services/mediaSearch.service.js">
import prisma from '../lib/prisma.js';
import { createHash } from 'crypto';
import axios from 'axios';
import { searchEntities, getEntities, isQid } from '../utils/wikidata.adapter.js';

/*
 *  Objetivo desta versão:
 *  - Quando a query for de franquia, os resultados devem ser dominados por "core items"
 *    derivados de um hub, e ordenados de forma determinística (ordinal -> ano -> título).
 *  - Evitar itens irrelevantes subindo por "match textual" (ex: Narnia-Romanus).
 *  - Evitar o hub "guarda-chuva" aparecendo no meio do resultado quando existem partes.
 */

const WD_LANGS = ['pt-br', 'pt', 'en', 'es'];
const DB_LANGS = ['PT', 'EN', 'ES'];

const WD_CLAIMS = {
    instanceOf: 'P31',
    subclassOf: 'P279',

    publicationDate: 'P577',
        inception: 'P571',

        partOf: 'P361',
        partOfSeries: 'P179',
        hasPart: 'P527',
        seriesOrdinal: 'P1545',

        tmdbMovieId: 'P4947',
        rawgGameId: 'P9968',
        openLibraryId: 'P648',
        musicBrainzReleaseGroupId: 'P436'
};

const TYPE_ROOTS = {
    filme: ['Q11424'],
    jogo: ['Q7889'],
    album: ['Q482994'],
    livro: ['Q7725634', 'Q571']
};

const SERIES_BLACKLIST_ROOTS = [
    'Q24856', // film series
'Q277759', // book series
'Q7058673', // video game series
'Q196600' // media franchise
];

const SERIES_HUB_TYPE_BY_ROOT = {
    Q24856: 'filme',
    Q277759: 'livro'
};

const ROOTS_FOR_SPARQL = {
    filme: ['Q11424'],
    livro: ['Q571', 'Q7725634']
};

const safeUpper = (value) => String(value || '').trim().toUpperCase();

const uiLangToDbLang = (uiLang) => {
    const raw = safeUpper(uiLang);
    if (raw.startsWith('PT')) return 'PT';
    if (raw.startsWith('EN')) return 'EN';
    if (raw.startsWith('ES')) return 'ES';
    return 'PT';
};

const dbLangToWdLang = (dbLang) => {
    const raw = safeUpper(dbLang);
    if (raw === 'PT') return 'pt-br';
    if (raw === 'EN') return 'en';
    if (raw === 'ES') return 'es';
    return 'pt-br';
};

export const normalizeTitle = (value) => {
    const s = String(value ?? '')
    .normalize('NFKD')
    .replace(/[\u0300-\u036f]/g, '')
    .toLowerCase()
    .replace(/['"`´’]/g, '')
    .replace(/[^a-z0-9]+/g, ' ')
    .trim()
    .replace(/\s+/g, ' ');
    return s;
};

const countTerms = (queryNormalized) => {
    const q = String(queryNormalized || '').trim();
    if (!q) return 0;
    return q.split(' ').filter(Boolean).length;
};

const isFutureYear = (year) => {
    if (year == null) return false;
    const currentYear = new Date().getUTCFullYear();
    return year > currentYear;
};

const cleanTitleForUi = (value) => {
    const s0 = String(value || '').replace(/_/g, ' ').trim();
    if (!s0) return null;

    const m = s0.match(/^(.*)\s+\(([^)]+)\)\s*$/);
    if (!m) return s0;

    const base = String(m[1] || '').trim();
    const inside = String(m[2] || '').trim().toLowerCase();

    const looksLikeDisambiguation =
    /\bfilme\b/.test(inside) ||
    /\bfilm\b/.test(inside) ||
    /\blivro\b/.test(inside) ||
    /\bromance\b/.test(inside) ||
    /\bnovel\b/.test(inside) ||
    /\bjogo\b/.test(inside) ||
    /\bgame\b/.test(inside) ||
    /\bálbum\b/.test(inside) ||
    /\balbum\b/.test(inside) ||
    /\bsérie\b/.test(inside) ||
    /\bseries\b/.test(inside) ||
    /\b(19|20)\d{2}\b/.test(inside);

    if (looksLikeDisambiguation && base) return base;
    return s0;
};

const unwrapEntitiesMap = (res) => {
    if (!res) return {};
    if (res.entities && typeof res.entities === 'object') return res.entities;
    if (res.data?.entities && typeof res.data.entities === 'object') return res.data.entities;
    return res;
};

const normalizeSearchResults = (res) => {
    if (!res) return [];
    if (Array.isArray(res)) return res;
    if (Array.isArray(res.results)) return res.results;
    if (Array.isArray(res.search)) return res.search;
    if (Array.isArray(res.items)) return res.items;
    return [];
};

const callSearchEntities = async ({ query, language, limit }) => {
    try {
        return await searchEntities({ query, language, limit });
    } catch {
        return await searchEntities(query, language, limit);
    }
};

const callGetEntities = async ({ qids, languages, props }) => {
    try {
        return await getEntities({ qids, languages, props });
    } catch {
        return await getEntities(qids, languages, props);
    }
};

const chunk = (arr, n) => {
    const out = [];
    for (let i = 0; i < arr.length; i += n) out.push(arr.slice(i, i + n));
    return out;
};

const getClaimValues = (entity, property) => {
    const claims = entity?.claims?.[property];
    if (!Array.isArray(claims)) return [];
    const values = [];
    for (const claim of claims) {
        const dv = claim?.mainsnak?.datavalue?.value;
        if (dv == null) continue;
        values.push(dv);
    }
    return values;
};

const getClaimItemIds = (entity, property) => {
    const values = getClaimValues(entity, property);
    const ids = [];
    for (const v of values) {
        const qid = v?.id;
        if (isQid(qid)) ids.push(qid);
    }
    return ids;
};

const getClaimStringValues = (entity, property) => {
    const values = getClaimValues(entity, property);
    const out = [];
    for (const v of values) {
        if (typeof v === 'string' && v.trim()) out.push(v.trim());
    }
    return out;
};

const pickLabel = (labels, wdLang) => {
    const v = labels?.[wdLang]?.value;
    if (v && String(v).trim()) return cleanTitleForUi(String(v).trim());
    return null;
};

const pickSitelinkTitle = (sitelinks, wdLang) => {
    const key =
    wdLang === 'pt' || wdLang === 'pt-br'
    ? 'ptwiki'
    : wdLang === 'en'
    ? 'enwiki'
    : wdLang === 'es'
    ? 'eswiki'
    : null;

    if (!key) return null;
    const title = sitelinks?.[key]?.title;
    return title ? cleanTitleForUi(title) : null;
};

const pickAnyLabel = (labels) => {
    if (!labels || typeof labels !== 'object') return null;
    for (const k of Object.keys(labels)) {
        const v = labels?.[k]?.value;
        if (v && String(v).trim()) return cleanTitleForUi(String(v).trim());
    }
    return null;
};

const pickAnySitelink = (sitelinks) => {
    const order = ['ptwiki', 'enwiki', 'eswiki'];
    for (const k of order) {
        const t = sitelinks?.[k]?.title;
        if (t && String(t).trim()) return cleanTitleForUi(t);
    }
    return null;
};

const buildTitlesObjectByType = (entity, type) => {
    const titles = { PT: null, EN: null, ES: null };

    const ptbr = pickLabel(entity?.labels, 'pt-br');
    const pt = ptbr || pickLabel(entity?.labels, 'pt') || pickSitelinkTitle(entity?.sitelinks, 'pt');
    const en = pickLabel(entity?.labels, 'en') || pickSitelinkTitle(entity?.sitelinks, 'en');
    const es = pickLabel(entity?.labels, 'es') || pickSitelinkTitle(entity?.sitelinks, 'es');
    const any = pickAnyLabel(entity?.labels) || pickAnySitelink(entity?.sitelinks);

    if (type === 'jogo' || type === 'album') {
        const base = en || any || pt || es || null;
        titles.PT = base;
        titles.EN = base;
        titles.ES = base;
        return titles;
    }

    titles.PT = pt || en || es || any || null;
    titles.EN = en || pt || es || any || null;
    titles.ES = es || en || pt || any || null;

    return titles;
};

const extractYearFromTime = (timeValue) => {
    if (!timeValue) return null;
    const raw = String(timeValue);
    const m = raw.match(/[+-](\d{1,9})-/);
    if (!m) return null;

    const yearNum = Number.parseInt(m[1], 10);
    if (!Number.isFinite(yearNum)) return null;
    if (yearNum < 0 || yearNum > 9999) return null;

    return yearNum;
};

const extractYearFromEntity = (entity) => {
    let times = getClaimValues(entity, WD_CLAIMS.publicationDate);
    if (!times || times.length === 0) times = getClaimValues(entity, WD_CLAIMS.inception);
    return extractYearFromTime(times?.[0]?.time);
};

const extractExternalIds = (entity) => {
    const tmdb = getClaimStringValues(entity, WD_CLAIMS.tmdbMovieId)[0] || null;
    const rawg = getClaimStringValues(entity, WD_CLAIMS.rawgGameId)[0] || null;
    const openLibrary = getClaimStringValues(entity, WD_CLAIMS.openLibraryId)[0] || null;
    const musicBrainzReleaseGroup = getClaimStringValues(entity, WD_CLAIMS.musicBrainzReleaseGroupId)[0] || null;

    return {
        wikidata: entity?.id || null,
        tmdb,
        rawg,
        openLibrary,
        musicBrainzReleaseGroup
    };
};

const classAncestorsCache = new Map();

const getClassAncestors = async (classQid, { maxDepth = 4 } = {}) => {
    if (!isQid(classQid)) return new Set();

    const cached = classAncestorsCache.get(classQid);
    if (cached) return cached;

    const visited = new Set([classQid]);
    let frontier = [classQid];

    for (let depth = 0; depth < maxDepth && frontier.length > 0; depth += 1) {
        const res = await callGetEntities({
            qids: frontier,
            languages: ['en'],
            props: ['claims']
        });

        const entitiesMap = unwrapEntitiesMap(res);
        const next = [];

        for (const qid of frontier) {
            const ent = entitiesMap?.[qid];
            if (!ent) continue;

            const parents = getClaimItemIds(ent, WD_CLAIMS.subclassOf);
            for (const parentQid of parents) {
                if (!visited.has(parentQid)) {
                    visited.add(parentQid);
                    next.push(parentQid);
                }
            }
        }

        frontier = next;
    }

    classAncestorsCache.set(classQid, visited);
    return visited;
};

const isAnyClassInRoots = async (classQids, rootQids) => {
    const rootSet = new Set(rootQids);

    for (const classQid of classQids) {
        if (rootSet.has(classQid)) return true;

        const ancestors = await getClassAncestors(classQid);
        for (const a of ancestors) {
            if (rootSet.has(a)) return true;
        }
    }

    return false;
};

const detectSeriesHubType = async (entity) => {
    const instanceOf = getClaimItemIds(entity, WD_CLAIMS.instanceOf);
    if (instanceOf.length === 0) return null;

    for (const root of instanceOf) {
        const direct = SERIES_HUB_TYPE_BY_ROOT[root];
        if (direct) return direct;

        const ancestors = await getClassAncestors(root);
        for (const a of ancestors) {
            const t = SERIES_HUB_TYPE_BY_ROOT[a];
            if (t) return t;
        }
    }

    return null;
};

const inferMediaType = async (entity) => {
    const instanceOf = getClaimItemIds(entity, WD_CLAIMS.instanceOf);
    if (instanceOf.length === 0) return null;

    if (await isAnyClassInRoots(instanceOf, SERIES_BLACKLIST_ROOTS)) return null;

    for (const [type, roots] of Object.entries(TYPE_ROOTS)) {
        const ok = await isAnyClassInRoots(instanceOf, roots);
        if (ok) return type;
    }

    return null;
};

const scoreTextMatch = (candidate, queryNormalized) => {
    const c = normalizeTitle(candidate || '');
    if (!c) return 0;

    if (c === queryNormalized) return 100;
    if (c.startsWith(queryNormalized)) return 85;
    if (c.includes(queryNormalized)) return 65;
    if (queryNormalized.includes(c) && c.length >= 6) return 35;

    return 0;
};

const exactMatchUmbrellaPenalty = ({ title, queryNormalized }) => {
    const t = normalizeTitle(title || '');
    if (!t) return 0;
    if (t === queryNormalized) return 200;
    return 0;
};

const hashId = (seed) => createHash('sha1').update(seed).digest('hex');

const makeAliasId = ({ canonicalId, lang, titleNormalized, source }) => {
    const seed = `${canonicalId}|${lang}|${titleNormalized}|${source}`;
    return `ma_${hashId(seed)}`;
};

const upsertMediaReferenceStubMinimal = async ({
    qid,
    type,
    titles,
    year,
    externalIds,
    seriesOrdinal = null,
    partOfCount = null
}) => {
    const at = new Date();

    const technical = {
        qid,
        type,
        year: year ?? null,
        seriesOrdinal: Number.isFinite(seriesOrdinal) ? seriesOrdinal : null,
        partOfCount: Number.isFinite(partOfCount) ? partOfCount : null
    };

    return prisma.mediaReference.upsert({
        where: { id: qid },
        create: {
            id: qid,
            type,
            titles,
            synopses: {},
            posterUrl: null,
            backdropUrl: null,
            releaseYear: year ?? null,

            runtime: null,
            director: null,
            genres: null,
            countries: null,

            details: { technical },
            tags: [],
            externalIds,

            isStub: true,
            lastFetchedAt: at,
            lastAccessedAt: at,
            countrySource: null
        },
        update: {
            type,
            titles,
            releaseYear: year ?? null,
            externalIds,
            details: { technical },
            lastFetchedAt: at,
            lastAccessedAt: at
        }
    });
};

const upsertAliasesForEntity = async ({ qid, type, entity, titles }) => {
    const at = new Date();
    const rows = [];

    for (const dbLang of DB_LANGS) {
        const wdLang = dbLangToWdLang(dbLang);

        const label = titles?.[dbLang] || null;
        if (label) {
            const titleNormalized = normalizeTitle(label);
            if (titleNormalized) {
                rows.push({
                    id: makeAliasId({
                        canonicalId: qid,
                        lang: dbLang,
                        titleNormalized,
                        source: 'wikidata.label'
                    }),
                    canonicalId: qid,
                    type,
                    lang: dbLang,
                    title: label,
                    titleRaw: label,
                    titleNormalized,
                    source: 'wikidata.label',
                    lastAccessedAt: at
                });
            }
        }

        const wl = wdLang === 'pt-br' ? ['pt-br', 'pt'] : [wdLang];
        for (const langKey of wl) {
            const aliases = entity?.aliases?.[langKey];
            if (!Array.isArray(aliases)) continue;

            for (const a of aliases.slice(0, 12)) {
                const aliasValue = a?.value;
                if (!aliasValue || !String(aliasValue).trim()) continue;

                const aliasStr = cleanTitleForUi(String(aliasValue).trim());
                if (!aliasStr) continue;

                if (label && aliasStr.toLowerCase() === String(label).toLowerCase()) continue;

                const titleNormalized = normalizeTitle(aliasStr);
                if (!titleNormalized) continue;

                rows.push({
                    id: makeAliasId({
                        canonicalId: qid,
                        lang: dbLang,
                        titleNormalized,
                        source: 'wikidata.alias'
                    }),
                    canonicalId: qid,
                    type,
                    lang: dbLang,
                    title: aliasStr,
                    titleRaw: aliasStr,
                    titleNormalized,
                    source: 'wikidata.alias',
                    lastAccessedAt: at
                });
            }
        }
    }

    for (const row of rows) {
        await prisma.mediaAlias.upsert({
            where: { id: row.id },
            create: row,
            update: {
                title: row.title,
                titleRaw: row.titleRaw,
                lastAccessedAt: at
            }
        });
    }
};

const fetchMediaReferencesForIds = async (ids) => {
    const unique = Array.from(new Set(ids)).filter(Boolean);
    if (unique.length === 0) return [];

    return prisma.mediaReference.findMany({
        where: { id: { in: unique } }
    });
};

const mapReferenceToSearchItem = (ref, dbLang) => {
    const title = ref?.titles?.[dbLang] ?? ref?.titles?.PT ?? ref?.titles?.EN ?? ref?.titles?.ES ?? null;

    return {
        id: ref.id,
        type: ref.type,
        title,
        year: ref.releaseYear ?? null,
        poster: ref.posterUrl ?? null
    };
};

const shouldHide = (ref) => {
    if (!ref) return true;

    const type = ref.type;
    const year = ref.releaseYear ?? null;
    const ext = ref.externalIds && typeof ref.externalIds === 'object' ? ref.externalIds : {};

    if (year != null && isFutureYear(year)) return true;

    if (ref.isStub === true && (type === 'filme' || type === 'livro') && year == null) {
        const hasExternal = Boolean(ext.tmdb || ext.openLibrary || ext.openLibraryId);
        if (!hasExternal) return true;
    }

    return false;
};

/*
 *  SPARQL:
 *  Esta versão inclui P527 (has part) porque é essencial em casos tipo LOTR.
 *  Para evitar explosão,:
 *  - LIMIT baixo
 *  - filtra por root class (livro/filme)
 *  - timeout curto no HTTP client
 */
const sparqlHttp = axios.create({
    baseURL: 'https://query.wikidata.org/sparql',
    headers: {
        Accept: 'application/sparql-results+json',
        'User-Agent': 'Mazarbul/1.0 (https://github.com/0zzmandias/Mazarbul)'
    },
    timeout: 9000
});

const sparqlCache = new Map();

const sparqlQuery = async (query) => {
    const key = createHash('sha1').update(query).digest('hex');
    const cached = sparqlCache.get(key);
    if (cached) return cached;

    try {
        const { data } = await sparqlHttp.get('', {
            params: { format: 'json', query }
        });

        sparqlCache.set(key, data);
        return data;
    } catch {
        return null;
    }
};

const extractQidFromEntityUri = (uri) => {
    const s = String(uri || '');
    const idx = s.lastIndexOf('/');
    const q = idx >= 0 ? s.slice(idx + 1) : s;
    return isQid(q) ? q : null;
};

const sparqlCountHubMembers = async ({ hubQid, type }) => {
    if (!isQid(hubQid)) return 0;
    if (type !== 'livro' && type !== 'filme') return 0;

    const roots = ROOTS_FOR_SPARQL[type] || [];
    if (roots.length === 0) return 0;

    const valuesRoots = roots.map((r) => `wd:${r}`).join(' ');

    const q = `
    SELECT (COUNT(DISTINCT ?item) AS ?c) WHERE {
        {
            ?item wdt:P179 wd:${hubQid} .
        }
        UNION
        {
            ?item wdt:P361 wd:${hubQid} .
        }
        UNION
        {
            wd:${hubQid} wdt:P527 ?item .
        }

        VALUES ?root { ${valuesRoots} }
        ?item wdt:P31/wdt:P279* ?root .
    }
    `.trim();

    const data = await sparqlQuery(q);
    const b = data?.results?.bindings?.[0];
    const c = b?.c?.value ? Number.parseInt(String(b.c.value).trim(), 10) : 0;
    return Number.isFinite(c) ? c : 0;
};

const sparqlExpandHubParts = async ({ hubQid, type, limit = 80 }) => {
    if (!isQid(hubQid)) return [];
    if (type !== 'livro' && type !== 'filme') return [];

    const roots = ROOTS_FOR_SPARQL[type] || [];
    if (roots.length === 0) return [];

    const valuesRoots = roots.map((r) => `wd:${r}`).join(' ');

    const q = `
    SELECT ?item ?ordinal WHERE {
        {
            ?item p:P179 ?st .
            ?st ps:P179 wd:${hubQid} .
            OPTIONAL { ?st pq:P1545 ?ordinal . }
        }
        UNION
        {
            ?item p:P361 ?st2 .
            ?st2 ps:P361 wd:${hubQid} .
            OPTIONAL { ?st2 pq:P1545 ?ordinal . }
        }
        UNION
        {
            wd:${hubQid} p:P527 ?st3 .
            ?st3 ps:P527 ?item .
            OPTIONAL { ?st3 pq:P1545 ?ordinal . }
        }

        VALUES ?root { ${valuesRoots} }
        ?item wdt:P31/wdt:P279* ?root .
    }
    LIMIT ${Math.max(1, Math.min(limit, 120))}
    `.trim();

    const data = await sparqlQuery(q);
    const bindings = data?.results?.bindings;
    if (!Array.isArray(bindings)) return [];

    const out = [];
    for (const b of bindings) {
        const qid = extractQidFromEntityUri(b?.item?.value);
        if (!qid) continue;

        const ordRaw = b?.ordinal?.value;
        const ord = ordRaw ? Number.parseInt(String(ordRaw).trim(), 10) : null;

        out.push({
            qid,
            ordinal: Number.isFinite(ord) ? ord : null
        });
    }

    return out;
};

const bestTextScoreForEntity = (entity, titles, queryNormalized) => {
    let best = 0;
    for (const v of [titles?.PT, titles?.EN, titles?.ES]) {
        if (!v) continue;
        best = Math.max(best, scoreTextMatch(v, queryNormalized));
    }

    const wl = ['pt-br', 'pt', 'en', 'es'];
    for (const lang of wl) {
        const aliases = entity?.aliases?.[lang];
        if (!Array.isArray(aliases)) continue;
        for (const a of aliases.slice(0, 8)) {
            const t = a?.value;
            if (!t) continue;
            best = Math.max(best, scoreTextMatch(t, queryNormalized));
        }
    }

    return best;
};

const findHubs = async ({ query, dbLang }) => {
    const queryNormalized = normalizeTitle(query);
    const wdLangUi = dbLangToWdLang(dbLang);

    const langsToSearch = Array.from(new Set([wdLangUi, 'pt', 'en', 'es']));
    const searches = await Promise.allSettled(
        langsToSearch.map((lang) => callSearchEntities({ query, language: lang, limit: 20 }))
    );

    const seedQids = [];
    for (const s of searches) {
        if (s.status !== 'fulfilled') continue;
        const arr = normalizeSearchResults(s.value);
        for (const r of arr) {
            const qid = r?.qid || r?.id || null;
            if (isQid(qid)) seedQids.push(qid);
        }
    }

    const uniqueSeed = Array.from(new Set(seedQids)).slice(0, 60);
    if (uniqueSeed.length === 0) return { hubs: {}, isFranchise: false, hubParts: {} };

    const seedRes = await callGetEntities({
        qids: uniqueSeed,
        languages: WD_LANGS,
        props: ['labels', 'aliases', 'claims', 'sitelinks']
    });

    const seedMap = unwrapEntitiesMap(seedRes);

    // Avalia candidatos de hub de forma pragmática:
    // - match textual forte
    // - ou é hub explícito (film series / book series)
    // - ou tem hasPart (P527) relevante
    // - e confirma pelo menos 2 membros via SPARQL
    const candidatesByType = {
        livro: [],
        filme: []
    };

    for (const qid of uniqueSeed) {
        const entity = seedMap?.[qid];
        if (!entity) continue;

        const seriesHubType = await detectSeriesHubType(entity);
        const inferredType = seriesHubType || (await inferMediaType(entity));

        // Só consideramos hub para livro/filme
        if (inferredType !== 'livro' && inferredType !== 'filme') continue;

        const titles = buildTitlesObjectByType(entity, inferredType);
        const textScore = bestTextScoreForEntity(entity, titles, queryNormalized);

        const hasPartCount = getClaimItemIds(entity, WD_CLAIMS.hasPart).length;
        const hubBonus =
        (seriesHubType ? 140 : 0) +
        (hasPartCount >= 2 ? 90 : hasPartCount >= 1 ? 40 : 0);

        const totalScore = textScore + hubBonus;

        // Precisa ser um candidato razoável de hub
        if (totalScore < 110 && textScore < 85) continue;

        candidatesByType[inferredType].push({
            qid,
            inferredType,
            totalScore,
            textScore
        });
    }

    for (const t of ['livro', 'filme']) {
        candidatesByType[t].sort((a, b) => b.totalScore - a.totalScore);
        candidatesByType[t] = candidatesByType[t].slice(0, 6);
    }

    const hubs = {};
    const hubParts = { livro: new Map(), filme: new Map() };

    for (const t of ['livro', 'filme']) {
        for (const c of candidatesByType[t]) {
            const count = await sparqlCountHubMembers({ hubQid: c.qid, type: t });
            if (count >= 2) {
                hubs[t] = c.qid;
                break;
            }
        }
    }

    // Expande partes
    for (const t of Object.keys(hubs)) {
        const hubQid = hubs[t];
        const parts = await sparqlExpandHubParts({ hubQid, type: t, limit: 90 });
        for (const p of parts) {
            if (!isQid(p.qid)) continue;
            hubParts[t].set(p.qid, p.ordinal ?? null);
        }
    }

    const hasAnyHub = Object.keys(hubs).length > 0;
    const coreCount =
    (hubParts.livro?.size || 0) + (hubParts.filme?.size || 0);

    // Franchises:
    // - se tem hub com 2+ membros, é franquia
    // - ou se a query tem 2+ termos e tem pelo menos 2 membros totais
    const isFranchise =
    (hasAnyHub && coreCount >= 2) ||
    (countTerms(queryNormalized) >= 2 && coreCount >= 2);

    return { hubs, isFranchise, hubParts };
};

const dbFetchAliasPool = async ({ queryNormalized, type, preferredLang, pool = 200 }) => {
    const whereType = type ? { type } : {};

    const langs = preferredLang
    ? [preferredLang, ...DB_LANGS.filter((l) => l !== preferredLang)]
    : DB_LANGS;

    const exact = await prisma.mediaAlias.findMany({
        where: {
            ...whereType,
            lang: { in: langs },
            titleNormalized: queryNormalized
        },
        take: Math.min(pool, 250)
    });

    const prefix = await prisma.mediaAlias.findMany({
        where: {
            ...whereType,
            lang: { in: langs },
            titleNormalized: { startsWith: queryNormalized }
        },
        take: Math.min(pool, 250)
    });

    // Determinístico: escolhe por melhor "qualidade" da linha, não por lastAccessedAt
    const langPriority = new Map(langs.map((l, i) => [l, i]));
    const sourcePriority = (src) => {
        if (src === 'wikidata.label') return 0;
        if (src === 'wikidata.alias') return 1;
        return 2;
    };

    const bestByCanonical = new Map();
    for (const row of [...exact, ...prefix]) {
        const canonicalId = row?.canonicalId;
        if (!canonicalId) continue;

        const prev = bestByCanonical.get(canonicalId);
        const curKey = {
            lang: langPriority.get(row.lang) ?? 99,
            source: sourcePriority(row.source),
            title: row.titleNormalized || '',
            id: row.id || ''
        };

        if (!prev) {
            bestByCanonical.set(canonicalId, { row, key: curKey });
            continue;
        }

        const prevKey = prev.key;
        const better =
        curKey.lang < prevKey.lang ||
        (curKey.lang === prevKey.lang && curKey.source < prevKey.source) ||
        (curKey.lang === prevKey.lang && curKey.source === prevKey.source && curKey.title < prevKey.title) ||
        (curKey.lang === prevKey.lang && curKey.source === prevKey.source && curKey.title === prevKey.title && curKey.id < prevKey.id);

        if (better) bestByCanonical.set(canonicalId, { row, key: curKey });
    }

    return Array.from(bestByCanonical.keys());
};

const sortCoreGroup = ({ refs, dbLang, ordinalsMap }) => {
    const items = refs.map((r) => {
        const tech = r?.details?.technical || {};
        const ordinal = ordinalsMap?.get(r.id) ?? (Number.isFinite(tech?.seriesOrdinal) ? tech.seriesOrdinal : null);
        const year = r.releaseYear ?? null;

        const title = r?.titles?.[dbLang] ?? r?.titles?.PT ?? r?.titles?.EN ?? r?.titles?.ES ?? '';

        return { ref: r, ordinal: Number.isFinite(ordinal) ? ordinal : null, year, title: String(title || '') };
    });

    const hasTwoOrdinals = items.filter((x) => x.ordinal != null).length >= 2;

    items.sort((a, b) => {
        if (hasTwoOrdinals) {
            const ao = a.ordinal != null ? a.ordinal : 99999;
            const bo = b.ordinal != null ? b.ordinal : 99999;
            if (ao !== bo) return ao - bo;
        }

        const ay = Number.isFinite(a.year) ? a.year : 99999;
        const by = Number.isFinite(b.year) ? b.year : 99999;
        if (ay !== by) return ay - by;

        const at = a.title.toLowerCase();
        const bt = b.title.toLowerCase();
        if (at < bt) return -1;
        if (at > bt) return 1;

        return a.ref.id.localeCompare(b.ref.id);
    });

    return items.map((x) => x.ref);
};

const determineTypeOrderForFranchise = ({ bookRefs, filmRefs }) => {
    const earliestYear = (refs) => {
        let best = null;
        for (const r of refs) {
            const y = r?.releaseYear ?? null;
            if (!Number.isFinite(y)) continue;
            if (best == null || y < best) best = y;
        }
        return best;
    };

    const b = earliestYear(bookRefs);
    const f = earliestYear(filmRefs);

    if (b != null && f != null) {
        if (b <= f) return ['livro', 'filme', 'jogo', 'album'];
        return ['filme', 'livro', 'jogo', 'album'];
    }
    if (b != null) return ['livro', 'filme', 'jogo', 'album'];
    if (f != null) return ['filme', 'livro', 'jogo', 'album'];

    return ['livro', 'filme', 'jogo', 'album'];
};

const populateStubsForQids = async ({ qids }) => {
    const unique = Array.from(new Set(qids)).filter(Boolean);
    if (unique.length === 0) return;

    // Busca em blocos para evitar URLs gigantes
    const batches = chunk(unique, 40);
    for (const batch of batches) {
        const res = await callGetEntities({
            qids: batch,
            languages: WD_LANGS,
            props: ['labels', 'aliases', 'claims', 'sitelinks']
        });

        const map = unwrapEntitiesMap(res);

        for (const qid of batch) {
            const entity = map?.[qid];
            if (!entity) continue;

            const seriesHubType = await detectSeriesHubType(entity);
            if (seriesHubType) continue;

            const inferredType = await inferMediaType(entity);
            if (!inferredType) continue;

            const titles = buildTitlesObjectByType(entity, inferredType);
            const year = extractYearFromEntity(entity);
            const externalIds = extractExternalIds({ ...entity, id: qid });

            if (year != null && isFutureYear(year)) continue;

            const partOfCount =
            getClaimItemIds(entity, WD_CLAIMS.partOf).length +
            getClaimItemIds(entity, WD_CLAIMS.partOfSeries).length;

            const rawOrd = getClaimStringValues(entity, WD_CLAIMS.seriesOrdinal)[0] || null;
            const ordinal = rawOrd ? Number.parseInt(String(rawOrd).trim(), 10) : null;

            await upsertMediaReferenceStubMinimal({
                qid,
                type: inferredType,
                titles,
                year,
                externalIds,
                seriesOrdinal: Number.isFinite(ordinal) ? ordinal : null,
                                                  partOfCount: Number.isFinite(partOfCount) ? partOfCount : null
            });

            await upsertAliasesForEntity({
                qid,
                type: inferredType,
                entity,
                titles
            });
        }
    }
};

const wikidataSimplePopulate = async ({ query, uiLang, type, remaining }) => {
    const dbLang = uiLangToDbLang(uiLang);
    const queryNormalized = normalizeTitle(query);
    const wdLangUi = dbLangToWdLang(dbLang);

    const langsToSearch = Array.from(new Set([wdLangUi, 'pt', 'en', 'es']));

    const searches = await Promise.allSettled(
        langsToSearch.map((lang) => callSearchEntities({ query, language: lang, limit: 25 }))
    );

    const qids = [];
    for (const s of searches) {
        if (s.status !== 'fulfilled') continue;
        const arr = normalizeSearchResults(s.value);
        for (const r of arr) {
            const qid = r?.qid || r?.id || null;
            if (isQid(qid)) qids.push(qid);
        }
    }

    const seedQids = Array.from(new Set(qids)).slice(0, 100);
    if (seedQids.length === 0) return [];

    const res = await callGetEntities({
        qids: seedQids,
        languages: WD_LANGS,
        props: ['labels', 'aliases', 'claims', 'sitelinks']
    });

    const map = unwrapEntitiesMap(res);
    const currentYear = new Date().getUTCFullYear();

    const candidates = [];
    for (const qid of seedQids) {
        const entity = map?.[qid];
        if (!entity) continue;

        const seriesHubType = await detectSeriesHubType(entity);
        if (seriesHubType) continue;

        const inferredType = await inferMediaType(entity);
        if (!inferredType) continue;
        if (type && inferredType !== type) continue;

        const titles = buildTitlesObjectByType(entity, inferredType);
        const year = extractYearFromEntity(entity);
        const externalIds = extractExternalIds({ ...entity, id: qid });

        if (year != null && year > currentYear) continue;

        // filtro de qualidade para livro/filme sem ano
        if ((inferredType === 'livro' || inferredType === 'filme') && year == null) {
            const ok = inferredType === 'filme' ? Boolean(externalIds?.tmdb) : Boolean(externalIds?.openLibrary);
            if (!ok) continue;
        }

        const titleForScore = titles?.[dbLang] || titles?.PT || titles?.EN || titles?.ES || '';
        const baseScore =
        scoreTextMatch(titleForScore, queryNormalized) +
        bestTextScoreForEntity(entity, titles, queryNormalized);

        const penalty = exactMatchUmbrellaPenalty({ title: titleForScore, queryNormalized });

        let score = baseScore - penalty;
        if (year != null) score += 10;
        if (inferredType === 'filme' && externalIds?.tmdb) score += 10;
        if (inferredType === 'livro' && externalIds?.openLibrary) score += 10;

        candidates.push({
            qid,
            inferredType,
            titles,
            year,
            externalIds,
            entity,
            score
        });
    }

    candidates.sort((a, b) => b.score - a.score || String(a.qid).localeCompare(String(b.qid)));

    const picked = [];
    const pickedSet = new Set();

    for (const c of candidates) {
        if (picked.length >= remaining) break;
        if (pickedSet.has(c.qid)) continue;
        pickedSet.add(c.qid);
        picked.push(c);
    }

    const created = [];
    for (const c of picked) {
        const partOfCount =
        getClaimItemIds(c.entity, WD_CLAIMS.partOf).length +
        getClaimItemIds(c.entity, WD_CLAIMS.partOfSeries).length;

        const rawOrd = getClaimStringValues(c.entity, WD_CLAIMS.seriesOrdinal)[0] || null;
        const ordinal = rawOrd ? Number.parseInt(String(rawOrd).trim(), 10) : null;

        await upsertMediaReferenceStubMinimal({
            qid: c.qid,
            type: c.inferredType,
            titles: c.titles,
            year: c.year,
            externalIds: c.externalIds,
            seriesOrdinal: Number.isFinite(ordinal) ? ordinal : null,
                                              partOfCount: Number.isFinite(partOfCount) ? partOfCount : null
        });

        await upsertAliasesForEntity({
            qid: c.qid,
            type: c.inferredType,
            entity: c.entity,
            titles: c.titles
        });

        created.push(c.qid);
    }

    return created;
};

export const searchUnifiedMedia = async ({ query, uiLang = 'PT', type = null, limit = 20 }) => {
    const q = String(query || '').trim();
    if (q.length < 2) return [];

    const dbLang = uiLangToDbLang(uiLang);
    const queryNormalized = normalizeTitle(q);
    if (!queryNormalized) return [];

    // 1) Tenta detectar hubs e core items para modo franquia
    const { hubs, isFranchise, hubParts } = await findHubs({ query: q, dbLang });

    const hubQidsToExclude = new Set(Object.values(hubs).filter(Boolean));

    // 2) DB pool determinístico
    const aliasIds = await dbFetchAliasPool({
        queryNormalized,
        type,
        preferredLang: dbLang,
        pool: 240
    });

    let dbRefs = [];
    if (aliasIds.length > 0) {
        dbRefs = await fetchMediaReferencesForIds(aliasIds);
        dbRefs = dbRefs.filter((r) => !shouldHide(r));
    }

    // Se estamos em modo franquia e temos core, o core manda no topo e "filtra" irrelevantes
    if (isFranchise) {
        const coreBookIds = Array.from(hubParts.livro?.keys?.() || []);
        const coreFilmIds = Array.from(hubParts.filme?.keys?.() || []);
        const coreIds = Array.from(new Set([...coreBookIds, ...coreFilmIds])).filter(Boolean);

        // Se core for pequeno demais, volta para modo normal
        if (coreIds.length >= 2) {
            // Garante que o core exista no DB como stubs
            await populateStubsForQids({ qids: coreIds });

            const coreRefs = await fetchMediaReferencesForIds(coreIds);
            const bookCoreRefs = coreRefs.filter((r) => r.type === 'livro' && !shouldHide(r));
            const filmCoreRefs = coreRefs.filter((r) => r.type === 'filme' && !shouldHide(r));

            // Remove hubs do resultado quando existem partes (evita "Harry Potter" e similares)
            const hubRefsFiltered = dbRefs.filter((r) => !hubQidsToExclude.has(r.id));

            // Ordena core por ordinal/ano
            const sortedBookCore = sortCoreGroup({
                refs: bookCoreRefs.filter((r) => !hubQidsToExclude.has(r.id)),
                                                 dbLang,
                                                 ordinalsMap: hubParts.livro
            });

            const sortedFilmCore = sortCoreGroup({
                refs: filmCoreRefs.filter((r) => !hubQidsToExclude.has(r.id)),
                                                 dbLang,
                                                 ordinalsMap: hubParts.filme
            });

            const typeOrder = determineTypeOrderForFranchise({
                bookRefs: sortedBookCore,
                filmRefs: sortedFilmCore
            });

            const coreOrdered = [];
            for (const t of typeOrder) {
                if (t === 'livro') coreOrdered.push(...sortedBookCore);
                if (t === 'filme') coreOrdered.push(...sortedFilmCore);
            }

            const coreSet = new Set(coreOrdered.map((r) => r.id));

            // Extras: só entram se tiverem match textual forte e qualidade mínima
            const extras = [];
            for (const r of hubRefsFiltered) {
                if (coreSet.has(r.id)) continue;
                if (hubQidsToExclude.has(r.id)) continue;

                if (type && r.type !== type) continue;

                const title = r?.titles?.[dbLang] ?? r?.titles?.PT ?? r?.titles?.EN ?? r?.titles?.ES ?? '';
                const score = scoreTextMatch(title, queryNormalized);
                if (score < 65) continue;

                const year = r.releaseYear ?? null;
                const ext = r.externalIds && typeof r.externalIds === 'object' ? r.externalIds : {};
                const hasExternal = Boolean(ext.tmdb || ext.openLibrary || ext.openLibraryId || ext.rawg || ext.musicBrainzReleaseGroup);

                // filtro anti lixo (ex: Narnia-Romanus de 1886)
                if (!hasExternal && (year == null || year < 1900)) continue;
                if (year != null && isFutureYear(year)) continue;

                // penaliza guarda-chuva fora do core
                const penalty = exactMatchUmbrellaPenalty({ title, queryNormalized });

                extras.push({
                    ref: r,
                    type: r.type,
                    score: score - penalty,
                    year: year ?? 99999,
                    title: String(title || '').toLowerCase()
                });
            }

            extras.sort((a, b) => {
                const typeIdx = (t) => {
                    const i = typeOrder.indexOf(t);
                    return i >= 0 ? i : 99;
                };

                const ai = typeIdx(a.type);
                const bi = typeIdx(b.type);
                if (ai !== bi) return ai - bi;

                if (b.score !== a.score) return b.score - a.score;

                if (a.year !== b.year) return a.year - b.year;

                if (a.title < b.title) return -1;
                if (a.title > b.title) return 1;

                return a.ref.id.localeCompare(b.ref.id);
            });

            const finalRefs = [];

            for (const r of coreOrdered) {
                if (finalRefs.length >= limit) break;
                finalRefs.push(r);
            }

            for (const e of extras) {
                if (finalRefs.length >= limit) break;
                finalRefs.push(e.ref);
            }

            // Se ainda falta, complementa com WD simples
            const remaining = Math.max(0, limit - finalRefs.length);
            if (remaining > 0) {
                const created = await wikidataSimplePopulate({ query: q, uiLang, type, remaining });
                if (created.length > 0) {
                    const newRefs = await fetchMediaReferencesForIds(created);
                    for (const r of newRefs) {
                        if (finalRefs.length >= limit) break;
                        if (!r || shouldHide(r)) continue;
                        if (hubQidsToExclude.has(r.id)) continue;
                        if (coreSet.has(r.id)) continue;
                        finalRefs.push(r);
                    }
                }
            }

            return finalRefs
            .filter((r) => r && !shouldHide(r))
            .slice(0, limit)
            .map((r) => mapReferenceToSearchItem(r, dbLang));
        }
    }

    // Modo normal (não-franquia): DB primeiro, depois WD simples
    const scoredDb = dbRefs
    .filter((r) => !hubQidsToExclude.has(r.id))
    .map((r) => {
        const title =
        r?.titles?.[dbLang] ?? r?.titles?.PT ?? r?.titles?.EN ?? r?.titles?.ES ?? '';

        const base = scoreTextMatch(title, queryNormalized);
        const penalty = exactMatchUmbrellaPenalty({ title, queryNormalized });
        const year = r.releaseYear ?? null;

        let s = base - penalty;
        if (year != null) s += 5;
        if (r.isStub === false) s += 3;

        const ext = r.externalIds && typeof r.externalIds === 'object' ? r.externalIds : {};
        if (r.type === 'filme' && ext.tmdb) s += 10;
        if (r.type === 'livro' && (ext.openLibrary || ext.openLibraryId)) s += 10;
        if (r.type === 'jogo' && ext.rawg) s += 6;
        if (r.type === 'album' && ext.musicBrainzReleaseGroup) s += 4;

        return {
            ref: r,
            score: s,
            type: r.type,
            year: Number.isFinite(year) ? year : 99999,
         title: String(title || '').toLowerCase()
        };
    });

    // Determinístico
    const typeOrder = ['filme', 'livro', 'jogo', 'album'];
    const typeIdx = (t) => {
        const i = typeOrder.indexOf(t);
        return i >= 0 ? i : 99;
    };

    scoredDb.sort((a, b) => {
        const ai = typeIdx(a.type);
        const bi = typeIdx(b.type);
        if (ai !== bi) return ai - bi;

        if (b.score !== a.score) return b.score - a.score;

        // Em modo normal, preferimos mais recente dentro do tipo como desempate
        if (a.year !== b.year) return b.year - a.year;

        if (a.title < b.title) return -1;
        if (a.title > b.title) return 1;

        return a.ref.id.localeCompare(b.ref.id);
    });

    const pickedRefs = [];
    const seen = new Set();

    for (const x of scoredDb) {
        if (pickedRefs.length >= limit) break;
        if (!x?.ref?.id) continue;
        if (seen.has(x.ref.id)) continue;
        seen.add(x.ref.id);
        pickedRefs.push(x.ref);
    }

    const remaining = Math.max(0, limit - pickedRefs.length);
    if (remaining > 0) {
        const created = await wikidataSimplePopulate({ query: q, uiLang, type, remaining });
        if (created.length > 0) {
            const newRefs = await fetchMediaReferencesForIds(created);
            for (const r of newRefs) {
                if (pickedRefs.length >= limit) break;
                if (!r || shouldHide(r)) continue;
                if (hubQidsToExclude.has(r.id)) continue;
                if (seen.has(r.id)) continue;
                seen.add(r.id);
                pickedRefs.push(r);
            }
        }
    }

    return pickedRefs
    .filter((r) => r && !shouldHide(r))
    .slice(0, limit)
    .map((r) => mapReferenceToSearchItem(r, dbLang));
};
</file>

<file path="server/src/utils/wikidata.adapter.js">
import axios from 'axios';

const WIKIDATA_API_URL = 'https://www.wikidata.org/w/api.php';

const wikidataClient = axios.create({
    baseURL: WIKIDATA_API_URL,
    timeout: 15000,
    headers: {
        'User-Agent': 'Mazarbul/1.0 (Wikidata integration; no personal data)'
    }
});

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const getHttpStatus = (error) => error?.response?.status ?? null;

const requestWithRetry = async (makeRequest, { retries = 2 } = {}) => {
    let lastError = null;

    for (let attempt = 0; attempt <= retries; attempt += 1) {
        try {
            return await makeRequest();
        } catch (error) {
            lastError = error;

            const status = getHttpStatus(error);
            const isRetryable = status === 429 || (status != null && status >= 500 && status <= 599);

            if (!isRetryable || attempt === retries) {
                throw error;
            }

            const backoffMs = 250 * Math.pow(2, attempt);
            await sleep(backoffMs);
        }
    }

    throw lastError;
};

export const normalizeUiLangToWikidataLang = (lang) => {
    if (!lang) return 'pt';

    const normalized = String(lang).trim().toLowerCase();

    if (normalized === 'pt') return 'pt';
    if (normalized === 'en') return 'en';
    if (normalized === 'es') return 'es';

    if (normalized === 'pt-br' || normalized === 'pt_br') return 'pt';
    if (normalized === 'en-us' || normalized === 'en_us') return 'en';
    if (normalized === 'es-es' || normalized === 'es_es') return 'es';

    if (normalized.startsWith('pt')) return 'pt';
    if (normalized.startsWith('en')) return 'en';
    if (normalized.startsWith('es')) return 'es';

    return 'pt';
};

export const isQid = (value) => /^Q\d+$/.test(String(value ?? '').trim());

export const WD_PROPS = {
    INSTANCE_OF: 'P31',
    GENRE: 'P136',
    SUBCLASS_OF: 'P279',
    PUBLICATION_DATE: 'P577',
    COUNTRY_OF_ORIGIN: 'P495',
    ISO3166_ALPHA2: 'P297',

    DIRECTOR: 'P57',
    AUTHOR: 'P50',
    DEVELOPER: 'P178',
    PUBLISHER: 'P123',
    PERFORMER: 'P175',
    CREATOR_GENERIC: 'P170',

    TMDB_MOVIE_ID: 'P4947',
    RAWG_GAME_ID: 'P9968',
    OPEN_LIBRARY_ID: 'P648',
    MUSICBRAINZ_RELEASE_GROUP_ID: 'P436'
};

export const PRIMARY_CREATOR_PROPS_BY_TYPE = {
    filme: [WD_PROPS.DIRECTOR, WD_PROPS.CREATOR_GENERIC],
    livro: [WD_PROPS.AUTHOR, WD_PROPS.CREATOR_GENERIC],
    jogo: [WD_PROPS.DEVELOPER, WD_PROPS.PUBLISHER, WD_PROPS.CREATOR_GENERIC],
    album: [WD_PROPS.PERFORMER, WD_PROPS.CREATOR_GENERIC]
};

export const makeWikidataCache = () => ({
    entities: new Map(),
                                        countryIso2: new Map(),
                                        labels: new Map()
});

const getClaimArray = (entity, prop) => {
    const claims = entity?.claims ?? null;
    if (!claims) return [];
    const arr = claims[prop];
    return Array.isArray(arr) ? arr : [];
};

const getDatavalue = (claim) => claim?.mainsnak?.datavalue ?? null;

const getDatavalueType = (dv) => dv?.type ?? null;

const getDatavalueValue = (dv) => dv?.value ?? null;

const getEntityIdFromDatavalue = (dv) => {
    if (!dv) return null;
    if (getDatavalueType(dv) !== 'wikibase-entityid') return null;

    const v = getDatavalueValue(dv);
    const id = v?.id ?? null;
    return isQid(id) ? id : null;
};

const getStringFromDatavalue = (dv) => {
    if (!dv) return null;
    const v = getDatavalueValue(dv);

    if (typeof v === 'string') return v;
    if (typeof v === 'number') return String(v);

    return null;
};

const getTimeFromDatavalue = (dv) => {
    if (!dv) return null;
    if (getDatavalueType(dv) !== 'time') return null;
    const v = getDatavalueValue(dv);
    return v?.time ?? null;
};

export const parseWikidataTimeToYear = (timeString) => {
    if (!timeString || typeof timeString !== 'string') return null;

    const match = timeString.match(/^([+-]?\d{1,})-/);
    if (!match) return null;

    const yearNum = Number(match[1]);
    if (!Number.isFinite(yearNum)) return null;

    return yearNum;
};

const uniq = (arr) => Array.from(new Set(arr));

const pickBestLabel = (labelsObj, langOrder = ['pt', 'en', 'es']) => {
    const labels = labelsObj ?? {};
    for (const lang of langOrder) {
        const v = labels?.[lang]?.value;
        if (v && String(v).trim()) return String(v);
    }

    const firstKey = Object.keys(labels)[0];
    const any = firstKey ? labels?.[firstKey]?.value : null;
    return any && String(any).trim() ? String(any) : null;
};

export const getTitlesPTENES = (entity) => {
    const labels = entity?.labels ?? {};
    const pt = labels?.pt?.value ?? null;
    const en = labels?.en?.value ?? null;
    const es = labels?.es?.value ?? null;

    return {
        PT: pt,
        EN: en,
        ES: es
    };
};

const getEntityCached = async ({ qid, languages, props, cache }) => {
    const key = String(qid ?? '').trim();
    if (!isQid(key)) return null;

    if (cache?.entities?.has(key)) {
        return cache.entities.get(key) ?? null;
    }

    const entity = await getEntity({ qid: key, languages, props });
    if (cache?.entities) cache.entities.set(key, entity ?? null);
    return entity ?? null;
};

export const searchEntities = async ({ query, language = 'pt', limit = 10 }) => {
    if (!query || !String(query).trim()) {
        return [];
    }

    const lang = normalizeUiLangToWikidataLang(language);

    const response = await requestWithRetry(() =>
    wikidataClient.get('', {
        params: {
            action: 'wbsearchentities',
            format: 'json',
                type: 'item',
                search: String(query),
                       language: lang,
                       uselang: lang,
                       limit
        }
    })
    );

    const results = response?.data?.search ?? [];

    return results
    .filter((r) => isQid(r?.id))
    .map((r) => ({
        qid: r.id,
        label: r.label ?? null,
        description: r.description ?? null,
        conceptUri: r.concepturi ?? null
    }));
};

export const getEntities = async ({
    qids,
    languages = ['pt', 'en', 'es'],
    props = ['labels', 'aliases', 'descriptions', 'claims']
}) => {
    const ids = Array.isArray(qids) ? qids : [qids];
    const cleanIds = ids.map((id) => String(id ?? '').trim()).filter((id) => isQid(id));

    if (cleanIds.length === 0) {
        return {};
    }

    const langs = Array.isArray(languages) ? languages : [languages];
    const cleanLangs = langs.map(normalizeUiLangToWikidataLang);

    const response = await requestWithRetry(() =>
    wikidataClient.get('', {
        params: {
            action: 'wbgetentities',
            format: 'json',
                ids: cleanIds.join('|'),
                       languages: cleanLangs.join('|'),
                       props: props.join('|')
        }
    })
    );

    return response?.data?.entities ?? {};
};

export const getEntity = async ({
    qid,
    languages = ['pt', 'en', 'es'],
    props = ['labels', 'aliases', 'descriptions', 'claims']
}) => {
    const entities = await getEntities({ qids: [qid], languages, props });
    return entities?.[qid] ?? null;
};

export const extractTechnicalClaims = ({ entity, type }) => {
    const instanceOfQids = getClaimArray(entity, WD_PROPS.INSTANCE_OF)
    .map(getDatavalue)
    .map(getEntityIdFromDatavalue)
    .filter(Boolean);

    const genreQids = getClaimArray(entity, WD_PROPS.GENRE)
    .map(getDatavalue)
    .map(getEntityIdFromDatavalue)
    .filter(Boolean);

    const countryQids = getClaimArray(entity, WD_PROPS.COUNTRY_OF_ORIGIN)
    .map(getDatavalue)
    .map(getEntityIdFromDatavalue)
    .filter(Boolean);

    const timeYears = getClaimArray(entity, WD_PROPS.PUBLICATION_DATE)
    .map(getDatavalue)
    .map(getTimeFromDatavalue)
    .map(parseWikidataTimeToYear)
    .filter((y) => typeof y === 'number' && Number.isFinite(y));

    const year = timeYears.length > 0 ? Math.min(...timeYears) : null;

    const creatorProps = PRIMARY_CREATOR_PROPS_BY_TYPE[type] ?? [WD_PROPS.CREATOR_GENERIC];
    const creatorQids = creatorProps.flatMap((prop) =>
    getClaimArray(entity, prop).map(getDatavalue).map(getEntityIdFromDatavalue).filter(Boolean)
    );

    const externalIds = {
        tmdb:
        getClaimArray(entity, WD_PROPS.TMDB_MOVIE_ID)
        .map(getDatavalue)
        .map(getStringFromDatavalue)
        .filter(Boolean)[0] ?? null,
        rawg:
        getClaimArray(entity, WD_PROPS.RAWG_GAME_ID)
        .map(getDatavalue)
        .map(getStringFromDatavalue)
        .filter(Boolean)[0] ?? null,
        openLibrary:
        getClaimArray(entity, WD_PROPS.OPEN_LIBRARY_ID)
        .map(getDatavalue)
        .map(getStringFromDatavalue)
        .filter(Boolean)[0] ?? null,
        musicbrainzReleaseGroup:
        getClaimArray(entity, WD_PROPS.MUSICBRAINZ_RELEASE_GROUP_ID)
        .map(getDatavalue)
        .map(getStringFromDatavalue)
        .filter(Boolean)[0] ?? null
    };

    return {
        qid: entity?.id ?? null,
        instanceOfQids: uniq(instanceOfQids),
        year,
        countryQids: uniq(countryQids),
        genreQids: uniq(genreQids),
        primaryCreatorQids: uniq(creatorQids),
        externalIds
    };
};

export const isBlockedByInstanceOf = ({ instanceOfQids, blockedInstanceOfQids }) => {
    const blocked = Array.isArray(blockedInstanceOfQids) ? blockedInstanceOfQids : [];
    if (blocked.length === 0) return false;

    const set = new Set(blocked.filter(isQid));
    for (const qid of instanceOfQids ?? []) {
        if (set.has(qid)) return true;
    }
    return false;
};

export const getLabelForQid = async ({ qid, uiLang = 'pt', cache }) => {
    const lang = normalizeUiLangToWikidataLang(uiLang);
    const cacheKey = `${qid}|${lang}`;

    if (cache?.labels?.has(cacheKey)) {
        return cache.labels.get(cacheKey) ?? null;
    }

    const entity = await getEntityCached({
        qid,
        languages: [lang, 'en', 'pt', 'es'],
        props: ['labels'],
        cache
    });

    const label = pickBestLabel(entity?.labels, [lang, 'en', 'pt', 'es']);
    if (cache?.labels) cache.labels.set(cacheKey, label ?? null);
    return label ?? null;
};

export const getCountryIso2ByCountryQid = async ({ countryQid, uiLang = 'pt', cache }) => {
    if (!isQid(countryQid)) return null;

    if (cache?.countryIso2?.has(countryQid)) {
        return cache.countryIso2.get(countryQid) ?? null;
    }

    const entity = await getEntityCached({
        qid: countryQid,
        languages: [normalizeUiLangToWikidataLang(uiLang), 'en'],
                                         props: ['claims'],
                                         cache
    });

    const iso2 =
    getClaimArray(entity, WD_PROPS.ISO3166_ALPHA2).map(getDatavalue).map(getStringFromDatavalue).filter(Boolean)[0] ?? null;

    const clean = iso2 && typeof iso2 === 'string' && iso2.trim() ? iso2.trim().toUpperCase() : null;
    if (cache?.countryIso2) cache.countryIso2.set(countryQid, clean);
    return clean;
};

export const resolveGenreToRoot = async ({
    genreQid,
    genreRootQids,
    maxDepth = 8,
    uiLang = 'pt',
    cache
}) => {
    if (!isQid(genreQid)) return null;

    const roots = Array.isArray(genreRootQids) ? genreRootQids.filter(isQid) : [];
    const rootsSet = new Set(roots);

    if (rootsSet.size > 0 && rootsSet.has(genreQid)) {
        return genreQid;
    }

    const visited = new Set([genreQid]);
    let frontier = [genreQid];
    let depth = 0;

    while (frontier.length > 0 && depth < maxDepth) {
        const entities = await getEntities({
            qids: frontier,
            languages: [normalizeUiLangToWikidataLang(uiLang), 'en'],
                                           props: ['claims']
        });

        const next = [];

        for (const current of frontier) {
            const entity = entities?.[current] ?? null;
            const parents = getClaimArray(entity, WD_PROPS.SUBCLASS_OF)
            .map(getDatavalue)
            .map(getEntityIdFromDatavalue)
            .filter(Boolean);

            for (const p of parents) {
                if (visited.has(p)) continue;
                visited.add(p);

                if (rootsSet.size > 0 && rootsSet.has(p)) {
                    return p;
                }

                next.push(p);
            }
        }

        frontier = next;
        depth += 1;
    }

    return genreQid;
};

export const resolveCanonicalGenres = async ({
    genreQids,
    genreRootQids,
    maxGenres = 2,
    maxDepth = 8,
    uiLang = 'pt',
    cache
}) => {
    const list = Array.isArray(genreQids) ? genreQids.filter(isQid) : [];
    const limited = list.slice(0, Math.max(0, maxGenres));

    const resolved = [];
    for (const g of limited) {
        const root = await resolveGenreToRoot({
            genreQid: g,
            genreRootQids,
            maxDepth,
            uiLang,
            cache
        });

        if (root && !resolved.includes(root)) {
            resolved.push(root);
        }

        if (resolved.length >= maxGenres) break;
    }

    return resolved;
};

export const buildTechnicalDetailsFromWikidata = async ({
    qid,
    type,
    uiLang = 'pt',
    blockedInstanceOfQids = [],
    genreRootQids = [],
    maxGenres = 2,
    cache
}) => {
    const lang = normalizeUiLangToWikidataLang(uiLang);
    const localCache = cache ?? makeWikidataCache();

    const entity = await getEntityCached({
        qid,
        languages: [lang, 'en', 'pt', 'es'],
        props: ['labels', 'aliases', 'descriptions', 'claims'],
        cache: localCache
    });

    if (!entity) {
        return {
            qid,
            type,
            found: false
        };
    }

    const titles = getTitlesPTENES(entity);
    const extracted = extractTechnicalClaims({ entity, type });

    const blocked = isBlockedByInstanceOf({
        instanceOfQids: extracted.instanceOfQids,
        blockedInstanceOfQids
    });

    if (blocked) {
        return {
            qid: entity.id,
            type,
            found: true,
            blocked: true,
            titles
        };
    }

    const primaryCreatorQid = extracted.primaryCreatorQids[0] ?? null;
    const primaryCreatorName = primaryCreatorQid
    ? await getLabelForQid({ qid: primaryCreatorQid, uiLang: lang, cache: localCache })
    : null;

    const countryQid = extracted.countryQids[0] ?? null;
    const countryIso2 = countryQid
    ? await getCountryIso2ByCountryQid({ countryQid, uiLang: lang, cache: localCache })
    : null;

    const canonicalGenreQids = await resolveCanonicalGenres({
        genreQids: extracted.genreQids,
        genreRootQids,
        maxGenres,
        uiLang: lang,
        cache: localCache
    });

    const genres = [];
    for (const gq of canonicalGenreQids) {
        const gEntity = await getEntityCached({
            qid: gq,
            languages: [lang, 'en', 'pt', 'es'],
            props: ['labels'],
            cache: localCache
        });

        genres.push({
            qid: gq,
            titles: getTitlesPTENES(gEntity)
        });
    }

    return {
        qid: entity.id,
        type,
        found: true,
        blocked: false,

        titles,

        year: extracted.year ?? null,

        primaryCreator: {
            qid: primaryCreatorQid,
            name: primaryCreatorName
        },

        country: {
            qid: countryQid,
            iso2: countryIso2
        },

        genres,

        externalIds: extracted.externalIds
    };
};
</file>

<file path="client/src/components/club/ClubCard/ClubCard.jsx">
import React from "react";
import { Users, Calendar, BookOpen, Film, Gamepad2, Disc } from "lucide-react";
import { Link } from "react-router-dom";
import { cx } from "../../../utils/formatters";

const TypeIcon = {
  livro: BookOpen,
  filme: Film,
  jogo: Gamepad2,
  album: Disc,
};

const ActivityLabelKey = {
  livro: "club.activity.livro",
  filme: "club.activity.filme",
  jogo: "club.activity.jogo",
  album: "club.activity.album",
};

export default function ClubCard({ club, t }) {
  // LÓGICA DE ADAPTAÇÃO:
  // Verifica se existe a lista nova 'activeWorks'. Se sim, pega o primeiro item.
  // Se não, tenta pegar o antigo 'currentWork' (caso algum dado antigo tenha sobrado).
  const primaryWork =
    club.activeWorks && club.activeWorks.length > 0
      ? club.activeWorks[0]
      : club.currentWork;

  // Define o ícone com base no tipo do trabalho principal
  const WorkIcon = primaryWork
    ? TypeIcon[primaryWork.type] || BookOpen
    : BookOpen;

  // Define o texto (Lendo/Jogando) com base no tipo
  const activityKey = primaryWork
    ? ActivityLabelKey[primaryWork.type] || "club.reading_now"
    : "club.reading_now";
  const activityText = t ? t(activityKey) : "Atividade";

  // Conta quantos extras existem além do principal
  const extraWorksCount = club.activeWorks
    ? Math.max(0, club.activeWorks.length - 1)
    : 0;

  return (
    <div className="group flex flex-col bg-white dark:bg-neutral-900 border border-neutral-200 dark:border-neutral-800 rounded-2xl overflow-hidden hover:border-neutral-300 dark:hover:border-neutral-700 transition-all duration-300 hover:shadow-lg dark:hover:shadow-neutral-900/50">
      {/* Capa */}
      <div
        className={cx(
          "h-32 w-full bg-gradient-to-br p-4 flex flex-col justify-between",
          club.coverGradient,
        )}
      >
        <div className="flex justify-between items-start">
          <span className="px-2 py-1 rounded-md bg-black/20 text-white text-[10px] font-bold uppercase tracking-wider backdrop-blur-sm">
            {club.tags[0]?.replace("tag.", "")}
          </span>
        </div>
      </div>

      {/* Conteúdo */}
      <div className="p-5 flex flex-col flex-1 gap-4">
        <div>
          <h3 className="text-xl font-bold text-neutral-900 dark:text-neutral-100 group-hover:text-indigo-600 dark:group-hover:text-indigo-400 transition-colors">
            {club.name}
          </h3>
          <p className="text-sm text-neutral-600 dark:text-neutral-400 mt-1 line-clamp-2">
            {club.description}
          </p>
        </div>

        {/* Card de Atividade Principal */}
        {primaryWork && (
          <div className="p-3 rounded-xl bg-neutral-50 dark:bg-neutral-800/50 border border-neutral-100 dark:border-neutral-800 flex items-center gap-3 relative">
            <div className="w-10 h-10 rounded-lg bg-white dark:bg-neutral-800 flex items-center justify-center text-indigo-500 shadow-sm">
              <WorkIcon size={20} />
            </div>
            <div className="flex flex-col">
              <span className="text-[10px] uppercase text-neutral-400 font-bold tracking-wider">
                {activityText}
              </span>
              <span className="text-sm font-semibold text-neutral-900 dark:text-neutral-200 line-clamp-1">
                {primaryWork.title}
              </span>
            </div>

            {/* Badge indicando "+2" se houver mais atividades */}
            {extraWorksCount > 0 && (
              <div
                className="absolute top-2 right-2 text-[10px] font-bold text-neutral-500 bg-neutral-200 dark:bg-neutral-700 px-1.5 py-0.5 rounded-full"
                title={`+${extraWorksCount} outras atividades`}
              >
                +{extraWorksCount}
              </div>
            )}
          </div>
        )}

        <div className="flex flex-wrap gap-2 mt-auto">
          {club.tags.slice(1).map((tag) => (
            <span
              key={tag}
              className="text-xs px-2 py-1 rounded-full bg-neutral-100 dark:bg-neutral-800 text-neutral-600 dark:text-neutral-400"
            >
              #{t ? t(tag) : tag.replace("tag.", "")}
            </span>
          ))}
        </div>

        <div className="pt-4 border-t border-neutral-100 dark:border-neutral-800 flex items-center justify-between">
          <div className="flex items-center gap-2 text-xs text-neutral-500">
            <Users size={14} />
            <span>{club.membersCount}</span>
          </div>

          <div className="flex items-center gap-2 text-xs text-indigo-600 dark:text-indigo-400 font-medium">
            <Calendar size={14} />
            <span>{club.nextMeeting}</span>
          </div>
        </div>

        <Link
          to={`/club/${club.id}`}
          className="mt-2 w-full h-10 flex items-center justify-center rounded-xl bg-neutral-900 dark:bg-white text-white dark:text-neutral-900 font-semibold text-sm hover:opacity-90 transition-opacity"
        >
          {t ? t("action.visit_club") : "Visitar Clube"}
        </Link>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/club/CreateClubModal/CreateClubModal.jsx">
import React, { useState } from "react";
import { useNavigate } from "react-router-dom";
import { X, Image as ImageIcon } from "lucide-react";
import { useUserDatabase } from "../../../contexts/UserDatabaseContext.jsx";
import { useAuth } from "../../../contexts/AuthContext.jsx";

export default function CreateClubModal({ isOpen, onClose, t }) {
  const navigate = useNavigate();
  const { createClub } = useUserDatabase();
  const { currentUser } = useAuth();

  // Estados do Formulário
  const [name, setName] = useState("");
  const [handle, setHandle] = useState("");
  const [description, setDescription] = useState("");
  const [rules, setRules] = useState("");

  // Estado do Banner
  const [bannerFile, setBannerFile] = useState(null); // Armazena o arquivo
  const [bannerPreview, setBannerPreview] = useState(null); // Armazena a URL de preview

  if (!isOpen) return null;

  const handleImageChange = (e) => {
    const file = e.target.files[0];
    if (file) {
      setBannerFile(file);
      // Cria URL temporária para preview
      setBannerPreview(URL.createObjectURL(file));
    }
  };

  const handleSubmit = (e) => {
    e.preventDefault();

    if (!name.trim() || !handle.trim() || !description.trim()) {
      alert("Nome, Identificador e Descrição são obrigatórios.");
      return;
    }

    const newClubData = {
      name,
      id: handle.replace("@", ""),
      description,
      rules,
      tags: [], // Tags virão das mídias no futuro
      // Gradiente padrão se não houver imagem (ou como base)
      coverGradient: "from-gray-800 via-gray-900 to-black",
      // No mundo real, faríamos upload do bannerFile aqui.
      // Como é mock, salvamos o preview se existir.
      bannerUrl: bannerPreview,
      nextMeeting: "A definir",
    };

    const newClubId = createClub(currentUser?.handle || "anonimo", newClubData);

    // Limpeza
    setName("");
    setHandle("");
    setDescription("");
    setRules("");
    setBannerFile(null);
    setBannerPreview(null);

    onClose();
    navigate(`/club/${newClubId}`);
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm">
      <div className="bg-white dark:bg-neutral-900 w-full max-w-2xl rounded-2xl shadow-2xl border border-neutral-200 dark:border-neutral-800 flex flex-col max-h-[90vh] overflow-hidden animate-in fade-in zoom-in duration-200">
        {/* Header */}
        <div className="p-4 border-b border-neutral-200 dark:border-neutral-800 flex items-center justify-between bg-neutral-50 dark:bg-neutral-900/50">
          <h2 className="text-lg font-bold text-neutral-900 dark:text-neutral-100">
            {t("club.create.title")}
          </h2>
          <button
            onClick={onClose}
            className="text-neutral-500 hover:text-neutral-900 dark:hover:text-neutral-100 transition-colors"
          >
            <X size={20} />
          </button>
        </div>

        {/* Corpo (Scrollável) */}
        <div className="p-6 overflow-y-auto">
          <form
            id="create-club-form"
            onSubmit={handleSubmit}
            className="flex flex-col gap-6"
          >
            {/* Nome e Handle */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-neutral-700 dark:text-neutral-300 mb-1.5">
                  {t("club.create.name_label")}
                </label>
                <input
                  type="text"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  placeholder={t("club.create.name_placeholder")}
                  className="w-full px-4 py-2.5 rounded-xl border border-neutral-300 dark:border-neutral-700 bg-transparent focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 outline-none transition-all text-neutral-900 dark:text-neutral-100 placeholder-neutral-400"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-neutral-700 dark:text-neutral-300 mb-1.5">
                  {t("club.create.handle_label")}
                </label>
                <input
                  type="text"
                  value={handle}
                  onChange={(e) => setHandle(e.target.value)}
                  placeholder={t("club.create.handle_placeholder")}
                  className="w-full px-4 py-2.5 rounded-xl border border-neutral-300 dark:border-neutral-700 bg-transparent focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 outline-none transition-all text-neutral-900 dark:text-neutral-100 placeholder-neutral-400"
                />
              </div>
            </div>

            {/* Descrição */}
            <div>
              <label className="block text-sm font-medium text-neutral-700 dark:text-neutral-300 mb-1.5">
                {t("club.create.desc_label")}
              </label>
              <textarea
                rows="2"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                placeholder={t("club.create.desc_placeholder")}
                className="w-full px-4 py-2.5 rounded-xl border border-neutral-300 dark:border-neutral-700 bg-transparent focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 outline-none transition-all resize-none text-neutral-900 dark:text-neutral-100 placeholder-neutral-400"
              />
            </div>

            {/* Regras (Primeiro) */}
            <div>
              <label className="block text-sm font-medium text-neutral-700 dark:text-neutral-300 mb-1.5">
                {t("club.create.rules_label")}
              </label>
              <textarea
                rows="4"
                value={rules}
                onChange={(e) => setRules(e.target.value)}
                placeholder={t("club.create.rules_placeholder")}
                className="w-full px-4 py-2.5 rounded-xl border border-neutral-300 dark:border-neutral-700 bg-amber-50/50 dark:bg-amber-900/10 focus:border-amber-500 focus:ring-1 focus:ring-amber-500 outline-none transition-all resize-none text-sm text-neutral-900 dark:text-neutral-100 placeholder-neutral-400"
              />
            </div>

            {/* Upload de Banner (Depois) */}
            <div>
              <label className="block text-sm font-medium text-neutral-700 dark:text-neutral-300 mb-1.5">
                {t("club.create.banner_label")}
              </label>

              <div className="w-full h-32 rounded-xl bg-neutral-100 dark:bg-neutral-800 border border-dashed border-neutral-300 dark:border-neutral-700 flex items-center justify-center overflow-hidden relative group cursor-pointer hover:border-indigo-500 transition-colors">
                {bannerPreview ? (
                  <img
                    src={bannerPreview}
                    alt="Preview"
                    className="w-full h-full object-cover"
                  />
                ) : (
                  <div className="text-center text-neutral-500 p-4">
                    <ImageIcon className="w-8 h-8 mx-auto mb-2 opacity-50" />
                    <span className="text-xs">
                      {t("club.create.banner_help")}
                    </span>
                  </div>
                )}

                {/* Input File: SEM VALUE controlado */}
                <input
                  type="file"
                  accept="image/*"
                  onChange={handleImageChange}
                  className="absolute inset-0 opacity-0 cursor-pointer"
                />
              </div>
            </div>
          </form>
        </div>

        {/* Footer Actions */}
        <div className="p-4 border-t border-neutral-200 dark:border-neutral-800 bg-neutral-50 dark:bg-neutral-900/50 flex justify-end gap-3">
          <button
            type="button"
            onClick={onClose}
            className="px-4 py-2 rounded-lg text-sm font-medium text-neutral-600 dark:text-neutral-300 hover:bg-neutral-200 dark:hover:bg-neutral-800 transition-colors"
          >
            {t("club.create.cancel")}
          </button>
          <button
            type="submit"
            form="create-club-form"
            className="px-6 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-bold shadow-md transition-all transform active:scale-95"
          >
            {t("club.create.submit")}
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/club/ManageClubModal/ManageClubModal.jsx">
import React, { useState, useEffect } from "react";
import { X, Image as ImageIcon } from "lucide-react";
import { useUserDatabase } from "../../../contexts/UserDatabaseContext.jsx";
import { cx } from "../../../utils/formatters.js";

export default function ManageClubModal({ isOpen, onClose, clubData, t }) {
  const { updateClub } = useUserDatabase();

  // Estados do Formulário
  const [name, setName] = useState(clubData?.name || "");
  const [description, setDescription] = useState(clubData?.description || "");
  const [rules, setRules] = useState(clubData?.rules || "");
  // REMOVIDO: Estado nextMeeting

  // Estado do Banner
  const [bannerPreview, setBannerPreview] = useState(
    clubData?.bannerUrl || null,
  );

  useEffect(() => {
    if (clubData) {
      setName(clubData.name || "");
      setDescription(clubData.description || "");
      setRules(clubData.rules || "");
      // REMOVIDO: setNextMeeting
      setBannerPreview(clubData.bannerUrl || null);
    }
  }, [clubData]);

  if (!isOpen || !clubData) return null;

  const handleImageChange = (e) => {
    const file = e.target.files[0];
    if (file) {
      setBannerPreview(URL.createObjectURL(file));
    }
  };

  const handleSubmit = (e) => {
    e.preventDefault();

    if (!name.trim() || !description.trim()) {
      alert("Nome e Descrição são obrigatórios.");
      return;
    }

    const updatedData = {
      name,
      description,
      rules,
      // REMOVIDO: nextMeeting do objeto de update
      bannerUrl: bannerPreview,
      coverGradient: bannerPreview
        ? null
        : clubData.coverGradient || "from-gray-800 via-gray-900 to-black",
    };

    updateClub(clubData.id, updatedData);

    onClose();
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm animate-in fade-in duration-200">
      <div className="bg-white dark:bg-neutral-900 w-full max-w-2xl rounded-2xl shadow-2xl border border-neutral-200 dark:border-neutral-800 flex flex-col max-h-[90vh] overflow-hidden animate-in zoom-in-95 duration-200">
        {/* Header */}
        <div className="p-4 border-b border-neutral-200 dark:border-neutral-800 flex items-center justify-between bg-neutral-50 dark:bg-neutral-900/50">
          <h2 className="text-lg font-bold text-neutral-900 dark:text-neutral-100">
            {t("club.manage.title") || "Gerir Clube"}
          </h2>
          <button
            onClick={onClose}
            className="text-neutral-500 hover:text-neutral-900 dark:hover:text-neutral-100 transition-colors"
          >
            <X size={20} />
          </button>
        </div>

        {/* Corpo */}
        <div className="p-6 overflow-y-auto">
          <form
            id="manage-club-form"
            onSubmit={handleSubmit}
            className="flex flex-col gap-6"
          >
            {/* Nome e Handle */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-neutral-700 dark:text-neutral-300 mb-1.5">
                  {t("club.create.name_label")}
                </label>
                <input
                  type="text"
                  value={name}
                  onChange={(e) => setName(e.target.value)}
                  className="w-full px-4 py-2.5 rounded-xl border border-neutral-300 dark:border-neutral-700 bg-transparent focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 outline-none transition-all text-neutral-900 dark:text-neutral-100"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-neutral-400 dark:text-neutral-500 mb-1.5">
                  {t("club.create.handle_label")} (Não editável)
                </label>
                <input
                  type="text"
                  value={`@${clubData.id}`}
                  disabled
                  className="w-full px-4 py-2.5 rounded-xl border border-neutral-200 dark:border-neutral-800 bg-neutral-100 dark:bg-neutral-800/50 text-neutral-500 cursor-not-allowed"
                />
              </div>
            </div>

            {/* REMOVIDO: Campo de Próximo Encontro */}

            {/* Descrição */}
            <div>
              <label className="block text-sm font-medium text-neutral-700 dark:text-neutral-300 mb-1.5">
                {t("club.create.desc_label")}
              </label>
              <textarea
                rows="2"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                className="w-full px-4 py-2.5 rounded-xl border border-neutral-300 dark:border-neutral-700 bg-transparent focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 outline-none transition-all resize-none text-neutral-900 dark:text-neutral-100"
              />
            </div>

            {/* Regras */}
            <div>
              <label className="block text-sm font-medium text-neutral-700 dark:text-neutral-300 mb-1.5">
                {t("club.create.rules_label")}
              </label>
              <textarea
                rows="5"
                value={rules}
                onChange={(e) => setRules(e.target.value)}
                className="w-full px-4 py-2.5 rounded-xl border border-neutral-300 dark:border-neutral-700 bg-amber-50/50 dark:bg-amber-900/10 focus:border-amber-500 focus:ring-1 focus:ring-amber-500 outline-none transition-all resize-none text-sm text-neutral-900 dark:text-neutral-100"
              />
            </div>

            {/* Banner */}
            <div>
              <div className="flex items-center justify-between mb-1.5">
                <label className="block text-sm font-medium text-neutral-700 dark:text-neutral-300">
                  {t("club.create.banner_label")}
                </label>
                {bannerPreview && (
                  <button
                    type="button"
                    onClick={() => setBannerPreview(null)}
                    className="text-xs text-red-500 hover:underline"
                  >
                    Remover imagem
                  </button>
                )}
              </div>

              <div
                className={cx(
                  "w-full h-40 rounded-xl bg-neutral-100 dark:bg-neutral-800 border border-dashed border-neutral-300 dark:border-neutral-700 flex items-center justify-center overflow-hidden relative group cursor-pointer hover:border-indigo-500 transition-colors",
                  bannerPreview ? "border-solid" : "",
                )}
              >
                {bannerPreview ? (
                  <img
                    src={bannerPreview}
                    alt="Preview"
                    className="w-full h-full object-cover"
                  />
                ) : (
                  <div
                    className={cx(
                      "absolute inset-0 bg-gradient-to-br opacity-50",
                      clubData.coverGradient,
                    )}
                  ></div>
                )}
                {!bannerPreview && (
                  <div className="text-center text-neutral-500 p-4 relative z-10">
                    <ImageIcon className="w-8 h-8 mx-auto mb-2 opacity-50" />
                    <span className="text-xs">
                      {t("club.create.banner_help")}
                    </span>
                  </div>
                )}

                <input
                  type="file"
                  accept="image/*"
                  onChange={handleImageChange}
                  className="absolute inset-0 opacity-0 cursor-pointer z-20"
                />
              </div>
            </div>
          </form>
        </div>

        {/* Footer Actions */}
        <div className="p-4 border-t border-neutral-200 dark:border-neutral-800 bg-neutral-50 dark:bg-neutral-900/50 flex justify-end gap-3">
          <button
            type="button"
            onClick={onClose}
            className="px-4 py-2 rounded-lg text-sm font-medium text-neutral-600 dark:text-neutral-300 hover:bg-neutral-200 dark:hover:bg-neutral-800 transition-colors"
          >
            {t("club.create.cancel")}
          </button>
          <button
            type="submit"
            form="manage-club-form"
            className="px-6 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-bold shadow-md transition-all transform active:scale-95"
          >
            {t("club.manage.save") || "Salvar Alterações"}
          </button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/dashboard/ActivityCalendar/ActivityCalendar.jsx">
import React, { useState, useMemo } from "react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { cx } from "../../../utils/formatters";

const WEEKDAYS = ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"];

const MONTH_MAP = {
  Jan: 0,
  Fev: 1,
  Mar: 2,
  Abr: 3,
  Mai: 4,
  Jun: 5,
  Jul: 6,
  Ago: 7,
  Set: 8,
  Out: 9,
  Nov: 10,
  Dez: 11,
};

export default function ActivityCalendar({ reviews, t }) {
  const [currentDate, setCurrentDate] = useState(new Date(2025, 9, 1));
  const [filter, setFilter] = useState("todos"); // 1. Novo estado para o filtro

  const activeDays = useMemo(() => {
    const activity = new Set();
    if (!reviews) return activity;

    const currentYear = currentDate.getFullYear();
    const currentMonth = currentDate.getMonth();

    reviews.forEach((review) => {
      // 3. A lógica agora verifica o filtro antes de adicionar o dia
      if (filter !== "todos" && review.type !== filter) {
        return; // Pula esta review se não corresponder ao filtro
      }

      const parts = review.date.split(" ");
      if (parts.length < 3) return;

      const day = parseInt(parts[0], 10);
      const month = MONTH_MAP[parts[1]];
      const year = parseInt(parts[2], 10);

      if (year === currentYear && month === currentMonth) {
        activity.add(day);
      }
    });

    return activity;
  }, [reviews, currentDate, filter]); // Adicionamos 'filter' às dependências

  const calendarDays = useMemo(() => {
    const year = currentDate.getFullYear();
    const month = currentDate.getMonth();
    const firstDayOfMonth = new Date(year, month, 1).getDay();
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const paddingDays = Array(firstDayOfMonth).fill(null);
    const monthDays = Array.from({ length: daysInMonth }, (_, i) => i + 1);
    return [...paddingDays, ...monthDays];
  }, [currentDate]);

  const handlePrevMonth = () => {
    setCurrentDate(
      new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1),
    );
  };

  const handleNextMonth = () => {
    setCurrentDate(
      new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1),
    );
  };

  const filterChips = [
    { k: "todos", label: t("filter.all") },
    { k: "filme", label: t("filter.movies") }, // CORREÇÃO DO ERRO DE DIGITAÇÃO AQUI
    { k: "livro", label: t("filter.books") },
    { k: "jogo", label: t("filter.games") },
    { k: "album", label: t("filter.albums") },
  ];

  // CORREÇÃO: Função para formatar o mês corretamente
  const formatMonthTitle = (date) => {
    const formatted = date.toLocaleString("pt-BR", {
      month: "long",
      year: "numeric",
    });
    // Garante que o "de" seja minúsculo e a primeira letra do mês seja maiúscula
    return formatted
      .replace(" de ", " de ")
      .replace(/^[a-z]/, (char) => char.toUpperCase());
  };

  return (
    <div className="p-4 rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 min-h-[320px]">
      <div className="flex items-center justify-between">
        {/* CORREÇÃO: Removido 'capitalize' e usada a nova função de formatação */}
        <h3 className="font-semibold text-neutral-800 dark:text-neutral-100">
          {formatMonthTitle(currentDate)}
        </h3>
        <div className="flex items-center gap-2">
          <button
            onClick={handlePrevMonth}
            className="p-1 rounded-md hover:bg-neutral-100 dark:hover:bg-neutral-800"
          >
            <ChevronLeft className="w-5 h-5" />
          </button>
          <button
            onClick={handleNextMonth}
            className="p-1 rounded-md hover:bg-neutral-100 dark:hover:bg-neutral-800"
          >
            <ChevronRight className="w-5 h-5" />
          </button>
        </div>
      </div>

      {/* 2. Botões de filtro adicionados */}
      <div className="flex items-center gap-2 text-xs flex-wrap my-4">
        {filterChips.map((f) => (
          <button
            key={f.k}
            onClick={() => setFilter(f.k)}
            className={cx(
              "px-3 py-1.5 rounded-full border",
              filter === f.k
                ? "bg-neutral-900 text-white dark:bg-white dark:text-neutral-900 border-neutral-900 dark:border-white"
                : "border-neutral-200 dark:border-neutral-700 hover:bg-neutral-50 dark:hover:bg-neutral-800/60",
            )}
          >
            {f.label}
          </button>
        ))}
      </div>

      <div className="grid grid-cols-7 gap-y-2 text-center text-xs text-neutral-500">
        {WEEKDAYS.map((day) => (
          <div key={day}>{day}</div>
        ))}
      </div>

      <div className="mt-2 grid grid-cols-7 gap-y-2 text-center text-sm">
        {calendarDays.map((day, index) => {
          const hasActivity = day && activeDays.has(day);
          return (
            <div key={index} className="flex justify-center items-center h-8">
              {day && (
                <span
                  className={cx(
                    "flex items-center justify-center w-8 h-8 rounded-full",
                    hasActivity &&
                      "bg-emerald-200/50 dark:bg-emerald-500/20 text-emerald-800 dark:text-emerald-200 font-semibold",
                  )}
                >
                  {day}
                </span>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/dashboard/CollectionList/CollectionList.jsx">
import React from "react";
import { motion } from "framer-motion";
import { List } from "lucide-react";
import { Link } from "react-router-dom";
import { cx } from "../../../utils/formatters";
import ExpandButton from "../../ui/ExpandButton/ExpandButton.jsx";

const palette = {
  filme: "bg-indigo-500",
  livro: "bg-emerald-500",
  jogo: "bg-fuchsia-500",
  album: "bg-amber-500",
};

export default function CollectionList({ collections, t }) {
  return (
    <div className="flex flex-col gap-3">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2 text-sm text-neutral-500 dark:text-neutral-400">
          <List className="w-4 h-4" />
          <h3 className="text-base font-semibold text-neutral-800 dark:text-neutral-100">
            {t("section.collections")}
          </h3>
        </div>
        <ExpandButton to="/dashboard/lists" ariaLabel={t("action.manage")} />
      </div>

      <div className="flex flex-col gap-3">
        {(collections || []).map((collection) => (
          // ALTERAÇÃO AQUI: Passando ?id=... na URL
          <Link
            to={`/dashboard/lists?id=${collection.id}`}
            key={collection.id}
            className="block w-full"
          >
            <motion.div
              whileHover={{ y: -2 }}
              className="w-full text-left p-3 rounded-xl border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 hover:border-neutral-300 dark:hover:border-neutral-700 transition-colors group"
            >
              <div className="flex items-center justify-between">
                <span className="font-semibold text-sm text-neutral-900 dark:text-neutral-100 group-hover:text-indigo-600 dark:group-hover:text-indigo-400 transition-colors">
                  {collection.title}
                </span>
              </div>
              <p className="text-xs text-neutral-500 dark:text-neutral-400 mt-1 line-clamp-1">
                {collection.description}
              </p>

              <div className="flex -space-x-1.5 mt-2">
                {(collection.items || []).slice(0, 5).map((item) => (
                  <div
                    key={item.id}
                    title={item.title}
                    className={cx(
                      "w-5 h-5 rounded-full ring-2 ring-white dark:ring-neutral-900",
                      palette[item.type] || "bg-neutral-400",
                    )}
                  />
                ))}
                {(collection.items || []).length > 5 && (
                  <div className="w-5 h-5 rounded-full ring-2 ring-white dark:ring-neutral-900 bg-neutral-200 dark:bg-neutral-700 flex items-center justify-center text-[9px] text-neutral-600 dark:text-neutral-200">
                    +{(collection.items || []).length - 5}
                  </div>
                )}
              </div>
            </motion.div>
          </Link>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/layout/SectionHeader/SectionHeader.jsx">
import React from "react";
import ExpandButton from "../../ui/ExpandButton/ExpandButton.jsx"; // Importando o novo botão padronizado

// Componente para o cabeçalho de uma seção, com título, ícone e filtros.
function SectionHeader({ title, href, icon, filters, t }) {
  return (
    <div className="mb-3 grid grid-cols-[auto_1fr_auto] items-center gap-2">
      {/* Lado esquerdo: Ícone e Título */}
      <div className="flex items-center gap-2 text-sm text-neutral-500 dark:text-neutral-400">
        {icon}
        <h3 className="text-base font-semibold text-neutral-800 dark:text-neutral-100">
          {title}
        </h3>
      </div>

      {/* Centro: Filtros (opcional) */}
      <div className="justify-self-center overflow-x-auto no-scrollbar w-full lg:w-auto px-2 lg:px-0">
        <div className="flex items-center gap-2 text-xs flex-wrap justify-center whitespace-nowrap">
          {filters}
        </div>
      </div>

      {/* Lado direito: Botão Expandir (+) padronizado */}
      <div className="justify-self-end">
        {href ? (
          <ExpandButton to={href} ariaLabel={t("action.explore")} />
        ) : (
          <span />
        )}
      </div>
    </div>
  );
}

export default SectionHeader;
</file>

<file path="client/src/components/media/CommunityReviewsFeed/CommunityReviewsFeed.jsx">
import React from "react";
import RatingStars from "../../ui/RatingStars/RatingStars.jsx";
import { formatScore } from "../../../utils/formatters";

// Função de arredondamento para o quarto de ponto mais próximo
const roundToQuarter = (n) => Math.round(n * 4) / 4;

export default function CommunityReviewsFeed({ reviews, t }) {
  if (!reviews || reviews.length === 0) {
    return (
      <div>
        {/* Usando t() para o título */}
        <h2 className="text-xl font-bold text-neutral-800 dark:text-neutral-100">
          {t("section.communityReviews")}
        </h2>
        <p className="text-sm text-neutral-500 mt-2">
          Ainda não há reviews da comunidade para este item.
        </p>
      </div>
    );
  }

  return (
    <div>
      {/* A CORREÇÃO ESTÁ AQUI: Usando t() para o título */}
      <h2 className="text-xl font-bold text-neutral-800 dark:text-neutral-100 mb-4">
        {t("section.communityReviews")}
      </h2>
      <div className="flex flex-col gap-6">
        {reviews.map((review) => (
          <div
            key={review.id}
            className="flex items-start gap-4 pb-6 border-b border-neutral-200 dark:border-neutral-800 last:border-b-0"
          >
            <div className="w-10 h-10 shrink-0 rounded-full bg-gradient-to-br from-neutral-200 to-neutral-400 dark:from-neutral-700 dark:to-neutral-600 flex items-center justify-center text-sm font-semibold text-neutral-700 dark:text-neutral-100">
              {review.user.avatar}
            </div>
            <div className="flex-1">
              <div className="flex items-center justify-between">
                <div>
                  <span className="font-semibold text-neutral-800 dark:text-neutral-100">
                    {review.user.name}
                  </span>
                  <span className="text-sm text-neutral-500 ml-2">
                    {review.user.handle}
                  </span>
                </div>
                <div className="flex items-center gap-2">
                  <RatingStars score={review.score} />
                  <span className="text-xs font-semibold text-neutral-600 dark:text-neutral-300">
                    {formatScore(roundToQuarter(review.score))}
                  </span>
                </div>
              </div>
              <p className="text-sm text-neutral-600 dark:text-neutral-300 mt-2 leading-relaxed">
                {review.text}
              </p>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/media/MediaCard/MediaCard.jsx">
import React from 'react';
import { Link } from 'react-router-dom'; // Assumindo uso de React Router

// Dicionário local para fallback das tags (idealmente viria de um hook useI18n, mas vamos manter funcional aqui)
const TAG_LABELS = {
    'tag.action': 'Ação',
    'tag.science-fiction': 'Ficção Científica',
    'tag.adventure': 'Aventura',
    'tag.drama': 'Drama',
    'tag.comedy': 'Comédia'
};

/**
 * MediaCard
 * Componente responsável por exibir o card de um filme/série.
 * Recebe o objeto completo do backend (ex: tmdb_603) via prop 'data'.
 */
const MediaCard = ({ data, lang = 'PT' }) => {
    // Proteção contra dados nulos
    if (!data) return null;

    // 1. Resolução de Idioma (I18n)
    // Tenta pegar o idioma pedido (PT), senão vai para EN, senão avisa que está indisponível.
    const title = data.titles?.[lang] || data.titles?.['EN'] || 'Título Indisponível';
    const synopsis = data.synopses?.[lang] || data.synopses?.['EN'] || 'Sinopse indisponível.';

    // 2. Extração de Metadados
    const year = data.releaseYear || 'N/A';
    const poster = data.posterUrl || 'https://via.placeholder.com/500x750?text=No+Poster';

    return (
        <div className="group relative flex flex-col bg-white dark:bg-gray-800 rounded-xl shadow-md overflow-hidden hover:shadow-xl transition-all duration-300 h-full">

        {/* --- PÔSTER --- */}
        <div className="relative w-full aspect-[2/3] overflow-hidden">
        <img
        src={poster}
        alt={title}
        className="w-full h-full object-cover transform group-hover:scale-105 transition-transform duration-500"
        loading="lazy"
        />

        {/* Badge de Ano (Canto superior) */}
        <div className="absolute top-2 right-2 bg-black/70 backdrop-blur-sm text-white text-xs font-bold px-2 py-1 rounded-md shadow-sm">
        {year}
        </div>

        {/* Overlay no Hover (opcional, para dar feedback visual) */}
        <div className="absolute inset-0 bg-black/0 group-hover:bg-black/10 transition-colors duration-300" />
        </div>

        {/* --- CONTEÚDO --- */}
        <div className="p-4 flex flex-col flex-grow">
        {/* Título */}
        <h3 className="text-lg font-bold text-gray-900 dark:text-gray-100 leading-tight mb-2 line-clamp-1" title={title}>
        {title}
        </h3>

        {/* Tags */}
        <div className="flex flex-wrap gap-1.5 mb-3">
        {data.tags && data.tags.slice(0, 3).map((tag) => (
            <span
            key={tag}
            className="px-2 py-0.5 text-[10px] uppercase tracking-wider font-semibold rounded bg-indigo-100 text-indigo-700 dark:bg-indigo-900/50 dark:text-indigo-300"
            >
            {TAG_LABELS[tag] || tag.replace('tag.', '')}
            </span>
        ))}
        </div>

        {/* Sinopse (Truncada) */}
        <p className="text-sm text-gray-600 dark:text-gray-400 line-clamp-3 mb-4 flex-grow">
        {synopsis}
        </p>

        {/* Botão de Ação */}
        {/* Usamos o ID composto (tmdb_603) para criar o link de navegação */}
        <Link
        to={`/media/${data.id}`}
        className="mt-auto w-full text-center bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 rounded-lg transition-colors text-sm"
        >
        Ver Detalhes
        </Link>
        </div>
        </div>
    );
};

export default MediaCard;
</file>

<file path="client/src/components/media/UserReviewEditor/UserReviewEditor.jsx">
import React, { useState } from "react";
import { cx, formatScore } from "../../../utils/formatters";
import RatingStars from "../../ui/RatingStars/RatingStars.jsx";

const roundToQuarter = (n) => Math.round(n * 4) / 4;

const StarIcon = (props) => (
  <svg viewBox="0 0 24 24" className="w-8 h-8" {...props}>
    <path d="M12 2.5l2.9 5.88 6.5.94-4.7 4.58 1.11 6.47L12 17.77 6.19 20.37l1.11-6.47-4.7-4.58 6.5-.94L12 2.5z" />
  </svg>
);

export default function UserReviewEditor({ communityAverage, t }) {
  const [rating, setRating] = useState(0);
  const [hoverRating, setHoverRating] = useState(0);
  const [reviewText, setReviewText] = useState("");

  const MAX_LENGTH = 500; // Limite Rígido

  const handleMouseMove = (e) => {
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const totalWidth = rect.width;
    const rawRating = Math.max(0, (x / totalWidth) * 10);
    setHoverRating(roundToQuarter(rawRating));
  };

  const handleMouseLeave = () => {
    setHoverRating(0);
  };

  const handleClick = () => {
    setRating(hoverRating);
  };

  const displayRating = hoverRating > 0 ? hoverRating : rating;
  const roundedCommunityAverage = roundToQuarter(communityAverage || 0);

  return (
    <div className="flex flex-col gap-8">
      {/* --- Seção "Sua Review" --- */}
      <div className="p-4 rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900">
        <h2 className="text-xl font-bold text-neutral-800 dark:text-neutral-100 mb-4">
          {t("section.yourReview")}
        </h2>

        <div className="text-center mb-4">
          <div
            onMouseMove={handleMouseMove}
            onMouseLeave={handleMouseLeave}
            onClick={handleClick}
            className="relative inline-flex cursor-pointer"
            aria-label={`Avaliar de 0 a 10. Nota atual: ${displayRating}`}
          >
            <div className="flex text-neutral-300 dark:text-neutral-700">
              {[...Array(5)].map((_, i) => (
                <StarIcon key={i} />
              ))}
            </div>
            <div
              className="absolute top-0 left-0 h-full overflow-hidden flex"
              style={{ width: `${displayRating * 10}%` }}
            >
              {[...Array(5)].map((_, i) => (
                <StarIcon
                  key={i}
                  className="text-amber-500 fill-current shrink-0"
                />
              ))}
            </div>
          </div>
          <p className="text-lg font-bold text-neutral-800 dark:text-neutral-200 mt-2 h-7">
            {displayRating > 0 ? formatScore(displayRating) : ""}
          </p>
        </div>

        <div className="relative">
          <textarea
            value={reviewText}
            onChange={(e) => setReviewText(e.target.value)}
            placeholder={t("form.placeholder.review")}
            maxLength={MAX_LENGTH} // Limite aplicado
            className="w-full h-32 p-3 text-sm rounded-lg border border-neutral-300 dark:border-neutral-700 bg-neutral-50 dark:bg-neutral-800/50 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none transition resize-none"
          />
          {/* Contador de Caracteres */}
          <div className="absolute bottom-2 right-3 text-xs text-neutral-400">
            {reviewText.length}/{MAX_LENGTH}
          </div>
        </div>

        <button className="w-full mt-4 h-10 rounded-lg bg-indigo-600 hover:bg-indigo-700 text-white font-semibold text-sm transition-colors">
          {t("action.saveReview")}
        </button>
      </div>

      {/* --- Seção "Média da Comunidade" --- */}
      <div className="p-4 rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900">
        <h3 className="text-base font-semibold text-neutral-800 dark:text-neutral-100 mb-2">
          {t("section.communityAverage")}
        </h3>
        <div className="flex items-center gap-2">
          <RatingStars score={roundedCommunityAverage} />
          <span className="font-bold text-neutral-800 dark:text-neutral-200">
            {formatScore(roundedCommunityAverage)}
          </span>
          <span className="text-xs text-neutral-500">
            ({(communityAverage || 0).toFixed(2)})
          </span>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/ui/AvatarStack/AvatarStack.jsx">
import React from "react";

// Componente para exibir uma pilha de avatares com as iniciais dos nomes.
function AvatarStack({ names }) {
  // Se 'names' não for um array, não renderiza nada para evitar erros.
  if (!Array.isArray(names)) {
    return null;
  }

  return (
    <div className="flex -space-x-2">
      {/* Mostra os primeiros 5 avatares */}
      {names.slice(0, 5).map((name, i) => (
        <div
          key={i}
          title={name} // O nome completo aparece ao passar o mouse
          className="w-7 h-7 rounded-full ring-2 ring-white dark:ring-neutral-900 bg-gradient-to-br from-neutral-200 to-neutral-400 dark:from-neutral-700 dark:to-neutral-600 flex items-center justify-center text-[10px] font-semibold text-neutral-700 dark:text-neutral-200"
        >
          {name.substring(0, 1).toUpperCase()}
        </div>
      ))}

      {/* Se houver mais de 5 nomes, mostra um contador */}
      {names.length > 5 && (
        <div className="w-7 h-7 rounded-full ring-2 ring-white dark:ring-neutral-900 bg-neutral-200 dark:bg-neutral-700 flex items-center justify-center text-[10px] text-neutral-600 dark:text-neutral-200">
          +{names.length - 5}
        </div>
      )}
    </div>
  );
}

export default AvatarStack;
</file>

<file path="client/src/components/ui/ExpandButton/ExpandButton.jsx">
import React from "react";
import { Link } from "react-router-dom";
import { Plus } from "lucide-react";

const ExpandButton = ({ to, onClick, ariaLabel = "Expandir" }) => {
  const baseClasses =
    "w-8 h-8 flex items-center justify-center rounded-full border border-neutral-200 dark:border-neutral-700 bg-transparent text-neutral-500 hover:text-neutral-900 dark:text-neutral-400 dark:hover:text-neutral-100 hover:bg-neutral-100 dark:hover:bg-neutral-800 transition-all duration-200 group";

  // Se tiver a prop 'to', renderiza como Link (navegação)
  if (to) {
    return (
      <Link to={to} className={baseClasses} aria-label={ariaLabel}>
        <Plus
          size={18}
          strokeWidth={2.5}
          className="group-hover:scale-110 transition-transform"
        />
      </Link>
    );
  }

  // Se não, renderiza como botão normal (ação/modal)
  return (
    <button onClick={onClick} className={baseClasses} aria-label={ariaLabel}>
      <Plus
        size={18}
        strokeWidth={2.5}
        className="group-hover:scale-110 transition-transform"
      />
    </button>
  );
};

export default ExpandButton;
</file>

<file path="client/src/components/ui/MediaBadge/MediaBadge.jsx">
import React from "react";
import { Film, BookOpen, Gamepad2, Disc } from "lucide-react";
import { cx } from "../../../utils/formatters";

// Mapa de ícones para cada tipo de mídia
const iconMap = {
  filme: Film,
  livro: BookOpen,
  jogo: Gamepad2,
  album: Disc,
};

// Este componente exibe um selo com ícone e texto para um tipo de mídia.
function MediaBadge({ type, label, compact = false }) {
  // Define o tamanho do ícone e o padding com base na prop 'compact'
  const size = compact ? "w-3 h-3" : "w-3.5 h-3.5";
  const padding = compact ? "px-1.5 py-0.5 text-[11px]" : "px-2 py-0.5 text-xs";

  const Icon = iconMap[type] || Film; // Usa o ícone de Filme como padrão

  return (
    <span
      className={cx(
        "inline-flex items-center gap-1 rounded-full border border-neutral-200/80 dark:border-neutral-700/60 text-neutral-600 dark:text-neutral-300 bg-white/70 dark:bg-neutral-900/60 backdrop-blur",
        padding,
      )}
    >
      <Icon className={size} />
      {label}
    </span>
  );
}

export default MediaBadge;
</file>

<file path="client/src/components/ui/MediaCard/MediaCard.jsx">
import React from "react";
import { motion } from "framer-motion";
import { X } from "lucide-react";
import MediaBadge from "../MediaBadge/MediaBadge";
import RatingStars from "../RatingStars/RatingStars";
import {
  cx,
  clamp10,
  roundToQuarter,
  formatScore,
} from "../../../utils/formatters";

const palette = {
  filme: "from-indigo-500/25 via-indigo-500/10 to-transparent",
  livro: "from-emerald-500/25 via-emerald-500/10 to-transparent",
  jogo: "from-fuchsia-500/25 via-fuchsia-500/10 to-transparent",
  album: "from-amber-500/25 via-amber-500/10 to-transparent",
};

function MediaCard({ item, onClick, onRemove, wide = false, badgeLabel }) {
  const grad = palette[item.type] || palette.filme;

  const displayTitle =
    typeof item.title === "object" && item.title !== null
      ? item.title.PT
      : item.title;

  return (
    <motion.button
      whileHover={{ y: -6 }}
      whileTap={{ scale: 0.98 }}
      onClick={onClick}
      className={cx(
        "group snap-start relative overflow-hidden rounded-2xl border border-neutral-200/70 dark:border-neutral-800/70 bg-white dark:bg-neutral-900 text-left transition-transform duration-200 hover:z-10",
        wide ? "w-full" : "w-56 shrink-0",
        "h-64 flex flex-col",
      )}
    >
      {onRemove && (
        <button
          onClick={(e) => {
            e.stopPropagation();
            onRemove(item.id);
          }}
          className="absolute top-2 right-2 z-20 h-7 w-7 rounded-full bg-black/40 text-white/80 backdrop-blur-sm flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity hover:bg-black/60 hover:text-white"
          aria-label="Remover dos favoritos"
        >
          <X className="w-4 h-4" />
        </button>
      )}

      <div className={cx("h-32 w-full bg-gradient-to-br", grad)} />

      <div className="p-3 flex flex-col gap-1.5 flex-1">
        <div className="flex items-center gap-2">
          <MediaBadge type={item.type} label={badgeLabel} />
          <span className="ml-auto text-xs text-neutral-500 dark:text-neutral-400">
            {item.year}
          </span>
        </div>
        <div className="font-medium leading-snug text-neutral-800 dark:text-neutral-100 line-clamp-2 min-h-[2.6em]">
          {displayTitle}
        </div>
        <div className="mt-auto flex items-center gap-2 text-sm">
          <RatingStars score={item.score} />
          <span className="text-xs text-neutral-500">
            {formatScore(roundToQuarter(clamp10(item.score)))}
          </span>
        </div>
      </div>
      <div className="absolute inset-x-0 bottom-0 h-8 bg-gradient-to-t from-black/5 to-transparent dark:from-white/5" />
    </motion.button>
  );
}

export default MediaCard;
</file>

<file path="client/src/components/ui/RatingStars/RatingStars.jsx">
import React, { useId } from "react";
import {
  roundToQuarter,
  clamp10,
  starFillFor,
} from "../../../utils/formatters";

// Este componente recebe uma nota 'score' e a renderiza como 5 estrelas.
function RatingStars({ score }) {
  const id = useId();
  const s = roundToQuarter(clamp10(score));

  return (
    <div
      className="inline-flex items-center gap-0.5"
      aria-label={`Nota ${s} de 10`}
    >
      {Array.from({ length: 5 }).map((_, i) => {
        const fill = starFillFor(s, i); // Calcula o preenchimento (0 a 1)
        const clipId = `${id}-clip-${i}`;

        return (
          <svg key={i} viewBox="0 0 24 24" className="w-4 h-4">
            <defs>
              <clipPath id={clipId}>
                <rect x="0" y="0" width={24 * fill} height="24" />
              </clipPath>
            </defs>
            {/* Estrela base (vazia) */}
            <path
              d="M12 2.5l2.9 5.88 6.5.94-4.7 4.58 1.11 6.47L12 17.77 6.19 20.37l1.11-6.47-4.7-4.58 6.5-.94L12 2.5z"
              className="text-neutral-300 dark:text-neutral-700"
              fill="currentColor"
            />
            {/* Estrela de preenchimento (parcial ou total), "cortada" pelo clipPath */}
            <g clipPath={`url(#${clipId})`}>
              <path
                d="M12 2.5l2.9 5.88 6.5.94-4.7 4.58 1.11 6.47L12 17.77 6.19 20.37l1.11-6.47-4.7-4.58 6.5-.94L12 2.5z"
                className="text-amber-500"
                fill="currentColor"
              />
            </g>
          </svg>
        );
      })}
    </div>
  );
}

export default RatingStars;
</file>

<file path="client/src/components/ui/ReviewsPanel/ReviewsPanel.jsx">
import React from "react";
import { MessageSquare } from "lucide-react";
import MediaBadge from "../../ui/MediaBadge/MediaBadge";
import RatingStars from "../../ui/RatingStars/RatingStars";
import {
  cx,
  clamp10,
  roundToQuarter,
  formatScore,
} from "../../../utils/formatters";

// Paleta de cores para o gradiente da "capa" de cada tipo de mídia.
const palette = {
  filme: "from-indigo-500/25 via-indigo-500/10 to-transparent",
  livro: "from-emerald-500/25 via-emerald-500/10 to-transparent",
  jogo: "from-fuchsia-500/25 via-fuchsia-500/10 to-transparent",
  album: "from-amber-500/25 via-amber-500/10 to-transparent",
};

// Componente para exibir o painel de reviews de um usuário.
function ReviewsPanel({ reviews, t, containerHeight }) {
  if (!reviews || reviews.length === 0) {
    return null;
  }

  return (
    <section
      className="flex flex-col min-h-0"
      style={{ height: containerHeight || undefined }}
    >
      {/* Cabeçalho da Seção */}
      <div className="flex items-center gap-2 text-sm text-neutral-500 dark:text-neutral-400 mb-3">
        <MessageSquare className="w-4 h-4" />
        <h3 className="text-base font-semibold text-neutral-800 dark:text-neutral-100">
          {t("section.reviews")}
        </h3>
      </div>

      {/* Contêiner Rôlavel */}
      <div className="rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 overflow-hidden flex-1 min-h-0">
        <div className="divide-y divide-neutral-200 dark:divide-neutral-800 h-full overflow-y-auto">
          {reviews.map((review) => (
            <article key={review.id} className="p-4">
              <div className="grid grid-cols-[112px_1fr] gap-4 items-start">
                {/* Imagem/Placeholder */}
                <div
                  className={cx(
                    "w-[112px] h-[112px] rounded-xl bg-gradient-to-br",
                    palette[review.type],
                  )}
                />

                {/* Conteúdo da Review */}
                <div>
                  <div className="flex items-center gap-2 text-xs text-neutral-500">
                    <MediaBadge
                      type={review.type}
                      compact
                      label={t(`badge.${review.type}`)}
                    />
                    <span>•</span>
                    <span>{review.date}</span>
                    <span className="ml-auto inline-flex items-center gap-1">
                      <RatingStars score={review.score} />
                      <span className="text-xs">
                        {formatScore(roundToQuarter(clamp10(review.score)))}
                      </span>
                    </span>
                  </div>
                  <h4 className="mt-2 text-lg font-semibold text-neutral-800 dark:text-neutral-100">
                    {review.title}
                  </h4>
                  <p className="mt-2 text-sm text-neutral-700 dark:text-neutral-200 leading-relaxed">
                    {review.text}
                  </p>
                </div>
              </div>
            </article>
          ))}
        </div>
      </div>
    </section>
  );
}

export default ReviewsPanel;
</file>

<file path="client/src/components/user/BadgeCard/BadgeCard.jsx">
import React from "react";
import {
  BookOpen,
  Music,
  Film,
  Gamepad2,
  Rocket,
  Skull,
  Sword,
  Sun,
  Swords,
  Heart,
  Shield,
  Search,
  Hourglass,
  Zap,
  EyeOff,
  Globe,
  Compass,
  Pickaxe,
  ThumbsUp,
  ThumbsDown,
  Layers,
  Box,
  Infinity,
  Star,
} from "lucide-react";

const ICON_MAP = {
  "book-open": BookOpen,
  music: Music,
  film: Film,
  gamepad: Gamepad2,
  rocket: Rocket,
  skull: Skull,
  sword: Sword,
  sun: Sun,
  "sword-crossed": Swords,
  heart: Heart,
  shield: Shield,
  search: Search,
  hourglass: Hourglass,
  zap: Zap,
  "eye-off": EyeOff,
  globe: Globe,
  compass: Compass,
  pickaxe: Pickaxe,
  "thumbs-up": ThumbsUp,
  "thumbs-down": ThumbsDown,
  layers: Layers,
  box: Box,
  infinity: Infinity,
};

// Cores Hexadecimais
const COLORS = {
  bronze: "#cd7f32",
  silver: "#9ca3af",
  gold: "#eab308",
  locked: "#525252",
};

const BadgeCard = ({ achievement, currentProgress = 0, onClick }) => {
  const IconComponent = ICON_MAP[achievement.iconName] || Star;
  const [bronzeTier, silverTier, goldTier] = achievement.tiers;

  // Estados de Conquista
  const hasBronze = currentProgress >= bronzeTier;
  const hasSilver = currentProgress >= silverTier;
  const hasGold = currentProgress >= goldTier;

  // --- LÓGICA DE CORES E PROGRESSO ---
  let percentage = 0;
  let strokeColor = COLORS.bronze;
  let iconColor = COLORS.locked;
  let iconBg = "bg-neutral-200 dark:bg-neutral-800";
  let isIconLocked = true;

  if (!hasBronze) {
    // 0 -> Buscando Bronze
    // "Ícone apagado e a barra ao redor do ícone cor de bronze"
    percentage = (currentProgress / bronzeTier) * 100;
    strokeColor = COLORS.bronze;
    iconColor = COLORS.locked;
    isIconLocked = true;
  } else if (!hasSilver) {
    // Bronze -> Buscando Prata
    // "Barra e ícone da cor da estrela de prata [ALVO]? Não.
    // Regra corrigida: Até Prata ser alcançada, barra e ícone devem ser da cor da estrela de prata."
    // *Interpretação:* Se eu tenho Bronze, eu estou "no nível Prata" ou "buscando Prata"?
    // O texto diz: "até a estrela de prata ser alcançada, a barra e o ícone sejam da cor da estrela de prata"
    // Isso significa que visualmente ele fica Prateado enquanto busca a prata? Ou ele fica Bronze e a barra Prata?
    // Pelo seu último parágrafo: "ícone prateado... e barra dourada sendo carregada" (quando tem prata).
    // Logo: Se tem Bronze -> Ícone BRONZE, Barra PRATA.

    percentage =
      ((currentProgress - bronzeTier) / (silverTier - bronzeTier)) * 100;
    strokeColor = COLORS.silver; // Barra Prata (Alvo)
    iconColor = COLORS.bronze; // Ícone Bronze (Conquistado)
    iconBg = "bg-orange-900/10 dark:bg-orange-900/20";
    isIconLocked = false;
  } else if (!hasGold) {
    // Prata -> Buscando Ouro
    // "Ícone prateado... barra dourada"
    percentage =
      ((currentProgress - silverTier) / (goldTier - silverTier)) * 100;
    strokeColor = COLORS.gold; // Barra Ouro (Alvo)
    iconColor = COLORS.silver; // Ícone Prata (Conquistado)
    iconBg = "bg-gray-400/10 dark:bg-gray-400/20";
    isIconLocked = false;
  } else {
    // Ouro
    percentage = 100;
    strokeColor = COLORS.gold;
    iconColor = COLORS.gold;
    iconBg = "bg-yellow-500/10 dark:bg-yellow-500/20";
    isIconLocked = false;
  }

  const radius = 40;
  const circumference = 2 * Math.PI * radius;
  const strokeDashoffset = circumference - (percentage / 100) * circumference;

  return (
    <div
      onClick={() => onClick(achievement)}
      className="flex flex-col items-center justify-center cursor-pointer group p-2 rounded-xl transition-transform hover:scale-105"
    >
      <div className="relative w-28 h-28 flex items-center justify-center mb-2">
        <svg className="absolute w-full h-full transform -rotate-90">
          <circle
            cx="50%"
            cy="50%"
            r={radius}
            className="stroke-neutral-200 dark:stroke-neutral-800"
            strokeWidth="6"
            fill="transparent"
          />
          {/* Barra de Progresso sempre visível (pois a página é restrita ao dono) */}
          <circle
            cx="50%"
            cy="50%"
            r={radius}
            stroke={strokeColor}
            strokeWidth="6"
            fill="transparent"
            strokeDasharray={circumference}
            strokeDashoffset={strokeDashoffset}
            strokeLinecap="round"
            className="transition-all duration-1000 ease-out"
          />
        </svg>

        <div
          className={`
          z-10 p-4 rounded-full transition-colors duration-300
          ${iconBg}
        `}
          style={{ color: !isIconLocked ? iconColor : undefined }}
        >
          <IconComponent
            size={32}
            strokeWidth={1.5}
            className={
              isIconLocked ? "text-neutral-400 dark:text-neutral-600" : ""
            }
          />
        </div>
      </div>

      <h3
        className={`
        text-sm font-bold text-center mb-1 leading-tight max-w-[120px]
        ${hasBronze ? "text-neutral-900 dark:text-neutral-100" : "text-neutral-500 dark:text-neutral-500"}
      `}
      >
        {achievement.title}
      </h3>

      <div className="flex items-end gap-1 mt-1 h-6">
        <Star
          size={14}
          fill={hasSilver ? COLORS.silver : "none"}
          color={hasSilver ? COLORS.silver : "#525252"}
          className="mb-0.5"
        />
        <Star
          size={18}
          fill={hasGold ? COLORS.gold : "none"}
          color={hasGold ? COLORS.gold : "#525252"}
          className="mb-2"
        />
        <Star
          size={14}
          fill={hasBronze ? COLORS.bronze : "none"}
          color={hasBronze ? COLORS.bronze : "#525252"}
          className="mb-0.5"
        />
      </div>
    </div>
  );
};

export default BadgeCard;
</file>

<file path="client/src/components/user/BadgesRibbon/BadgesRibbon.jsx">
import React from "react";
import {
  BookOpen,
  Music,
  Film,
  Gamepad2,
  Rocket,
  Skull,
  Sword,
  Sun,
  Swords,
  Heart,
  Shield,
  Search,
  Hourglass,
  Zap,
  EyeOff,
  Globe,
  Compass,
  Pickaxe,
  ThumbsUp,
  ThumbsDown,
  Layers,
  Box,
  Infinity,
  Star,
  BadgeCheck,
} from "lucide-react";
import { cx } from "../../../utils/formatters";
import ExpandButton from "../../ui/ExpandButton/ExpandButton";
import { MASTER_ACHIEVEMENTS_LIST } from "../../../hooks/useUserProfileData";

const ICON_MAP = {
  "book-open": BookOpen,
  music: Music,
  film: Film,
  gamepad: Gamepad2,
  rocket: Rocket,
  skull: Skull,
  sword: Sword,
  sun: Sun,
  "sword-crossed": Swords,
  heart: Heart,
  shield: Shield,
  search: Search,
  hourglass: Hourglass,
  zap: Zap,
  "eye-off": EyeOff,
  globe: Globe,
  compass: Compass,
  pickaxe: Pickaxe,
  "thumbs-up": ThumbsUp,
  "thumbs-down": ThumbsDown,
  layers: Layers,
  box: Box,
  infinity: Infinity,
};

const COLORS = {
  bronze: "#cd7f32",
  silver: "#9ca3af",
  gold: "#eab308",
  locked: "#525252",
};

const getBadgeColor = (progress, tiers) => {
  if (!tiers) return COLORS.locked;
  const [bronze, silver, gold] = tiers;
  if (progress >= gold) return COLORS.gold;
  if (progress >= silver) return COLORS.silver;
  if (progress >= bronze) return COLORS.bronze;
  return COLORS.locked;
};

function BadgesRibbon({ badges, t, handle, isOwner }) {
  if (!badges || badges.length === 0) {
    return null;
  }

  const displayBadges = badges
    .map((userBadge) => {
      const definition = MASTER_ACHIEVEMENTS_LIST.find(
        (item) => item.id === userBadge.id,
      );
      if (!definition) return null;
      return {
        ...userBadge,
        ...definition,
      };
    })
    .filter(Boolean);

  if (displayBadges.length === 0) return null;

  return (
    <section>
      <div className="flex items-center justify-between mb-3">
        <div className="flex items-center gap-2 text-sm text-neutral-500 dark:text-neutral-400">
          <BadgeCheck className="w-4 h-4" />
          <h3 className="text-base font-semibold text-neutral-800 dark:text-neutral-100">
            {t("section.achievements")}
          </h3>
        </div>

        {isOwner && handle && (
          <ExpandButton
            to={`/profile/${handle}/achievements`}
            ariaLabel={t("action.see_all")}
          />
        )}
      </div>

      <div className="flex flex-wrap items-center gap-4 select-none">
        {displayBadges.map((badge) => {
          const IconComponent = ICON_MAP[badge.iconName] || Star;
          const badgeColor = getBadgeColor(badge.progress, badge.tiers);

          // Formata o ID para Título (ex: "the-one" -> "The One")
          const badgeTitle = badge.id
            .replace(/-/g, " ")
            .replace(/\b\w/g, (l) => l.toUpperCase());

          return (
            <div
              key={badge.id}
              className="relative group flex flex-col items-center"
            >
              <div
                className="w-12 h-12 rounded-full border-2 flex items-center justify-center bg-neutral-100 dark:bg-neutral-800 transition-colors"
                style={{ borderColor: badgeColor, color: badgeColor }}
              >
                <IconComponent size={20} strokeWidth={2} />
              </div>

              {/* Tooltip atualizado: Título em negrito + Descrição */}
              <div className="absolute top-full mt-2 px-3 py-2 rounded bg-neutral-900 text-white text-xs opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap z-20 pointer-events-none shadow-lg border border-neutral-700">
                <span className="font-bold text-neutral-200">
                  {badgeTitle}:
                </span>{" "}
                {t(`achievement.desc.${badge.id}`) || badge.id}
              </div>
            </div>
          );
        })}
      </div>
    </section>
  );
}

export default BadgesRibbon;
</file>

<file path="client/src/components/user/FavoritesSection/FavoritesSection.jsx">
import React, { useState, useMemo } from "react";
import { Link } from "react-router-dom";
import { Star as StarIcon } from "lucide-react";

import { cx } from "../../../utils/formatters";
import MediaCard from "../../ui/MediaCard/MediaCard.jsx";
import ExpandButton from "../../ui/ExpandButton/ExpandButton.jsx"; // Importando o novo botão

function FavoritesSection({ items, t, handle }) {
  const [filter, setFilter] = useState("todos");

  const filteredItems = useMemo(() => {
    if (!items) return [];
    return items
      .filter((i) => (filter === "todos" ? true : i.type === filter))
      .sort((a, b) => b.score - a.score)
      .slice(0, 8);
  }, [filter, items]);

  const renderFilterChips = () => {
    const chips = [
      { k: "todos", label: t("filter.all") },
      { k: "filme", label: t("filter.movies") },
      { k: "livro", label: t("filter.books") },
      { k: "jogo", label: t("filter.games") },
      { k: "album", label: t("filter.albums") },
    ];
    return (
      <>
        {chips.map((f) => (
          <button
            key={f.k}
            onClick={() => setFilter(f.k)}
            className={cx(
              "px-3 py-1.5 rounded-full border text-xs font-medium transition-colors",
              filter === f.k
                ? "bg-neutral-900 text-white dark:bg-white dark:text-neutral-900 border-neutral-900 dark:border-white"
                : "border-neutral-200 dark:border-neutral-700 text-neutral-600 dark:text-neutral-400 hover:bg-neutral-100 dark:hover:bg-neutral-800",
            )}
          >
            {f.label}
          </button>
        ))}
      </>
    );
  };

  return (
    <section>
      <div className="mb-3 grid grid-cols-[auto_1fr_auto] items-center gap-2">
        {/* Título e Ícone */}
        <div className="flex items-center gap-2 text-sm text-neutral-500 dark:text-neutral-400">
          <StarIcon className="w-4 h-4" />
          <h3 className="text-base font-semibold text-neutral-800 dark:text-neutral-100">
            {t("section.favorites")}
          </h3>
        </div>

        {/* Filtros (Chips) */}
        <div className="justify-self-start lg:justify-self-center overflow-x-auto no-scrollbar w-full lg:w-auto px-2 lg:px-0">
          <div className="flex items-center gap-2 text-xs whitespace-nowrap">
            {renderFilterChips()}
          </div>
        </div>

        {/* Botão Expandir (+) */}
        <div className="justify-self-end">
          <ExpandButton
            to={`/profile/${handle}/favorites`}
            ariaLabel={t("action.explore")}
          />
        </div>
      </div>

      {/* Grid de Cards */}
      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3 min-h-[32.75rem]">
        {filteredItems.map((item) => (
          <Link to={`/media/${item.id}`} key={item.id}>
            <MediaCard item={item} wide badgeLabel={t(`badge.${item.type}`)} />
          </Link>
        ))}
      </div>
    </section>
  );
}

export default FavoritesSection;
</file>

<file path="client/src/components/user/ProfileHeader/ProfileHeader.jsx">
import React from "react";

function ProfileHeader({ profile, tags, t }) {
  if (!profile) {
    return null;
  }

  return (
    // AQUI ESTÁ A MUDANÇA PRINCIPAL: De Grid para Flexbox
    <section className="flex flex-row items-start gap-6 md:gap-8">
      {/* Coluna da Esquerda: Agora é um item flexível que cresce */}
      <div className="flex-1 min-w-0">
        <h1 className="text-2xl sm:text-3xl md:text-4xl font-extrabold tracking-tight">
          {profile.name}
        </h1>
        <div className="mt-1 text-neutral-500">{profile.handle}</div>
        <p className="mt-4 text-neutral-700 dark:text-neutral-300 max-w-2xl">
          {profile.bio}
        </p>

        {/* Contêiner das Tags: Agora dentro de um pai flexível, ele se comportará corretamente */}
        <div className="mt-4 flex flex-row gap-2 flex-nowrap overflow-hidden">
          {tags &&
            tags.map((tagKey) => (
              <span
                key={tagKey}
                className="inline-flex items-center justify-center h-8 px-3 rounded-full border border-neutral-200 dark:border-neutral-700 text-sm leading-none bg-white/60 dark:bg-neutral-900/60 capitalize shrink-0"
              >
                {t(tagKey)}
              </span>
            ))}
        </div>
      </div>

      {/* Coluna da Direita (Avatar): Agora um item flexível com tamanho fixo */}
      <img
        src={profile.avatarUrl}
        alt={`Avatar de ${profile.name}`}
        className="w-48 md:w-56 h-auto rounded-2xl object-cover border border-neutral-200 dark:border-neutral-800 shadow-sm flex-shrink-0"
      />
    </section>
  );
}

export default ProfileHeader;
</file>

<file path="client/src/components/user/ReviewCard/ReviewCard.jsx">
import React from "react";
import { Link } from "react-router-dom";
import { cx, formatScore } from "../../../utils/formatters";
import RatingStars from "../../ui/RatingStars/RatingStars.jsx";
import MediaBadge from "../../ui/MediaBadge/MediaBadge.jsx";

// Paleta de cores para o placeholder da capa (caso não tenha imagem)
const typeColors = {
  filme: "from-indigo-500 to-purple-600",
  livro: "from-emerald-500 to-teal-600",
  jogo: "from-rose-500 to-orange-600",
  album: "from-amber-500 to-yellow-600",
};

export default function ReviewCard({ review, t }) {
  // Se a review tiver dados de usuário, mostramos o cabeçalho de autor
  const showAuthor = !!review.user;

  return (
    <div className="p-4 bg-white dark:bg-neutral-900 border border-neutral-200 dark:border-neutral-800 rounded-2xl hover:border-neutral-300 dark:hover:border-neutral-700 transition-colors group">
      {/* CABEÇALHO DO AUTOR (Novo: Para a Home) */}
      {showAuthor && (
        <div className="flex items-center gap-3 mb-3 pb-3 border-b border-neutral-100 dark:border-neutral-800">
          <Link
            to={`/profile/${review.user.handle.replace("@", "")}`}
            className="shrink-0"
          >
            {review.user.avatarUrl ? (
              <img
                src={review.user.avatarUrl}
                alt={review.user.name}
                className="w-8 h-8 rounded-full object-cover"
              />
            ) : (
              <div className="w-8 h-8 rounded-full bg-gradient-to-br from-neutral-200 to-neutral-400 dark:from-neutral-700 dark:to-neutral-600 flex items-center justify-center text-xs font-bold text-neutral-700 dark:text-neutral-200">
                {review.user.avatar || review.user.name[0]}
              </div>
            )}
          </Link>
          <div className="flex flex-col leading-tight">
            <Link
              to={`/profile/${review.user.handle.replace("@", "")}`}
              className="font-semibold text-sm hover:underline text-neutral-900 dark:text-neutral-100"
            >
              {review.user.name}
            </Link>
            <span className="text-xs text-neutral-500">
              {review.user.handle}
            </span>
          </div>
          <span className="ml-auto text-xs text-neutral-400">
            {review.date}
          </span>
        </div>
      )}

      <div className="flex gap-4">
        {/* Poster / Capa (Miniatura) */}
        <Link
          to={`/media/${review.type}/${review.mediaId || "m1"}`}
          className="shrink-0"
        >
          <div
            className={cx(
              "w-16 h-24 rounded-lg bg-gradient-to-br shadow-sm",
              typeColors[review.type] || "from-gray-500 to-gray-600",
            )}
          />
        </Link>

        {/* Conteúdo */}
        <div className="flex-1 min-w-0 flex flex-col">
          <div className="flex items-start justify-between gap-2">
            <div>
              <div className="flex items-center gap-2 mb-1">
                <MediaBadge
                  type={review.type}
                  compact
                  label={t ? t(`badge.${review.type}`) : review.type}
                />
                {!showAuthor && (
                  <span className="text-xs text-neutral-500">
                    {review.date}
                  </span>
                )}
              </div>
              <h4 className="font-bold text-neutral-900 dark:text-neutral-100 truncate leading-tight">
                {review.title}
              </h4>
            </div>
            <div className="flex flex-col items-end">
              <span className="font-mono font-bold text-lg text-indigo-600 dark:text-indigo-400 leading-none">
                {formatScore(review.score)}
              </span>
              <div className="scale-75 origin-right">
                <RatingStars score={review.score} />
              </div>
            </div>
          </div>

          <p className="mt-2 text-sm text-neutral-600 dark:text-neutral-300 line-clamp-3 leading-relaxed">
            "{review.text}"
          </p>

          {/* Tags (Opcional) */}
          {review.tags && (
            <div className="mt-auto pt-2 flex gap-1 overflow-hidden opacity-60 hover:opacity-100 transition-opacity">
              {review.tags.slice(0, 2).map((tag) => (
                <span
                  key={tag}
                  className="text-[10px] uppercase tracking-wider font-medium text-neutral-500 bg-neutral-100 dark:bg-neutral-800 px-1.5 py-0.5 rounded"
                >
                  {t ? t(tag) : tag}
                </span>
              ))}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/user/ReviewsPanel/ReviewsPanel.jsx">
import React from "react";
import { MessageSquare } from "lucide-react";

import ReviewCard from "../ReviewCard/ReviewCard.jsx";
import ExpandButton from "../../ui/ExpandButton/ExpandButton.jsx"; // Importando o novo botão

// Componente para exibir o painel de reviews de um usuário.
function ReviewsPanel({ reviews, t, containerHeight, handle }) {
  if (!reviews || reviews.length === 0) {
    return null;
  }

  return (
    <section
      className="flex flex-col min-h-0"
      style={{ height: containerHeight || undefined }}
    >
      {/* Cabeçalho da Seção */}
      <div className="mb-3 grid grid-cols-[auto_1fr_auto] items-center gap-2">
        <div className="flex items-center gap-2 text-sm text-neutral-500 dark:text-neutral-400">
          <MessageSquare className="w-4 h-4" />
          <h3 className="text-base font-semibold text-neutral-800 dark:text-neutral-100">
            {t("section.reviews")}
          </h3>
        </div>

        {/* Div espaçador (caso necessário para o grid layout se manter consistente) */}
        <div></div>

        {/* Botão Expandir (+) */}
        {handle && (
          <div className="justify-self-end">
            <ExpandButton
              to={`/profile/${handle}/reviews`}
              ariaLabel={t("action.see_more")}
            />
          </div>
        )}
      </div>

      {/* Contêiner Rôlavel */}
      <div className="rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 overflow-hidden flex-1 min-h-0">
        <div className="divide-y divide-neutral-200 dark:divide-neutral-800 h-full overflow-y-auto">
          {reviews.map((review) => (
            <ReviewCard key={review.id} review={review} t={t} />
          ))}
        </div>
      </div>
    </section>
  );
}

export default ReviewsPanel;
</file>

<file path="client/src/constants/books.genres.js">
// src/constants/books.genres.js

// =====================================================
// LIVROS (Google Books Categories -> Classificador -> Top 3)
// =====================================================
//
// Objetivo:
// - Receber categories do Google Books (strings ruidosas e hierárquicas)
// - Classificar em chaves canônicas (conjunto pequeno) para evitar ruído infinito
// - Traduzir essas chaves para PT/ES/EN
// - Retornar no máximo 3 gêneros por livro
//
// Observação:
// - O backend entrega para livros um array "genres" com as categories cruas do Google Books.
// - Este módulo transforma esse array em 1..3 gêneros "bons" para exibição.

export const BOOK_GENRE_TRANSLATIONS = {
    // Macros
    fiction: { pt: "Ficção", es: "Ficción", en: "Fiction" },
    non_fiction: { pt: "Não Ficção", es: "No Ficción", en: "Non-fiction" },

    // Ficção
    fantasy: { pt: "Fantasia", es: "Fantasía", en: "Fantasy" },
    sci_fi: { pt: "Ficção Científica", es: "Ciencia Ficción", en: "Science Fiction" },
    romance: { pt: "Romance", es: "Romance", en: "Romance" },
    mystery: { pt: "Mistério", es: "Misterio", en: "Mystery" },
    thriller: { pt: "Suspense", es: "Suspenso", en: "Thriller" },
    horror: { pt: "Terror", es: "Terror", en: "Horror" },

    // Não ficção / temas grandes
    history: { pt: "História", es: "Historia", en: "History" },
    biography: { pt: "Biografia", es: "Biografía", en: "Biography" },
    philosophy: { pt: "Filosofia", es: "Filosofía", en: "Philosophy" },
    religion: { pt: "Religião", es: "Religión", en: "Religion" },
    psychology: { pt: "Psicologia", es: "Psicología", en: "Psychology" },
    self_help: { pt: "Autoajuda", es: "Autoayuda", en: "Self-help" },

    business: { pt: "Negócios", es: "Negocios", en: "Business" },
    economics: { pt: "Economia", es: "Economía", en: "Economics" },
    finance: { pt: "Finanças", es: "Finanzas", en: "Finance" },

    politics: { pt: "Política", es: "Política", en: "Politics" },
    social_science: { pt: "Ciências Sociais", es: "Ciencias Sociales", en: "Social Science" },

    science: { pt: "Ciência", es: "Ciencia", en: "Science" },
    technology: { pt: "Tecnologia", es: "Tecnología", en: "Technology" },
    education: { pt: "Educação", es: "Educación", en: "Education" },
    health: { pt: "Saúde", es: "Salud", en: "Health" },

    // Formatos / públicos
    children: { pt: "Infantil", es: "Infantil", en: "Children" },
    young_adult: { pt: "Jovem Adulto", es: "Juvenil", en: "Young Adult" },
    comics: { pt: "Quadrinhos", es: "Cómics", en: "Comics" },
    poetry: { pt: "Poesia", es: "Poesía", en: "Poetry" },

    // Lifestyle
    cooking: { pt: "Culinária", es: "Cocina", en: "Cooking" },
    travel: { pt: "Viagem", es: "Viajes", en: "Travel" },
    art: { pt: "Arte", es: "Arte", en: "Art" }
};

const normalizeLang = (langCode = "PT") => {
    const l = langCode ? String(langCode).toLowerCase().split("-")[0] : "pt";
    if (l !== "pt" && l !== "es" && l !== "en") return "pt";
    return l;
};

const cleanCategoryString = (value) => {
    if (!value || typeof value !== "string") return "";
    return value
    .replace("tag.", "")
    .replace(/-/g, " ")
    .replace(/\s+/g, " ")
    .trim();
};

const splitCategoryPath = (category) => {
    // Ex.: "Fiction / Fantasy / General" -> ["fiction", "fantasy", "general"]
    const cleaned = cleanCategoryString(category);
    if (!cleaned) return [];
    return cleaned
    .split("/")
    .map((s) => s.trim().toLowerCase())
    .filter(Boolean);
};

// Genéricos: só entram se não houver nenhum gênero mais específico
const BOOK_GENERIC_KEYS = new Set(["fiction", "non_fiction"]);

// Tokens que pouco ajudam e aparecem muito em paths
const BOOK_IGNORE_TOKENS = new Set(["general", "miscellaneous", "other", "books", "literature"]);

// Regras: padrões para mapear tokens (ou a string inteira) em chaves canônicas.
const BOOK_RULES = [
    // Público / faixa
    { key: "children", patterns: [/juvenile/, /children/, /\bkids?\b/] },
{ key: "young_adult", patterns: [/young adult/, /\bya\b/] },

// Ficção
{ key: "fantasy", patterns: [/fantasy/] },
{ key: "sci_fi", patterns: [/science fiction/, /sci[\s-]?fi/, /\bsf\b/] },
{ key: "romance", patterns: [/romance/] },
{ key: "mystery", patterns: [/mystery/, /detective/] },
{ key: "thriller", patterns: [/thriller/, /suspense/] },
{ key: "horror", patterns: [/horror/] },

// Macros
{ key: "non_fiction", patterns: [/non[\s-]?fiction/] },
{ key: "fiction", patterns: [/^fiction$/, /literary fiction/, /\bnovel\b/] },

// Não ficção / grandes temas
{ key: "history", patterns: [/^history$/, /historical/] },
{ key: "biography", patterns: [/biography/, /autobiography/, /memoir/] },
{ key: "philosophy", patterns: [/philosophy/] },
{ key: "religion", patterns: [/religion/, /theology/, /spiritual/] },
{ key: "psychology", patterns: [/psychology/, /behavior/, /behaviour/] },
{ key: "self_help", patterns: [/self[\s-]?help/, /personal growth/, /motivational/] },

{ key: "business", patterns: [/business/, /management/, /marketing/, /entrepreneur/] },
{ key: "economics", patterns: [/economics/] },
{ key: "finance", patterns: [/finance/, /investment/, /investing/, /personal finance/] },

{ key: "politics", patterns: [/politics/, /government/, /public policy/, /political science/] },
{ key: "social_science", patterns: [/social science/, /sociology/, /anthropology/] },

{ key: "science", patterns: [/science/, /physics/, /chemistry/, /biology/, /mathematics/, /astronomy/] },
{ key: "technology", patterns: [/computers/, /technology/, /programming/, /software/, /internet/] },
{ key: "education", patterns: [/education/, /study aids/, /language arts/, /disciplines/, /reference/] },
{ key: "health", patterns: [/health/, /fitness/, /medical/, /nutrition/, /wellness/] },

// Formatos
{ key: "comics", patterns: [/comics/, /graphic novels?/, /manga/] },
{ key: "poetry", patterns: [/poetry/] },

// Lifestyle
{ key: "cooking", patterns: [/cooking/, /food/, /recipes?/] },
{ key: "travel", patterns: [/travel/] },
{ key: "art", patterns: [/art/, /photography/, /music/, /performing arts/] }
];

const matchBookRule = (tokenOrFullString) => {
    if (!tokenOrFullString) return null;
    for (const rule of BOOK_RULES) {
        for (const re of rule.patterns) {
            if (re.test(tokenOrFullString)) return rule.key;
        }
    }
    return null;
};

const uniq = (arr) => Array.from(new Set(arr));

/**
 * Classifica categories do Google Books em chaves canônicas.
 * Retorna no máximo 3.
 * Importante: este passo reduz ruído e evita dicionário infinito.
 */
export const classifyBookGenres = (rawCategories, limit = 3) => {
    const categories = Array.isArray(rawCategories)
    ? rawCategories
    : typeof rawCategories === "string"
    ? [rawCategories]
    : [];

    if (categories.length === 0) return [];

    const scores = {}; // key -> score

    for (const cat of categories) {
        const segments = splitCategoryPath(cat);

        // 1) tenta casar por segmento (path)
        for (let i = 0; i < segments.length; i++) {
            const token = segments[i];
            if (!token) continue;
            if (BOOK_IGNORE_TOKENS.has(token)) continue;

            // Peso: quanto mais profundo no path, mais específico tende a ser.
            const weight = 10 + i * 10;

            const matchedKey = matchBookRule(token);
            if (matchedKey) {
                scores[matchedKey] = (scores[matchedKey] || 0) + weight;
            }
        }

        // 2) tenta casar na string inteira (às vezes o split perde informação como "&")
        const full = cleanCategoryString(cat).toLowerCase();
        if (full) {
            const matchedKey = matchBookRule(full);
            if (matchedKey) {
                scores[matchedKey] = (scores[matchedKey] || 0) + 8;
            }
        }
    }

    // Ranking por score
    const ranked = Object.entries(scores)
    .sort((a, b) => b[1] - a[1])
    .map(([k]) => k);

    // Fallback para evitar "livro alien":
    // Se nenhuma regra casou, tenta inferir macro por presença de "fiction".
    if (ranked.length === 0) {
        const joined = categories.map((c) => cleanCategoryString(c).toLowerCase()).join(" | ");
        if (/\bfiction\b/.test(joined)) return ["fiction"].slice(0, limit);
        return ["non_fiction"].slice(0, limit);
    }

    // Remove genéricos se já existe algo mais específico.
    const hasSpecific = ranked.some((k) => !BOOK_GENERIC_KEYS.has(k));
    let filtered = ranked;
    if (hasSpecific) filtered = ranked.filter((k) => !BOOK_GENERIC_KEYS.has(k));

    // Garante que nunca fica vazio aqui
    if (filtered.length === 0) filtered = ranked;

    // Dedup e top N
    return uniq(filtered).slice(0, limit);
};

export const translateBookGenreKey = (genreKey, langCode = "PT") => {
    if (!genreKey) return "";
    const lang = normalizeLang(langCode);

    const entry = BOOK_GENRE_TRANSLATIONS[genreKey];
    if (!entry) {
        // fallback: humaniza a chave
        return String(genreKey).replace(/_/g, " ").trim();
    }

    if (lang === "pt") return entry.pt || entry.en || entry.es || genreKey;
    if (lang === "es") return entry.es || entry.pt || entry.en || genreKey;
    return entry.en || entry.pt || entry.es || genreKey;
};

/**
 * Retorna os gêneros de livros já prontos para exibição (no idioma do site),
 * limitados a no máximo 3.
 */
export const getBookGenresTop3 = (rawCategories, langCode = "PT", limit = 3) => {
    const keys = classifyBookGenres(rawCategories, limit);
    return keys.map((k) => translateBookGenreKey(k, langCode)).filter(Boolean);
};
</file>

<file path="client/src/constants/game.genres.js">
// src/constants/game.genres.js

export const GENRE_TRANSLATIONS = {
    "action": { pt: "Ação", es: "Acción" },
    "adventure": { pt: "Aventura", es: "Aventura" },
    "indie": { pt: "Indie", es: "Indie" },
    "rpg": { pt: "RPG", es: "RPG" },
    "strategy": { pt: "Estratégia", es: "Estrategia" },
    "shooter": { pt: "Tiro", es: "Shooter" },
    "casual": { pt: "Casual", es: "Casual" },
    "simulation": { pt: "Simulação", es: "Simulación" },
    "puzzle": { pt: "Quebra-Cabeça", es: "Puzles" },
    "arcade": { pt: "Arcade", es: "Arcade" },
    "platformer": { pt: "Plataforma", es: "Plataformas" },
    "racing": { pt: "Corrida", es: "Carreras" },
    "massively multiplayer": { pt: "MMO", es: "MMO" },
    "sports": { pt: "Esportes", es: "Deportes" },
    "fighting": { pt: "Luta", es: "Lucha" },
    "family": { pt: "Família", es: "Familia" },
    "board games": { pt: "Jogos de Tabuleiro", es: "Juegos de Mesa" },
    "educational": { pt: "Educacional", es: "Educativo" },
    "card": { pt: "Cartas", es: "Cartas" },
    "hack and slash": { pt: "Hack and Slash", es: "Hack and Slash" }
};

/**
 * Traduz o gênero de forma robusta.
 * Aceita strings sujas (com espaços), cases variados e retorna o idioma correto.
 */
export const translateGenre = (englishName, langCode = 'PT') => {
    if (!englishName || typeof englishName !== 'string') return "";

    // 1. Limpeza e Normalização
    const cleanString = englishName.replace('tag.', '').replace(/-/g, ' ').trim();
    const lowerKey = cleanString.toLowerCase();

    // 2. Detecção de Idioma
    const lang = langCode ? langCode.toLowerCase().split('-')[0] : 'pt';

    // Se o idioma do site for inglês, retorna o original limpo
    if (lang === 'en') return cleanString;

    // 3. Busca no Dicionário
    const entry = GENRE_TRANSLATIONS[lowerKey];

    // Se não encontrar, retorna o original (Fallback)
    if (!entry) return cleanString;

    // Retorna tradução ou fallback para PT
    return entry[lang] || entry['pt'] || cleanString;
};
</file>

<file path="client/src/constants/genres.js">
// src/constants/genres.js
//
// FACHADA (Facade) para gêneros.
// Motivo:
// - manter compatibilidade com imports existentes no projeto
// - separar implementação por domínio:
//   - jogos: ./game.genres.js
//   - livros: ./books.genres.js

export { GENRE_TRANSLATIONS, translateGenre } from "./game.genres";

export {
    BOOK_GENRE_TRANSLATIONS,
    classifyBookGenres,
    translateBookGenreKey,
    getBookGenresTop3
} from "./books.genres";
</file>

<file path="client/src/contexts/UserDatabaseContext.jsx">
import React, { createContext, useContext, useState, useMemo } from "react";
// Importamos os dados estáticos *originais*
import {
  staticUserDatabase,
  staticMediaDatabase,
  staticClubsDatabase,
} from "../hooks/useUserProfileData.js";

// --- Definição do Contexto ---
const UserDatabaseContext = createContext(null);

// --- O Provedor ---
export function UserDatabaseProvider({ children }) {
  const [db, setDb] = useState(staticUserDatabase);
  const mediaDatabase = staticMediaDatabase;

  // Estado para os Clubes
  const [clubsDb, setClubsDb] = useState(staticClubsDatabase);

  // --- Funções para Modificar a "Memória" ---

  const toggleFavorite = (userId, mediaData) => {
    if (!mediaData) return;

    setDb((prevDb) => {
      const userHandle = userId.replace("@", "");
      const currentUser = prevDb[userHandle];
      if (!currentUser) return prevDb;

      const currentFavorites = currentUser.favorites || [];
      const isFavorited = currentFavorites.some(
        (fav) => fav.id === mediaData.id,
      );

      let newFavorites;

      if (isFavorited) {
        newFavorites = currentFavorites.filter(
          (fav) => fav.id !== mediaData.id,
        );
      } else {
        const newFavoriteItem = {
          id: mediaData.id,
          type: mediaData.type,
          title: mediaData.title,
          year: mediaData.details?.Ano || mediaData.year,
          score: mediaData.communityAverage || mediaData.score,
          tags: mediaData.details?.Gênero || mediaData.tags,
        };
        newFavorites = [...currentFavorites, newFavoriteItem];
      }

      return {
        ...prevDb,
        [userHandle]: {
          ...currentUser,
          favorites: newFavorites,
        },
      };
    });
  };

  // --- LÓGICA DE LISTAS ---

  const createCollection = (userId, title, description) => {
    const userHandle = userId.replace("@", "");
    const newCollection = {
      id: `col_${Date.now()}`,
      title,
      description,
      items: [],
    };

    setDb((prevDb) => {
      const currentUser = prevDb[userHandle];
      return {
        ...prevDb,
        [userHandle]: {
          ...currentUser,
          collections: [...(currentUser.collections || []), newCollection],
        },
      };
    });
    return newCollection.id;
  };

  const updateCollectionDetails = (
    userId,
    collectionId,
    newTitle,
    newDescription,
  ) => {
    const userHandle = userId.replace("@", "");
    setDb((prevDb) => {
      const currentUser = prevDb[userHandle];
      const newCollections = currentUser.collections.map((col) =>
        col.id === collectionId
          ? { ...col, title: newTitle, description: newDescription }
          : col,
      );
      return {
        ...prevDb,
        [userHandle]: {
          ...currentUser,
          collections: newCollections,
        },
      };
    });
  };

  const addMediaToCollection = (userId, collectionId, mediaId) => {
    const userHandle = userId.replace("@", "");
    const itemData = mediaDatabase[mediaId];
    if (!itemData) return;

    const newCollectionItem = {
      id: itemData.id,
      type: itemData.type,
      title: itemData.title.PT || "Título Desconhecido",
    };

    setDb((prevDb) => {
      const currentUser = prevDb[userHandle];
      if (!currentUser) return prevDb;

      const newCollections = currentUser.collections.map((col) => {
        if (col.id === collectionId) {
          if (col.items.some((item) => item.id === mediaId)) return col;
          return { ...col, items: [...col.items, newCollectionItem] };
        }
        return col;
      });

      const isFavorited = currentUser.favorites.some(
        (fav) => fav.id === mediaId,
      );
      let newFavorites = currentUser.favorites;
      if (!isFavorited) {
        const newFavoriteItem = {
          id: itemData.id,
          type: itemData.type,
          title: itemData.title,
          year: itemData.details?.Ano,
          score: itemData.communityAverage,
          tags: itemData.details?.Gênero,
        };
        newFavorites = [...currentUser.favorites, newFavoriteItem];
      }

      return {
        ...prevDb,
        [userHandle]: {
          ...currentUser,
          collections: newCollections,
          favorites: newFavorites,
        },
      };
    });
  };

  const removeMediaFromCollection = (userId, collectionId, mediaId) => {
    const userHandle = userId.replace("@", "");
    setDb((prevDb) => {
      const currentUser = prevDb[userHandle];
      const newCollections = currentUser.collections.map((col) => {
        if (col.id === collectionId) {
          const newItems = col.items.filter((item) => item.id !== mediaId);
          return { ...col, items: newItems };
        }
        return col;
      });
      return {
        ...prevDb,
        [userHandle]: {
          ...currentUser,
          collections: newCollections,
        },
      };
    });
  };

  const deleteCollection = (userId, collectionId) => {
    const userHandle = userId.replace("@", "");
    setDb((prevDb) => {
      const currentUser = prevDb[userHandle];
      const newCollections = currentUser.collections.filter(
        (col) => col.id !== collectionId,
      );
      return {
        ...prevDb,
        [userHandle]: {
          ...currentUser,
          collections: newCollections,
        },
      };
    });
  };

  // --- LÓGICA DE PERFIL (NOVO) ---
  const updateUserProfile = (userId, updatedData) => {
    const userHandle = userId.replace("@", "");

    setDb((prevDb) => {
      const currentUser = prevDb[userHandle];
      if (!currentUser) return prevDb;

      return {
        ...prevDb,
        [userHandle]: {
          ...currentUser,
          profile: {
            ...currentUser.profile,
            ...updatedData, // Mescla os novos dados (nome, bio, avatar)
          },
        },
      };
    });
  };

  // --- LÓGICA DE CLUBES ---

  const createClub = (ownerHandle, clubData) => {
    const newClub = {
      id: `c_${Date.now()}`,
      ownerHandle: ownerHandle.replace("@", ""),
      membersCount: 1,
      ...clubData,
      activeWorks: [],
      topics: [],
      members: [
        {
          name: "Fundador",
          handle: ownerHandle,
          role: "owner",
          avatar: "F",
        },
      ],
    };

    setClubsDb((prevClubs) => [...prevClubs, newClub]);
    return newClub.id;
  };

  const updateClub = (clubId, updatedData) => {
    setClubsDb((prevClubs) =>
      prevClubs.map((club) =>
        club.id === clubId ? { ...club, ...updatedData } : club,
      ),
    );
  };

  const deleteClub = (clubId) => {
    setClubsDb((prevClubs) => prevClubs.filter((c) => c.id !== clubId));
  };

  const value = useMemo(
    () => ({
      db,
      mediaDatabase,
      clubsDb,
      toggleFavorite,
      createCollection,
      updateCollectionDetails,
      addMediaToCollection,
      removeMediaFromCollection,
      deleteCollection,
      createClub,
      updateClub,
      deleteClub,
      updateUserProfile, // Exportando a nova função
    }),
    [db, clubsDb],
  );

  return (
    <UserDatabaseContext.Provider value={value}>
      {children}
    </UserDatabaseContext.Provider>
  );
}

export function useUserDatabase() {
  const context = useContext(UserDatabaseContext);
  if (!context) {
    throw new Error(
      "useUserDatabase deve ser usado dentro de um UserDatabaseProvider",
    );
  }
  return context;
}
</file>

<file path="client/src/hooks/useTheme.js">
import { useState, useEffect } from "react";

export function useTheme() {
  const [theme, setTheme] = useState(() => {
    // Verifica se o código está rodando no navegador antes de acessar o window
    if (typeof window === "undefined") return "light";

    // 1. Tenta pegar o tema salvo no localStorage
    const saved = localStorage.getItem("theme_v1");
    if (saved === "dark" || saved === "light") return saved;

    // 2. Se não houver tema salvo, verifica a preferência do sistema operacional
    return window.matchMedia &&
      window.matchMedia("(prefers-color-scheme: dark)").matches
      ? "dark"
      : "light";
  });

  // Este efeito roda toda vez que o estado 'theme' muda
  useEffect(() => {
    try {
      // Salva a preferência atual do usuário no localStorage
      localStorage.setItem("theme_v1", theme);
    } catch (e) {
      // Ignora erros caso o localStorage não esteja disponível
      console.error("Failed to save theme to localStorage", e);
    }
  }, [theme]);

  return { theme, setTheme };
}
</file>

<file path="client/src/hooks/useUserProfileData.js">
import { useMemo } from "react";
// 1. Importar o hook para usar o Contexto
import { useUserDatabase } from "../contexts/UserDatabaseContext.jsx";

// ==========================
// LISTA MESTRA DE CONQUISTAS
// ==========================
export const MASTER_ACHIEVEMENTS_LIST = [
  { id: "the-one", tiers: [12, 25, 52], iconName: "book-open" },
  { id: "narya", tiers: [12, 25, 52], iconName: "music" },
  { id: "vilya", tiers: [12, 25, 52], iconName: "film" },
  { id: "nenya", tiers: [12, 25, 52], iconName: "gamepad" },
  { id: "life-universe-everything", tiers: [1, 6, 12], iconName: "rocket" },
  { id: "horror-business", tiers: [1, 6, 12], iconName: "skull" },
  { id: "wood-between-worlds", tiers: [1, 6, 12], iconName: "sword" },
  { id: "once-upon-time-west", tiers: [1, 6, 12], iconName: "sun" },
  { id: "kagemusha", tiers: [1, 6, 12], iconName: "sword-crossed" },
  { id: "help-me-eros", tiers: [1, 6, 12], iconName: "heart" },
  { id: "guernica", tiers: [1, 6, 12], iconName: "shield" },
  { id: "nighthawks", tiers: [1, 6, 12], iconName: "search" },
  { id: "perche-leggere-classici", tiers: [1, 6, 12], iconName: "hourglass" },
  { id: "zeitgeist", tiers: [6, 12, 25], iconName: "zap" },
  { id: "moritarnon", tiers: [1, 3, 6], iconName: "eye-off" },
  { id: "arda", tiers: [1, 3, 6], iconName: "globe" },
  { id: "rhun", tiers: [1, 3, 6], iconName: "compass" },
  { id: "khazad-dum", tiers: [1, 6, 12], iconName: "pickaxe" },
  { id: "manwe", tiers: [1, 6, 12], iconName: "thumbs-up" },
  { id: "melkor", tiers: [1, 6, 12], iconName: "thumbs-down" },
  { id: "trivium", tiers: [1, 3, 6], iconName: "layers" },
  { id: "quadrivium", tiers: [1, 3, 6], iconName: "box" },
  { id: "dagor-dagorath", tiers: [1, 3, 6], iconName: "infinity" },
];

// ==========================
// BANCO DE DADOS DA HOME (NOVO)
// ==========================
const homeDatabase = {
  highlights: [
    {
      id: "m1",
      type: "filme",
      title: "Duna: Parte Dois",
      year: 2024,
      score: 9.2,
    },
    {
      id: "g1",
      type: "jogo",
      title: "Baldur's Gate 3",
      year: 2023,
      score: 9.7,
    },
    {
      id: "b1",
      type: "livro",
      title: "O Nome do Vento",
      year: 2007,
      score: 9.3,
    },
    {
      id: "a1",
      type: "album",
      title: "To Pimp a Butterfly",
      year: 2015,
      score: 9.6,
    },
    { id: "m5", type: "filme", title: "Oppenheimer", year: 2023, score: 9.0 },
    { id: "g2", type: "jogo", title: "Elden Ring", year: 2022, score: 9.5 },
    { id: "b3", type: "livro", title: "1984", year: 1949, score: 9.2 },
    { id: "a3", type: "album", title: "Abbey Road", year: 1969, score: 9.4 },
  ],
  communityReviews: [
    {
      id: "cr1",
      type: "filme",
      date: "2 min atrás",
      score: 9.5,
      title: "Oppenheimer",
      tags: ["tag.biografia", "tag.drama"],
      text: "A tensão construída apenas com diálogos é algo que só Nolan consegue fazer. Cillian Murphy entrega a atuação da vida.",
      user: { name: "Marina", handle: "@maris", avatar: "M" },
    },
    {
      id: "cr2",
      type: "livro",
      date: "15 min atrás",
      score: 8.0,
      title: "Torto Arado",
      tags: ["tag.drama", "tag.historia"],
      text: "Uma narrativa potente sobre ancestralidade e terra. O realismo mágico é sutil, mas golpeia com força.",
      user: { name: "Lucas", handle: "@lucas_l", avatar: "L" },
    },
    {
      id: "cr3",
      type: "jogo",
      date: "1 hora atrás",
      score: 10,
      title: "Elden Ring",
      tags: ["tag.rpg", "tag.fantasia"],
      text: "O mundo aberto definitivo. A sensação de descoberta é genuína, sem marcadores segurando sua mão a cada passo.",
      user: { name: "Dante", handle: "@dante_g", avatar: "D" },
    },
    {
      id: "cr4",
      type: "album",
      date: "3 horas atrás",
      score: 9.0,
      title: "Renaissance",
      tags: ["tag.pop", "tag.dance"],
      text: "Beyoncé celebra a cultura ballroom com uma produção impecável. As transições entre as faixas são arte pura.",
      user: { name: "Gui", handle: "@gui_music", avatar: "G" },
    },
  ],
  friendsActivity: [
    {
      id: "f1",
      who: "Marina",
      handle: "@maris",
      type: "filme",
      item: "Oppenheimer",
      score: 9.0,
      when: "há 2 h",
      note: "Roteiro e montagem impecáveis. O som cria uma tensão contínua.",
    },
    {
      id: "f2",
      who: "Diego",
      handle: "@dgs",
      type: "album",
      item: "Random Access Memories",
      score: 9.0,
      when: "ontem",
      note: "Produção cristalina com arranjos que respiram.",
    },
    {
      id: "f3",
      who: "Lívia",
      handle: "@livz",
      type: "jogo",
      item: "Hades",
      score: 9.2,
      when: "há 3 dias",
      note: "Loop perfeito: a narrativa cresce a cada run sem cansar.",
    },
    {
      id: "f4",
      who: "Caio",
      handle: "@caiod",
      type: "livro",
      item: "Ensaio Sobre a Cegueira",
      score: 9.4,
      when: "há 1 semana",
      note: "Assustador de tão atual.",
    },
    {
      id: "f5",
      who: "Júlia",
      handle: "@ju",
      type: "filme",
      item: "Duna: Parte Dois",
      score: 9.1,
      when: "há 1 h",
      note: "Visual imersivo e trilha absurda.",
    },
    {
      id: "f6",
      who: "Rafa",
      handle: "@raf",
      type: "jogo",
      item: "Elden Ring",
      score: 9.7,
      when: "há 4 h",
      note: "Mundo vivo e desafiador.",
    },
    {
      id: "f7",
      who: "Nina",
      handle: "@nina",
      type: "album",
      item: "Anima",
      score: 8.6,
      when: "hoje",
      note: "Climas eletrônicos hipnóticos.",
    },
    {
      id: "f8",
      who: "Tom",
      handle: "@tom",
      type: "filme",
      item: "La La Land",
      score: 8.2,
      when: "há 9 h",
      note: "Encantador e melancólico.",
    },
    {
      id: "f9",
      who: "Bia",
      handle: "@bia",
      type: "livro",
      item: "1984",
      score: 9.5,
      when: "há 2 dias",
      note: "Releitura necessária. Cada vez mais atual.",
    },
    {
      id: "f10",
      who: "Pedro",
      handle: "@pedro",
      type: "jogo",
      item: "God of War",
      score: 9.8,
      when: "há 5 h",
      note: "Narrativa paternal incrível e combate visceral.",
    },
    {
      id: "f11",
      who: "Sofia",
      handle: "@sof",
      type: "filme",
      item: "Interestelar",
      score: 10,
      when: "ontem",
      note: "Chorei tudo de novo. A trilha do Hans Zimmer é outro nível.",
    },
    {
      id: "f12",
      who: "Iuri",
      handle: "@iuri",
      type: "album",
      item: "Dark Side of the Moon",
      score: 9.9,
      when: "há 3 dias",
      note: "O álbum perfeito para ouvir no escuro.",
    },
    {
      id: "f13",
      who: "Ana",
      handle: "@ana",
      type: "livro",
      item: "Dom Casmurro",
      score: 9.0,
      when: "há 1 semana",
      note: "Machado é gênio. A dúvida permanece.",
    },
    {
      id: "f14",
      who: "Leo",
      handle: "@leo",
      type: "jogo",
      item: "Cyberpunk 2077",
      score: 8.5,
      when: "hoje",
      note: "Night City é linda, mas ainda tem seus bugs.",
    },
    {
      id: "f15",
      who: "Carla",
      handle: "@carla",
      type: "filme",
      item: "Barbie",
      score: 8.0,
      when: "há 6 h",
      note: "Divertido e com uma crítica social bem colocada.",
    },
    {
      id: "f16",
      who: "Bruno",
      handle: "@bruno",
      type: "album",
      item: "Folklore",
      score: 9.2,
      when: "ontem",
      note: "Taylor Swift contando histórias como ninguém.",
    },
    {
      id: "f17",
      who: "Gabi",
      handle: "@gabi",
      type: "livro",
      item: "Harry Potter 1",
      score: 8.5,
      when: "há 2 dias",
      note: "Nostalgia pura relendo isso.",
    },
    {
      id: "f18",
      who: "Vitor",
      handle: "@vitor",
      type: "jogo",
      item: "Hollow Knight",
      score: 9.6,
      when: "há 4 dias",
      note: "Atmosfera e design de som impecáveis.",
    },
  ],
};

// ==========================
// BANCO DE DADOS DE CLUBES (ATUALIZADO COM CONTEÚDO DE TÓPICOS)
// ==========================
const clubsDatabase = [
  {
    id: "c1",
    name: "Clube Sci-Fi",
    description: "Explorando o desconhecido, de Asimov a Cyberpunk.",
    ownerHandle: "alexl",
    membersCount: 142,
    nextMeeting: "27/10 • 20:00",
    tags: ["tag.scifi", "tag.futurismo", "tag.tecnologia"],
    coverGradient: "from-indigo-500 via-purple-500 to-pink-500",
    rules:
      "1. Respeito acima de tudo.\n2. Spoilers apenas com aviso ou na thread específica.\n3. Votações ficam abertas por 48h.",
    activeWorks: [
      { id: "duna-livro", type: "livro", title: "Duna" },
      { id: "m1", type: "filme", title: "Duna: Parte Dois" },
      { id: "g_mass_effect", type: "jogo", title: "Mass Effect Legendary" },
      { id: "a_blade_runner_ost", type: "album", title: "Blade Runner Blues" },
    ],
    topics: [
      {
        id: "t1",
        title: "Boas-vindas e Apresentações",
        author: "alexl",
        isPinned: true,
        context: "general",
        date: "20 Out 2025",
        body: "Olá a todos! Sejam bem-vindos ao Clube Sci-Fi. Use este espaço para se apresentar, dizer qual sua obra de ficção científica favorita e o que espera das nossas leituras.\n\nEu começo: Sou o Alex, adoro Philip K. Dick e espero que a gente consiga ler algo de Ursula K. Le Guin esse ano.",
        replies: [
          {
            id: "r1",
            author: "maris",
            text: "Oi gente! Sou a Marina. Minha obra favorita é Duna (óbvio).",
            date: "20 Out 2025",
          },
          {
            id: "r2",
            author: "joao",
            text: "E aí pessoal. Sou o João. Gosto muito de Cyberpunk.",
            date: "21 Out 2025",
          },
        ],
      },
      {
        id: "t2",
        title: "Discussão: Capítulos 1-5",
        author: "alexl",
        isPinned: false,
        context: "duna-livro",
        date: "22 Out 2025",
        body: "Vamos começar a discussão oficial de Duna! O que vocês acharam da introdução do Paul e do teste do Gom Jabbar?\n\nAchei a tensão da cena incrível, mesmo já tendo visto o filme.",
        replies: [
          {
            id: "r3",
            author: "maris",
            text: "A descrição da dor na mão dele é muito vívida. Herbert escreve muito bem.",
            date: "22 Out 2025",
          },
          {
            id: "r4",
            author: "bia",
            text: "Eu fiquei com pena dele, mas entendo a necessidade do teste para as Bene Gesserit.",
            date: "23 Out 2025",
          },
        ],
      },
      {
        id: "t3",
        title: "O filme fez justiça ao livro?",
        author: "maris",
        isPinned: false,
        context: "m1",
        date: "25 Out 2025",
        body: "Acabei de rever a Parte Dois. Visualmente é impecável, mas senti falta de alguns diálogos internos do livro. O que vocês acham? A mudança na Chani foi boa ou ruim?",
        replies: [
          {
            id: "r5",
            author: "lucas",
            text: "Acho que a mudança na Chani deu mais agência pra ela. No livro ela é meio passiva no final.",
            date: "25 Out 2025",
          },
        ],
      },
    ],
    members: [
      { name: "Alex Lima", handle: "@alexl", role: "owner", avatar: "A" },
      { name: "Marina Silva", handle: "@maris", role: "mod", avatar: "M" },
      { name: "João Silva", handle: "@joao", role: "member", avatar: "J" },
      { name: "Ana Clara", handle: "@anac", role: "member", avatar: "A" },
      { name: "Lucas P.", handle: "@lucas", role: "member", avatar: "L" },
      { name: "Beatriz", handle: "@bia", role: "member", avatar: "B" },
    ],
  },
  // ... MANTENHA OS OUTROS CLUBES (c2 a c8) IGUAIS, APENAS ADICIONANDO CAMPOS VAZIOS SE NECESSÁRIO
  {
    id: "c2",
    name: "Terror à Meia-Noite",
    description: "Dissecando o horror psicológico e slashers clássicos.",
    ownerHandle: "maris",
    membersCount: 89,
    nextMeeting: "31/10 • 23:59",
    tags: ["tag.horror", "tag.cinema", "tag.suspense"],
    coverGradient: "from-red-900 via-red-600 to-orange-900",
    rules: "Proibido gore real. Apenas ficção.",
    activeWorks: [{ id: "m_hereditario", type: "filme", title: "Hereditário" }],
    topics: [],
    members: [
      { name: "Marina Silva", handle: "@maris", role: "owner", avatar: "M" },
      { name: "Alex Lima", handle: "@alexl", role: "member", avatar: "A" },
    ],
  },
  {
    id: "c3",
    name: "Indie Games Corner",
    description:
      "Descobrindo joias escondidas e apoiando desenvolvedores independentes.",
    ownerHandle: "maris",
    membersCount: 215,
    nextMeeting: "10/11 • 18:00",
    tags: ["tag.indie", "tag.jogos", "tag.art"],
    coverGradient: "from-emerald-500 via-teal-500 to-cyan-500",
    rules: "Sem gatekeeping. Todo jogo é jogo.",
    activeWorks: [
      { id: "g_hollow", type: "jogo", title: "Hollow Knight" },
      { id: "g_celeste", type: "jogo", title: "Celeste" },
      { id: "a_celeste_ost", type: "album", title: "Celeste OST" },
    ],
    topics: [],
    members: [],
  },
  {
    id: "c4",
    name: "Sociedade do Anel",
    description: "Para os amantes da alta fantasia e construção de mundos.",
    ownerHandle: "gandalf_fake",
    membersCount: 350,
    nextMeeting: "05/11 • 19:00",
    tags: ["tag.fantasia", "tag.rpg", "tag.literatura"],
    coverGradient: "from-amber-500 via-yellow-600 to-orange-500",
    rules: "Fale amigo e entre.",
    activeWorks: [
      { id: "b_silmarillion", type: "livro", title: "O Silmarillion" },
    ],
    topics: [],
    members: [],
  },
  {
    id: "c5",
    name: "Cinephiles Noir",
    description: "Sombras, detetives e a estética do cinema preto e branco.",
    ownerHandle: "bogart",
    membersCount: 45,
    nextMeeting: "15/11 • 21:00",
    tags: ["tag.noir", "tag.cinema", "tag.classico"],
    coverGradient: "from-gray-900 via-gray-700 to-gray-500",
    rules: "Preto e branco é lei.",
    activeWorks: [{ id: "m_maltese", type: "filme", title: "O Falcão Maltês" }],
    topics: [],
    members: [],
  },
  {
    id: "c6",
    name: "Vinil & Café",
    description: "Apreciação de álbuns completos, do Jazz ao Rock Progressivo.",
    ownerHandle: "alexl",
    membersCount: 120,
    nextMeeting: "Domingo • 10:00",
    tags: ["tag.musica", "tag.jazz", "tag.rock"],
    coverGradient: "from-amber-900 via-yellow-900 to-brown-800",
    rules: "Escute o álbum inteiro antes de opinar.",
    activeWorks: [{ id: "a_kindofblue", type: "album", title: "Kind of Blue" }],
    topics: [],
    members: [],
  },
  {
    id: "c7",
    name: "Literatura Latino-Americana",
    description: "Realismo mágico e as vozes do nosso continente.",
    ownerHandle: "gabo",
    membersCount: 78,
    nextMeeting: "02/11 • 19:30",
    tags: ["tag.literatura", "tag.cultura", "tag.historia"],
    coverGradient: "from-green-600 via-yellow-500 to-blue-600",
    rules: "Português ou Espanhol apenas.",
    activeWorks: [
      { id: "b_cem_anos", type: "livro", title: "Cem Anos de Solidão" },
    ],
    topics: [],
    members: [],
  },
  {
    id: "c8",
    name: "Cyberpunk Netrunners",
    description:
      "High Tech, Low Life. Discussões sobre distopias tecnológicas.",
    ownerHandle: "v_cyber",
    membersCount: 156,
    nextMeeting: "Sexta • 22:00",
    tags: ["tag.scifi", "tag.ciberpunk", "tag.tecnologia"],
    coverGradient: "from-pink-600 via-purple-600 to-cyan-400",
    rules: "Não hackear o grupo.",
    activeWorks: [
      { id: "g_cp2077", type: "jogo", title: "Cyberpunk 2077" },
      { id: "m_bladerunner", type: "filme", title: "Blade Runner" },
    ],
    topics: [],
    members: [],
  },
];

// ==========================
// SIMULAÇÃO DE BANCO DE DADOS (MOCK DB)
// ==========================

// --- DADOS DE MÍDIA DETALHADOS ---
const mediaDatabase = {
  m1: {
    id: "m1",
    type: "filme",
    title: {
      PT: "Duna: Parte Dois",
      EN: "Dune: Part Two",
      ES: "Dune: Parte Dos",
    },
    posterUrl:
      "https://image.tmdb.org/t/p/w500/1m02V5s5z03iV2lX3a1iV77F22i.jpg",
    backdropUrl:
      "https://image.tmdb.org/t/p/w1280/xOMo8BRK7PfcJv9JCnx7s5hj0PX.jpg",
    sinopse: {
      PT: "Paul Atreides se une a Chani e aos Fremen em uma guerra de vingança contra os conspiradores que destruíram sua família. Diante de uma escolha entre o amor de sua vida e o destino do universo conhecido, ele se esforça para evitar um futuro terrível que só ele pode prever.",
      EN: "Paul Atreides unites with Chani and the Fremen on a warpath of revenge against the conspirators who destroyed his family. Facing a choice between the love of his life and the fate of the known universe, he endeavors to prevent a terrible future only he can foresee.",
      ES: "Paul Atreides se une a Chani y a los Fremen mientras emprende un camino de venganza contra los conspiradores que destruyeron a su familia. Al enfrentarse a una elección entre el amor de su vida y el destino del universo, se esfuerça por evitar un futuro terrible que solo él pode prever.",
    },
    details: {
      Diretor: "Denis Villeneuve",
      Duração: "2h 46min",
      Gênero: ["tag.scifi", "tag.aventura"],
      Ano: "2024",
      País: {
        PT: "Estados Unidos",
        EN: "United States",
        ES: "Estados Unidos",
      },
    },
    communityAverage: 9.18,
    communityReviews: [
      {
        id: "cr1",
        user: { name: "Júlia", handle: "@ju", avatar: "J" },
        score: 9.1,
        text: "Visual imersivo e trilha absurda...",
      },
    ],
  },
  "duna-livro": {
    id: "duna-livro",
    type: "livro",
    title: {
      PT: "Duna",
      EN: "Dune",
      ES: "Dune",
    },
    posterUrl:
      "https://images-na.ssl-images-amazon.com/images/S/compressed.photo.goodreads.com/books/1555447414l/44767458.jpg",
    backdropUrl: "https://images.alphacoders.com/133/1333069.jpeg",
    sinopse: {
      PT: "Uma mistura de aventura e misticismo, ecologia e política, este romance premiado deu origem a um dos universos mais épicos da ficção científica.",
      EN: "A blend of adventure and mysticism, ecology and politics, this award-winning novel gave rise to one of the most epic universes in science fiction.",
      ES: "Una mezcla de aventura y misticismo, ecología y política, esta novela galardonada dio origen a uno de los universos más épicos de la ciencia ficción.",
    },
    details: {
      Autor: "Frank Herbert",
      Páginas: "688",
      Gênero: ["tag.scifi", "tag.fantasia", "tag.epica"],
      Ano: "1965",
      País: {
        PT: "Estados Unidos",
        EN: "United States",
        ES: "Estados Unidos",
      },
    },
  },
  "duna-1984": {
    id: "duna-1984",
    type: "filme",
    title: {
      PT: "Duna",
      EN: "Dune",
      ES: "Dune",
    },
    posterUrl:
      "https://image.tmdb.org/t/p/w500/a3nDwAnKAl0jsSmsGaen09F2s6G.jpg",
    backdropUrl:
      "https://media.wired.com/photos/5f97371a536952d793623916/master/pass/Culture_Dune_Lynch-10659730-Edit.jpg",
    sinopse: {
      PT: "Em um futuro distante, clãs nobres rivais lutam pelo controle do desértico planeta Arrakis, a única fonte da valiosa especiaria Melange. A família Atreides aceita a administração do planeta, mas é traída por seus inimigos, os Harkonnens.",
      EN: "In the distant future, rival noble clans fight for control of the desert planet Arrakis, the only source of the valuable spice Melange. The Atreides family accepts stewardship of the planet, but is betrayed by their enemies, the Harkonnens.",
      ES: "En un futuro lejano, clanes nobles rivales luchan por el control del planeta desértico Arrakis, la única fuente de la valiosa especia Melange. La familia Atreides acepta la administración del planeta, pero es traicionada por sus enemigos, los Harkonnen.",
    },
    details: {
      Diretor: "David Lynch",
      Duração: "2h 17min",
      Gênero: ["tag.scifi", "tag.aventura", "tag.acao"],
      Ano: "1984",
      País: {
        PT: "Estados Unidos",
        EN: "United States",
        ES: "Estados Unidos",
      },
    },
  },
  "portrait-2019": {
    id: "portrait-2019",
    type: "filme",
    aliases: ["Portrait de la jeune fille en feu"],
    title: {
      PT: "Retrato de uma Jovem em Chamas",
      EN: "Portrait of a Lady on Fire",
      ES: "Retrato de una mujer en llamas",
    },
    posterUrl:
      "https://image.tmdb.org/t/p/w500/s2C0QeCcrT1BwE7cW3H1a3q3uY1.jpg",
    backdropUrl:
      "https://image.tmdb.org/t/p/w1280/g6PfZVLtYCaPiof5G3PEsIGV2cf.jpg",
    sinopse: {
      PT: "França, 1770. Marianne, uma pintora, é contratada para pintar o retrato de casamento de Héloïse, uma jovem que acaba de deixar o convento. Héloïse resiste ao seu destino, recusando-se a posar, então Marianne deve pintá-la em segredo.",
      EN: "France, 1770. Marianne, a painter, is commissioned to paint the wedding portrait of Héloïse, a young woman who has just left the convent. Héloïse resists her fate by refusing to pose, so Marianne must paint her in secret.",
      ES: "Francia, 1770. Marianne, una pintora, recibe el encargo de pintar el retrato de bodas de Héloïse, una joven que acaba de salir del convento. Héloïse se resiste a su destino negándose a posar, por lo que Marianne debe pintarla en secreto.",
    },
    details: {
      Diretor: "Céline Sciamma",
      Duração: "2h 2min",
      Gênero: ["tag.drama", "tag.romance", "tag.historia"],
      Ano: "2019",
      País: {
        PT: "França",
        EN: "France",
        ES: "Francia",
      },
    },
  },
  m2: {
    id: "m2",
    type: "filme",
    title: { PT: "Parasita" },
    posterUrl:
      "https://image.tmdb.org/t/p/w500/7IiTTgloJzvGI1TAYymCfbfl3vT.jpg",
    backdropUrl:
      "https://image.tmdb.org/t/p/w1280/TU9NIjwzjoKPwQHoHshkFcQUCG.jpg",
    sinopse: {
      PT: "A história de uma família pobre que se infiltra na vida de uma família rica.",
    },
    details: {
      Ano: "2019",
      Gênero: ["tag.drama", "tag.thriller", "tag.comedia"],
    },
  },
  m4: {
    id: "m4",
    type: "filme",
    title: { PT: "Blade Runner 2049" },
    posterUrl:
      "https://image.tmdb.org/t/p/w500/gajva2L0rPYkEWjzgFlBXCAVBE5.jpg",
    backdropUrl:
      "https://image.tmdb.org/t/p/w1280/sAtomqDVhNDQBc3QJl3RF6hlhGq.jpg",
    sinopse: {
      PT: "K, um novo Blade Runner, descobre um segredo há muito tempo enterrado.",
    },
    details: { Ano: "2017", Gênero: ["tag.scifi", "tag.noir", "tag.distopia"] },
  },
  m5: {
    id: "m5",
    type: "filme",
    title: { PT: "Oppenheimer" },
    posterUrl:
      "https://image.tmdb.org/t/p/w500/8Gxv8gSFCU0XGDykEGv7zR1n2ua.jpg",
    backdropUrl:
      "https://image.tmdb.org/t/p/w1280/fm6KqXpk3M2HVveHwvkHIeHYDI2.jpg",
    sinopse: {
      PT: "A história do cientista americano J. Robert Oppenheimer e seu papel no desenvolvimento da bomba atômica.",
    },
    details: {
      Ano: "2023",
      Gênero: ["tag.biografia", "tag.drama", "tag.historia"],
    },
  },
  g1: {
    id: "g1",
    type: "jogo",
    title: { PT: "Hades" },
    posterUrl:
      "https://images.igdb.com/igdb/image/upload/t_cover_big/co2mvt.jpg",
    sinopse: {
      PT: "Desafie o deus dos mortos enquanto você batalha para sair do Submundo.",
    },
    details: {
      Ano: "2020",
      Gênero: ["tag.roguelike", "tag.mitologia", "tag.indie"],
    },
  },
  g2: {
    id: "g2",
    type: "jogo",
    title: { PT: "Baldur's Gate 3" },
    posterUrl:
      "https://images.igdb.com/igdb/image/upload/t_cover_big/co670h.jpg",
    sinopse: { PT: "Reúna seu grupo e retorne aos Reinos Esquecidos." },
    details: {
      Ano: "2023",
      Gênero: ["tag.rpg", "tag.fantasia", "tag.estrategia"],
    },
  },
  b1: {
    id: "b1",
    type: "livro",
    title: { PT: "1984" },
    posterUrl:
      "https://images-na.ssl-images-amazon.com/images/I/91SZSW8qSsL.jpg",
    sinopse: {
      PT: "Em 1984, Winston Smith vive em uma sociedade totalitária sob o olhar atento do Grande Irmão.",
    },
    details: {
      Ano: "1949",
      Gênero: ["tag.distopia", "tag.scifi", "tag.politica"],
    },
  },
  b2: {
    id: "b2",
    type: "livro",
    title: { PT: "O Nome do Vento" },
    posterUrl:
      "https://images-na.ssl-images-amazon.com/images/I/91M9xPIf10L.jpg",
    sinopse: {
      PT: "A história de Kvothe, um jovem dotado de magia, em sua busca por vingança.",
    },
    details: { Ano: "2007", Gênero: ["tag.fantasia", "tag.epica"] },
  },
  a2: {
    id: "a2",
    type: "album",
    title: { PT: "To Pimp a Butterfly" },
    posterUrl:
      "https://upload.wikimedia.org/wikipedia/en/f/f6/Kendrick_Lamar_-_To_Pimp_a_Butterfly.png",
    sinopse: {
      PT: "O terceiro álbum de estúdio do rapper americano Kendrick Lamar.",
    },
    details: {
      Ano: "2015",
      Gênero: ["tag.hiphop", "tag.jazz", "tag.funk", "tag.criticasocial"],
    },
  },
};

// --- DADOS DE USUÁRIO (MARINA) ---
const marisData = {
  profile: {
    name: "Marina Silva",
    handle: "@maris",
    bio: "Viciada em listas, sci‑fi e cafés gelados. Avalio tudo que assisto/leio/jogo para lembrar por que gostei.",
    avatarUrl: "https://i.pravatar.cc/200?img=5",
  },
  badges: [
    { id: "the-one", progress: 60 },
    { id: "narya", progress: 5 },
    { id: "vilya", progress: 26 },
    { id: "nenya", progress: 12 },
    { id: "zeitgeist", progress: 8 },
    { id: "khazad-dum", progress: 2 },
  ],
  favorites: [
    {
      id: "g2",
      type: "jogo",
      title: "Baldur's Gate 3",
      year: 2023,
      score: 9.7,
      tags: ["tag.rpg", "tag.fantasia", "tag.estrategia"],
    },
    {
      id: "a2",
      type: "album",
      title: "To Pimp a Butterfly",
      year: 2015,
      score: 9.6,
      tags: ["tag.hiphop", "tag.jazz", "tag.funk", "tag.criticasocial"],
    },
    {
      id: "b1",
      type: "livro",
      title: "1984 (George Orwell)",
      year: 1949,
      score: 9.25,
      tags: ["tag.distopia", "tag.scifi", "tag.politica"],
    },
    {
      id: "m1",
      type: "filme",
      title: {
        PT: "Duna: Parte Dois",
        EN: "Dune: Part Two",
        ES: "Dune: Parte Dos",
      },
      year: 2024,
      score: 9.2,
      tags: ["tag.scifi", "tag.aventura"],
    },
    {
      id: "g1",
      type: "jogo",
      title: "Hades",
      year: 2020,
      score: 9.1,
      tags: ["tag.roguelike", "tag.mitologia", "tag.indie"],
    },
    {
      id: "m2",
      type: "filme",
      title: "Parasita",
      year: 2019,
      score: 9.0,
      tags: ["tag.drama", "tag.thriller", "tag.comedia"],
    },
    {
      id: "m4",
      type: "filme",
      title: "Blade Runner 2049",
      year: 2017,
      score: 8.9,
      tags: ["tag.scifi", "tag.noir", "tag.distopia"],
    },
    {
      id: "b2",
      type: "livro",
      title: "O Nome do Vento",
      year: 2007,
      score: 8.7,
      tags: ["tag.fantasia", "tag.epica"],
    },
  ],
  reviews: [
    {
      id: "r1",
      type: "filme",
      date: "12 Ago 2025",
      score: 9.25,
      title: "Duna: Parte Dois",
      tags: ["tag.scifi", "tag.aventura"],
      text: "Villeneuve mantém a grandiosidade sem perder os personagens de vista...",
    },
    {
      id: "r2",
      type: "livro",
      date: "08 Ago 2025",
      score: 9.0,
      title: "1984 (George Orwell)",
      tags: ["tag.distopia", "tag.politica"],
      text: "Revisita dolorosa e necessária...",
    },
    {
      id: "r3",
      type: "jogo",
      date: "03 Ago 2025",
      score: 9.5,
      title: "Baldur's Gate 3",
      tags: ["tag.rpg", "tag.fantasia"],
      text: "Liberdade real sem quebrar a narrativa...",
    },
    {
      id: "r4",
      type: "album",
      date: "26 Jul 2025",
      score: 8.75,
      title: "Random Access Memories",
      tags: ["tag.eletronica", "tag.disco"],
      text: "Produção analógica brilhante com espaço para respirar...",
    },
    {
      id: "r5",
      type: "filme",
      date: "20 Jul 2025",
      score: 9.0,
      title: "Oppenheimer",
      tags: ["tag.biografia", "tag.drama"],
      text: "Nolan de um jeito que nunca vimos: denso, dialógico e tenso...",
    },
    {
      id: "r6",
      type: "jogo",
      date: "15 Jul 2025",
      score: 9.2,
      title: "Hades",
      tags: ["tag.roguelike", "tag.mitologia"],
      text: "Combate viciante, com cada tentativa de fuga revelando mais da história...",
    },
    {
      id: "r7",
      type: "livro",
      date: "01 Jul 2025",
      score: 8.8,
      title: "O Nome do Vento",
      tags: ["tag.fantasia", "tag.epica"],
      text: "Construção de mundo e sistema de magia fascinantes...",
    },
    {
      id: "r8",
      type: "filme",
      date: "25 Jun 2025",
      score: 9.0,
      title: "Blade Runner 2049",
      tags: ["tag.scifi", "tag.noir"],
      text: "Visualmente deslumbrante e atmosférico...",
    },
  ],
  collections: [],
};

// --- DADOS DE USUÁRIO (ALEX) ---
const alexlData = {
  profile: {
    name: "Alex Lima",
    handle: "@alexl",
    bio: "Explorando mundos de fantasia e futuros distópicos. Foco em RPGs, cinema de autor e álbuns conceituais.",
    avatarUrl: "https://i.pravatar.cc/200?img=12",
  },
  badges: [
    { id: "the-one", progress: 14 },
    { id: "narya", progress: 55 },
    { id: "nenya", progress: 24 },
    { id: "wood-between-worlds", progress: 7 },
    { id: "zeitgeist", progress: 10 },
  ],
  favorites: [
    {
      id: "m1",
      type: "filme",
      title: {
        PT: "Duna: Parte Dois",
        EN: "Dune: Part Two",
        ES: "Dune: Parte Dos",
      },
      year: 2024,
      score: 9.2,
      tags: ["tag.scifi", "tag.aventura"],
    },
    {
      id: "al_fav1",
      type: "jogo",
      title: "The Witcher 3: Wild Hunt",
      year: 2015,
      score: 9.8,
      tags: ["tag.rpg", "tag.fantasia", "tag.epica"],
    },
    {
      id: "al_fav2",
      type: "filme",
      title: "Interestelar",
      year: 2014,
      score: 9.5,
      tags: ["tag.scifi", "tag.drama"],
    },
    {
      id: "al_fav3",
      type: "livro",
      title: "O Senhor dos Anéis",
      year: 1954,
      score: 10,
      tags: ["tag.fantasia", "tag.epica", "tag.aventura"],
    },
    {
      id: "al_fav4",
      type: "album",
      title: "The Dark Side of the Moon",
      year: 1973,
      score: 9.9,
      tags: ["tag.rock", "tag.conceitual"],
    },
    {
      id: "al_fav5",
      type: "jogo",
      title: "Cyberpunk 2077",
      year: 2020,
      score: 9.0,
      tags: ["tag.rpg", "tag.scifi", "tag.distopia"],
    },
    {
      id: "al_fav6",
      type: "filme",
      title: "Blade Runner",
      year: 1982,
      score: 9.1,
      tags: ["tag.scifi", "tag.noir"],
    },
    {
      id: "al_fav7",
      type: "livro",
      title: "Neuromancer",
      year: 1984,
      score: 9.3,
      tags: ["tag.ciberpunk"],
    },
    {
      id: "al_fav8",
      type: "album",
      title: "OK Computer",
      year: 1997,
      score: 9.7,
      tags: ["tag.rock", "tag.alternativo"],
    },
  ],
  reviews: [
    {
      id: "al_rev1",
      type: "jogo",
      date: "15 Out 2025",
      score: 9.8,
      title: "The Witcher 3",
      tags: ["tag.rpg", "tag.fantasia"],
      text: "Uma obra-prima da narrativa em jogos. Cada contrato de bruxo conta uma história.",
    },
    {
      id: "al_rev2",
      type: "filme",
      date: "10 Out 2025",
      score: 9.5,
      title: "Interestelar",
      tags: ["tag.scifi"],
      text: "Uma jornada emocional e visualmente espetacular. A trilha sonora de Hans Zimmer é icônica.",
    },
    {
      id: "al_rev3",
      type: "livro",
      date: "05 Out 2025",
      score: 9.3,
      title: "O Senhor dos Anéis",
      tags: ["tag.fantasia", "tag.epica"],
      text: "A base de toda a fantasia moderna. Uma leitura obrigatória que te transporta para outro mundo.",
    },
    {
      id: "al_rev4",
      type: "album",
      date: "01 Out 2025",
      score: 9.9,
      title: "The Dark Side of the Moon",
      tags: ["tag.rock", "tag.conceitual"],
      text: "Um marco na história da música. Atmosférico, filosófico e sonoramente perfeito.",
    },
    {
      id: "al_rev5",
      type: "jogo",
      date: "28 Set 2025",
      score: 9.0,
      title: "Cyberpunk 2077",
      tags: ["tag.rpg", "tag.scifi"],
      text: "Apesar de um lançamento turbulento, a história e o mundo de Night City são cativantes. Um RPG profundo.",
    },
    {
      id: "al_rev6",
      type: "filme",
      date: "20 Set 2025",
      score: 9.1,
      title: "Blade Runner",
      tags: ["tag.scifi", "tag.noir"],
      text: "Clássico atemporal que define o gênero cyberpunk. A atmosfera e as questões filosóficas são ainda relevantes.",
    },
    {
      id: "al_rev7",
      type: "livro",
      date: "15 Set 2025",
      score: 9.3,
      title: "Neuromancer",
      tags: ["tag.ciberpunk"],
      text: "O livro que deu origem ao cyberpunk. Leitura densa mas recompensadora, um mergulho em um futuro tecnológico e sombrio.",
    },
    {
      id: "al_rev8",
      type: "album",
      date: "10 Set 2025",
      score: 9.7,
      title: "OK Computer",
      tags: ["tag.rock", "tag.alternativo"],
      text: "Radiohead no seu auge. Melancólico e visionário, um álbum que captura a ansiedade da era digital.",
    },
    {
      id: "al_rev9",
      type: "jogo",
      date: "05 Set 2025",
      score: 9.6,
      title: "God of War (2018)",
      tags: ["tag.aventura", "tag.mitologia"],
      text: "Uma reinvenção brilhante de Kratos. Combate visceral e uma história emocionante de pai e filho.",
    },
    {
      id: "al_rev10",
      type: "filme",
      date: "01 Set 2025",
      score: 9.0,
      title: "Arrival",
      tags: ["tag.scifi", "tag.drama"],
      text: "Um sci-fi inteligente e comovente sobre linguagem e tempo. Amy Adams entrega uma performance memorável.",
    },
  ],
  collections: [
    {
      id: "col1",
      title: "Cyberpunk Completo",
      description: "Uma imersão no gênero, do livro ao jogo.",
      items: [
        { id: "al_fav7", type: "livro", title: "Neuromancer" },
        { id: "al_fav6", type: "filme", title: "Blade Runner" },
        { id: "al_fav5", type: "jogo", title: "Cyberpunk 2077" },
      ],
    },
    {
      id: "col2",
      title: "Filmes para ver em 2025",
      description: "Minha lista de filmes para assistir este ano.",
      items: [{ id: "m5", type: "filme", title: "Oppenheimer" }],
    },
    {
      id: "col3",
      title: "Clássicos da Fantasia",
      description: "As obras que definiram o gênero.",
      items: [
        { id: "al_fav3", type: "livro", title: "O Senhor dos Anéis" },
        { id: "g2", type: "jogo", title: "Baldur's Gate 3" },
      ],
    },
  ],
};

// --- DADOS DE HOME ESTÁTICOS (Novos) ---
export const staticHomeDatabase = {
  highlights: [
    {
      id: "m1",
      type: "filme",
      title: "Duna: Parte Dois",
      year: 2024,
      score: 9.2,
    },
    {
      id: "g1",
      type: "jogo",
      title: "Baldur's Gate 3",
      year: 2023,
      score: 9.7,
    },
    {
      id: "b1",
      type: "livro",
      title: "O Nome do Vento",
      year: 2007,
      score: 9.3,
    },
    {
      id: "a1",
      type: "album",
      title: "To Pimp a Butterfly",
      year: 2015,
      score: 9.6,
    },
    { id: "m5", type: "filme", title: "Oppenheimer", year: 2023, score: 9.0 },
    { id: "g2", type: "jogo", title: "Elden Ring", year: 2022, score: 9.5 },
    { id: "b3", type: "livro", title: "1984", year: 1949, score: 9.2 },
    { id: "a3", type: "album", title: "Abbey Road", year: 1969, score: 9.4 },
  ],
  communityReviews: [
    {
      id: "cr1",
      type: "filme",
      date: "2 min atrás",
      score: 9.5,
      title: "Oppenheimer",
      tags: ["tag.biografia", "tag.drama"],
      text: "A tensão construída apenas com diálogos é algo que só Nolan consegue fazer. Cillian Murphy entrega a atuação da vida.",
      user: { name: "Marina", handle: "@maris", avatar: "M" },
    },
    {
      id: "cr2",
      type: "livro",
      date: "15 min atrás",
      score: 8.0,
      title: "Torto Arado",
      tags: ["tag.drama", "tag.historia"],
      text: "Uma narrativa potente sobre ancestralidade e terra. O realismo mágico é sutil, mas golpeia com força.",
      user: { name: "Lucas", handle: "@lucas_l", avatar: "L" },
    },
    {
      id: "cr3",
      type: "jogo",
      date: "1 hora atrás",
      score: 10,
      title: "Elden Ring",
      tags: ["tag.rpg", "tag.fantasia"],
      text: "O mundo aberto definitivo. A sensação de descoberta é genuína, sem marcadores segurando sua mão a cada passo.",
      user: { name: "Dante", handle: "@dante_g", avatar: "D" },
    },
    {
      id: "cr4",
      type: "album",
      date: "3 horas atrás",
      score: 9.0,
      title: "Renaissance",
      tags: ["tag.pop", "tag.dance"],
      text: "Beyoncé celebra a cultura ballroom com uma produção impecável. As transições entre as faixas são arte pura.",
      user: { name: "Gui", handle: "@gui_music", avatar: "G" },
    },
  ],
  friendsActivity: [
    {
      id: "f1",
      who: "Marina",
      handle: "@maris",
      type: "filme",
      item: "Oppenheimer",
      score: 9.0,
      when: "há 2 h",
      note: "Roteiro e montagem impecáveis. O som cria uma tensão contínua.",
    },
    {
      id: "f2",
      who: "Diego",
      handle: "@dgs",
      type: "album",
      item: "Random Access Memories",
      score: 9.0,
      when: "ontem",
      note: "Produção cristalina com arranjos que respiram.",
    },
    {
      id: "f3",
      who: "Lívia",
      handle: "@livz",
      type: "jogo",
      item: "Hades",
      score: 9.2,
      when: "há 3 dias",
      note: "Loop perfeito: a narrativa cresce a cada run sem cansar.",
    },
    {
      id: "f4",
      who: "Caio",
      handle: "@caiod",
      type: "livro",
      item: "Ensaio Sobre a Cegueira",
      score: 9.4,
      when: "há 1 semana",
      note: "Assustador de tão atual.",
    },
    {
      id: "f5",
      who: "Júlia",
      handle: "@ju",
      type: "filme",
      item: "Duna: Parte Dois",
      score: 9.1,
      when: "há 1 h",
      note: "Visual imersivo e trilha absurda.",
    },
    {
      id: "f6",
      who: "Rafa",
      handle: "@raf",
      type: "jogo",
      item: "Elden Ring",
      score: 9.7,
      when: "há 4 h",
      note: "Mundo vivo e desafiador.",
    },
    {
      id: "f7",
      who: "Nina",
      handle: "@nina",
      type: "album",
      item: "Anima",
      score: 8.6,
      when: "hoje",
      note: "Climas eletrônicos hipnóticos.",
    },
    {
      id: "f8",
      who: "Tom",
      handle: "@tom",
      type: "filme",
      item: "La La Land",
      score: 8.2,
      when: "há 9 h",
      note: "Encantador e melancólico.",
    },
    {
      id: "f9",
      who: "Bia",
      handle: "@bia",
      type: "livro",
      item: "1984",
      score: 9.5,
      when: "há 2 dias",
      note: "Releitura necessária. Cada vez mais atual.",
    },
    {
      id: "f10",
      who: "Pedro",
      handle: "@pedro",
      type: "jogo",
      item: "God of War",
      score: 9.8,
      when: "há 5 h",
      note: "Narrativa paternal incrível e combate visceral.",
    },
    {
      id: "f11",
      who: "Sofia",
      handle: "@sof",
      type: "filme",
      item: "Interestelar",
      score: 10,
      when: "ontem",
      note: "Chorei tudo de novo. A trilha do Hans Zimmer é outro nível.",
    },
    {
      id: "f12",
      who: "Iuri",
      handle: "@iuri",
      type: "album",
      item: "Dark Side of the Moon",
      score: 9.9,
      when: "há 3 dias",
      note: "O álbum perfeito para ouvir no escuro.",
    },
    {
      id: "f13",
      who: "Ana",
      handle: "@ana",
      type: "livro",
      item: "Dom Casmurro",
      score: 9.0,
      when: "há 1 semana",
      note: "Machado é gênio. A dúvida permanece.",
    },
    {
      id: "f14",
      who: "Leo",
      handle: "@leo",
      type: "jogo",
      item: "Cyberpunk 2077",
      score: 8.5,
      when: "hoje",
      note: "Night City é linda, mas ainda tem seus bugs.",
    },
    {
      id: "f15",
      who: "Carla",
      handle: "@carla",
      type: "filme",
      item: "Barbie",
      score: 8.0,
      when: "há 6 h",
      note: "Divertido e com uma crítica social bem colocada.",
    },
    {
      id: "f16",
      who: "Bruno",
      handle: "@bruno",
      type: "album",
      item: "Folklore",
      score: 9.2,
      when: "ontem",
      note: "Taylor Swift contando histórias como ninguém.",
    },
    {
      id: "f17",
      who: "Gabi",
      handle: "@gabi",
      type: "livro",
      item: "Harry Potter 1",
      score: 8.5,
      when: "há 2 dias",
      note: "Nostalgia pura relendo isso.",
    },
    {
      id: "f18",
      who: "Vitor",
      handle: "@vitor",
      type: "jogo",
      item: "Hollow Knight",
      score: 9.6,
      when: "há 4 dias",
      note: "Atmosfera e design de som impecáveis.",
    },
  ],
};

export const staticUserDatabase = { maris: marisData, alexl: alexlData };
export const staticMediaDatabase = mediaDatabase;
export const staticClubsDatabase = clubsDatabase;

function getUserData(handle) {
  const finalHandle = handle || "alexl";
  const userData = staticUserDatabase[finalHandle] || staticUserDatabase.alexl;
  return userData;
}

export function getMediaDetails(mediaId) {
  return staticMediaDatabase[mediaId];
}

export function useUserProfileData(handle) {
  // LENDO DO CONTEXTO: Agora inclui clubsDb
  const { db, clubsDb } = useUserDatabase();
  const finalHandle = handle || "alexl";
  const userData = db[finalHandle] || db.alexl;

  const dynamicTags = useMemo(() => {
    if (!userData) return [];
    const tagScores = new Map();
    const FAVORITE_WEIGHT = 4;
    const REVIEW_WEIGHT = 2;

    (userData.favorites || []).forEach((item) => {
      if (item.tags) {
        item.tags.forEach((tag) => {
          tagScores.set(tag, (tagScores.get(tag) || 0) + FAVORITE_WEIGHT);
        });
      }
    });

    (userData.reviews || []).forEach((item) => {
      if (item.tags) {
        item.tags.forEach((tag) => {
          tagScores.set(tag, (tagScores.get(tag) || 0) + REVIEW_WEIGHT);
        });
      }
    });

    const sortedTags = Array.from(tagScores.entries())
      .sort(([, scoreA], [, scoreB]) => scoreB - scoreA)
      .slice(0, 10)
      .map(([tag]) => tag);

    return sortedTags;
  }, [userData]);

  // Retorna os dados do usuário + a lista dinâmica de clubes (clubsDb) + dados da home
  return {
    ...userData,
    dynamicTags,
    clubs: clubsDb, // Clubes agora vêm do contexto (estado dinâmico)
    homeData: staticHomeDatabase, // Home continua estática por enquanto
  };
}
</file>

<file path="client/src/pages/AchievementsPage/AchievementsPage.jsx">
import React, { useState, useEffect } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { X } from "lucide-react";

import { cx } from "../../utils/formatters";
import { useAuth } from "../../contexts/AuthContext.jsx";
import {
  useUserProfileData,
  MASTER_ACHIEVEMENTS_LIST,
} from "../../hooks/useUserProfileData.js"; // Importando dados reais

import HeaderBar from "../../components/layout/HeaderBar/HeaderBar.jsx";
import BadgeCard from "../../components/user/BadgeCard/BadgeCard.jsx";

const COLORS = { bronze: "#cd7f32", silver: "#9ca3af", gold: "#eab308" };

const AchievementsPage = ({ theme, setTheme, lang, setLang, t }) => {
  const { handle } = useParams();
  const navigate = useNavigate();
  const { currentUser } = useAuth();

  // Busca os dados do usuário dono do perfil
  const { badges } = useUserProfileData(handle);

  const [selectedAchievement, setSelectedAchievement] = useState(null);

  // Lógica de Proteção
  const isOwner =
    currentUser &&
    handle &&
    currentUser.handle.toLowerCase() === handle.toLowerCase();

  useEffect(() => {
    if (!isOwner) {
      navigate(`/profile/${handle}`);
    }
  }, [handle, isOwner, navigate]);

  if (!isOwner) return null;

  // Transforma o array de badges do usuário em um objeto chave-valor para acesso rápido
  // Ex: { 'the-one': 14, 'narya': 55 }
  const userProgressMap = (badges || []).reduce((acc, badge) => {
    acc[badge.id] = badge.progress;
    return acc;
  }, {});

  const calculateProgress = (current, tiers) => {
    const [bronze, silver, gold] = tiers;
    let target = bronze;
    let percentage = 0;
    let barColor = COLORS.bronze;

    if (current < bronze) {
      target = bronze;
      percentage = (current / bronze) * 100;
      barColor = COLORS.bronze;
    } else if (current < silver) {
      target = silver;
      percentage = ((current - bronze) / (silver - bronze)) * 100;
      barColor = COLORS.silver;
    } else if (current < gold) {
      target = gold;
      percentage = ((current - silver) / (gold - silver)) * 100;
      barColor = COLORS.gold;
    } else {
      target = gold;
      percentage = 100;
      barColor = COLORS.gold;
    }
    return { percentage, target, barColor };
  };

  return (
    <div className={cx(theme === "dark" ? "dark" : "", "font-sans")}>
      <div className="min-h-screen bg-neutral-50 text-neutral-900 dark:bg-neutral-950 dark:text-neutral-100 transition-colors duration-300">
        <HeaderBar
          theme={theme}
          setTheme={setTheme}
          lang={lang}
          setLang={setLang}
          t={t}
        />

        <main className="max-w-7xl mx-auto px-4 pt-24 pb-16">
          <div className="mb-8">
            <h1 className="text-3xl font-bold mb-2 text-neutral-900 dark:text-neutral-100">
              {t("achievements.title")}
            </h1>
            <p className="text-neutral-500 dark:text-neutral-400">
              {t("achievements.subtitle")}
            </p>
          </div>

          <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6">
            {/* Mapeamos a lista MESTRA para exibir todos os slots possíveis */}
            {MASTER_ACHIEVEMENTS_LIST.map((achievement) => {
              const displayTitle = achievement.id
                .replace(/-/g, " ")
                .replace(/\b\w/g, (l) => l.toUpperCase());
              const enrichedAchievement = {
                ...achievement,
                title: displayTitle,
              };

              // Pegamos o progresso real do mapa
              const progress = userProgressMap[achievement.id] || 0;

              return (
                <BadgeCard
                  key={achievement.id}
                  achievement={enrichedAchievement}
                  currentProgress={progress}
                  onClick={() =>
                    setSelectedAchievement({ ...enrichedAchievement, progress })
                  }
                />
              );
            })}
          </div>

          {selectedAchievement && (
            <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm">
              <div className="bg-white dark:bg-neutral-900 border border-neutral-200 dark:border-neutral-800 rounded-2xl p-6 max-w-md w-full relative shadow-2xl animate-in fade-in zoom-in duration-200">
                <button
                  onClick={() => setSelectedAchievement(null)}
                  className="absolute top-4 right-4 text-neutral-400 hover:text-neutral-900 dark:hover:text-white transition-colors"
                >
                  <X size={24} />
                </button>
                <div className="flex flex-col items-center text-center">
                  <div className="mb-4 transform scale-125 pointer-events-none">
                    <BadgeCard
                      achievement={selectedAchievement}
                      currentProgress={selectedAchievement.progress}
                      onClick={() => {}}
                    />
                  </div>
                  <h2 className="text-2xl font-bold mb-2 text-neutral-900 dark:text-neutral-100">
                    {selectedAchievement.title}
                  </h2>
                  <p className="text-neutral-600 dark:text-neutral-400 mb-6 px-4">
                    {t(`achievement.desc.${selectedAchievement.id}`)}
                  </p>
                  {(() => {
                    const { percentage, target, barColor } = calculateProgress(
                      selectedAchievement.progress,
                      selectedAchievement.tiers,
                    );
                    return (
                      <div className="w-full bg-neutral-100 dark:bg-neutral-800 rounded-xl p-4 border border-neutral-200 dark:border-neutral-700">
                        <div className="flex justify-between items-end mb-2">
                          <span className="text-sm text-neutral-500 dark:text-neutral-400 uppercase font-bold tracking-wider">
                            {t("achievements.progress")}
                          </span>
                          <span
                            className="text-xl font-mono font-bold"
                            style={{ color: barColor }}
                          >
                            {selectedAchievement.progress}{" "}
                            <span className="text-neutral-400 text-sm">
                              / {target}
                            </span>
                          </span>
                        </div>
                        <div className="w-full h-4 bg-neutral-200 dark:bg-neutral-700 rounded-full overflow-hidden">
                          <div
                            className="h-full transition-all duration-500"
                            style={{
                              width: `${percentage}%`,
                              backgroundColor: barColor,
                            }}
                          />
                        </div>
                        <div className="mt-1 text-right">
                          <span className="text-xs text-neutral-500 dark:text-neutral-400">
                            {Math.round(percentage)}%
                          </span>
                        </div>
                      </div>
                    );
                  })()}
                </div>
              </div>
            </div>
          )}
        </main>
      </div>
    </div>
  );
};

export default AchievementsPage;
</file>

<file path="client/src/pages/ClubDetailsPage/ClubDetailsPage.jsx">
import React, { useState, useMemo, useRef, useEffect } from "react";
import { useParams, Link, useNavigate } from "react-router-dom";
import {
  Users,
  Calendar,
  BookOpen,
  Film,
  Gamepad2,
  Disc,
  Info,
  ChevronLeft,
  Clock,
  LogOut,
  MessageSquare,
  Pin,
  Lock,
  Search,
  Plus,
  ChevronRight,
  Settings,
  Trash2,
} from "lucide-react";
import { cx } from "../../utils/formatters";
import { useUserProfileData } from "../../hooks/useUserProfileData.js";
import { useUserDatabase } from "../../contexts/UserDatabaseContext.jsx";
import { useAuth } from "../../contexts/AuthContext.jsx";

import HeaderBar from "../../components/layout/HeaderBar/HeaderBar.jsx";
import ManageClubModal from "../../components/club/ManageClubModal/ManageClubModal.jsx";

const TypeIcon = {
  livro: BookOpen,
  filme: Film,
  jogo: Gamepad2,
  album: Disc,
};

// ==========================
// COMPONENTE UNIFICADO DE CARD DE OBRA
// ==========================
const ClubWorkCard = ({ work, variant = "active", t }) => {
  if (!work) return null; // Proteção contra crash

  const WorkIcon = TypeIcon[work.type] || BookOpen;
  const author = work.author || "Artista Desconhecido";

  return (
    <div className="flex flex-col sm:flex-row gap-4 p-4 rounded-xl border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 hover:border-neutral-300 dark:hover:border-neutral-700 transition-all group cursor-pointer relative">
      <div className="w-20 h-28 bg-neutral-100 dark:bg-neutral-800 rounded-lg flex items-center justify-center shrink-0 text-neutral-400 shadow-sm group-hover:text-indigo-500 transition-colors">
        <WorkIcon size={32} />
      </div>

      <div className="flex-1 flex flex-col justify-center min-w-0">
        {variant === "history" && (
          <div className="flex items-center justify-between mb-1">
            <span className="text-[10px] font-bold text-neutral-500 uppercase tracking-wider">
              {t ? t("club.card.cycle_prev") : "Ciclo Anterior"}
            </span>
            <span className="text-xs text-neutral-400">
              {t ? t("club.card.ended_at") : "Encerrado em"} 10 Out
            </span>
          </div>
        )}

        <h4 className="font-bold text-xl text-neutral-900 dark:text-neutral-100 leading-tight mb-0.5 truncate">
          {work.title}
        </h4>
        <p className="text-sm text-neutral-500 mb-2 truncate">{author}</p>

        <div className="mb-auto">
          <span className="text-[10px] font-bold bg-neutral-100 dark:bg-neutral-800 text-neutral-500 px-2 py-0.5 rounded uppercase tracking-wide border border-neutral-200 dark:border-neutral-700">
            {t ? t(`badge.${work.type}`) : work.type}
          </span>
        </div>

        <div className="mt-3 pt-3 border-t border-neutral-100 dark:border-neutral-800 flex items-center gap-4 text-xs">
          {variant === "overview" && (
            <Link
              to={`/media/${work.id}`}
              className="font-medium text-indigo-600 dark:text-indigo-400 flex items-center gap-1 hover:underline"
            >
              {t ? t("club.card.view_details") : "Ver ficha técnica"}
            </Link>
          )}
          {variant === "discussions" && (
            <>
              <div className="flex items-center gap-1.5 text-indigo-600 dark:text-indigo-400 font-medium">
                <MessageSquare size={14} />
                <span>
                  3 {t ? t("club.card.topics_open") : "tópicos abertos"}
                </span>
              </div>
              <span className="text-neutral-300 dark:text-neutral-700">|</span>
              <div className="flex items-center gap-1.5 text-neutral-500">
                <Users size={14} />
                <span>
                  42 {t ? t("club.card.participating") : "participando"}
                </span>
              </div>
            </>
          )}
          {variant === "history" && (
            <>
              <button className="font-medium text-indigo-600 dark:text-indigo-400 flex items-center gap-1.5 hover:underline">
                <MessageSquare size={14} />
                {t ? t("club.card.view_archived") : "Ver tópicos arquivados"}
              </button>
              <span className="text-neutral-300 dark:text-neutral-700">|</span>
              <div className="flex items-center gap-1.5 text-neutral-500">
                <Users size={14} />
                <span>
                  85 {t ? t("club.card.participating") : "participaram"}
                </span>
              </div>
            </>
          )}
        </div>
      </div>

      <div className="self-center hidden sm:block text-neutral-300 dark:text-neutral-700 group-hover:translate-x-1 transition-transform">
        <ChevronRight size={20} />
      </div>
    </div>
  );
};

// Componente Auxiliar: Linha de Tópico
const DiscussionRow = ({ topic, isExtra, t, clubId }) => (
  <Link
    to={topic.id ? `/club/${clubId}/topic/${topic.id}` : "#"}
    className="flex items-start gap-4 p-4 border-b border-neutral-100 dark:border-neutral-800 hover:bg-neutral-50 dark:hover:bg-neutral-800/50 transition-colors cursor-pointer group last:border-0"
  >
    <div className="pt-1">
      {topic.isPinned ? (
        <Pin size={18} className="text-indigo-500 fill-current" />
      ) : topic.isLocked ? (
        <Lock size={18} className="text-neutral-400" />
      ) : (
        <MessageSquare
          size={18}
          className="text-neutral-400 group-hover:text-indigo-500 transition-colors"
        />
      )}
    </div>
    <div className="flex-1 min-w-0">
      <h4 className="text-sm font-bold text-neutral-900 dark:text-neutral-100 leading-tight group-hover:text-indigo-600 dark:group-hover:text-indigo-400 transition-colors mb-1">
        {topic.title}
      </h4>
      <div className="flex items-center gap-2 text-xs text-neutral-500">
        <span>
          {t ? t("club.card.by") : "por"}{" "}
          <span className="font-medium text-neutral-700 dark:text-neutral-300">
            @{topic.author}
          </span>
        </span>
        <span>•</span>
        <span>
          {Array.isArray(topic.replies)
            ? topic.replies.length
            : topic.replies || 0}{" "}
          {t ? t("club.card.responses") : "respostas"}
        </span>
      </div>
    </div>
    <div className="text-xs text-neutral-400 whitespace-nowrap">
      {isExtra ? "há 5 min" : "há 2h"}
    </div>
  </Link>
);

// Componente Auxiliar: Card de Membro
const MemberCard = ({ name, handle, role, avatar, t }) => (
  <Link
    to={`/profile/${handle?.replace("@", "") || ""}`}
    className="flex items-center gap-3 p-3 rounded-xl border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 hover:border-neutral-300 dark:hover:border-neutral-700 transition-colors group"
  >
    <div className="w-10 h-10 rounded-full bg-gradient-to-br from-neutral-200 to-neutral-400 dark:from-neutral-700 dark:to-neutral-600 flex items-center justify-center text-sm font-bold text-neutral-700 dark:text-neutral-200">
      {avatar}
    </div>
    <div className="flex flex-col">
      <span className="text-sm font-bold text-neutral-900 dark:text-neutral-100 group-hover:text-indigo-600 dark:group-hover:text-indigo-400 transition-colors">
        {name}
      </span>
      <span className="text-xs text-neutral-500">{handle}</span>
    </div>
    {role === "owner" && (
      <span className="ml-auto px-2 py-1 bg-amber-100 dark:bg-amber-900/30 text-amber-700 dark:text-amber-400 text-[10px] font-bold uppercase rounded-full">
        {t ? t("club.role.owner") : "Fundador"}
      </span>
    )}
    {role === "mod" && (
      <span className="ml-auto px-2 py-1 bg-indigo-100 dark:bg-indigo-900/30 text-indigo-700 dark:text-indigo-400 text-[10px] font-bold uppercase rounded-full">
        {t ? t("club.role.mod") : "Mod"}
      </span>
    )}
  </Link>
);

export default function ClubDetailsPage({ theme, setTheme, lang, setLang, t }) {
  const { clubId } = useParams();
  const navigate = useNavigate();
  const { clubs } = useUserProfileData();
  const { deleteClub } = useUserDatabase();
  const { currentUser } = useAuth();

  const club = clubs?.find((c) => c.id === clubId);

  const [isManageModalOpen, setIsManageModalOpen] = useState(false);
  const [activeTab, setActiveTab] = useState("overview");
  const [memberSearch, setMemberSearch] = useState("");
  const [isMemberSearchOpen, setIsMemberSearchOpen] = useState(false);
  const memberSearchInputRef = useRef(null);

  // --- PROTEÇÃO CONTRA CRASH ---
  const userMembership = useMemo(() => {
    if (!club || !currentUser || !club.members) return null; // Verifica club.members
    return club.members.find(
      (m) => m.handle.replace("@", "") === currentUser.handle,
    );
  }, [club, currentUser]);

  const isMember = !!userMembership;
  const isOwner = userMembership?.role === "owner";
  const isMod = userMembership?.role === "mod";
  const canManage = isOwner || isMod;

  useEffect(() => {
    if (isMemberSearchOpen && memberSearchInputRef.current) {
      memberSearchInputRef.current.focus();
    }
  }, [isMemberSearchOpen]);

  // --- PROTEÇÃO CONTRA CRASH ---
  const filteredMembers = useMemo(() => {
    if (!club?.members) return [];
    if (!memberSearch) return club.members;
    const q = memberSearch.toLowerCase();
    return club.members.filter(
      (m) =>
        m.name.toLowerCase().includes(q) || m.handle.toLowerCase().includes(q),
    );
  }, [club, memberSearch]);

  if (!club) {
    return (
      <div className={cx(theme === "dark" ? "dark" : "", "font-sans")}>
        <div className="min-h-screen bg-neutral-50 dark:bg-neutral-950 flex items-center justify-center text-neutral-500">
          Clube não encontrado.
        </div>
      </div>
    );
  }

  const handleJoinLeave = () => {
    alert("Lógica de entrar/sair será implementada no backend.");
  };

  const handleDeleteClub = () => {
    if (
      window.confirm(
        "Tem certeza que deseja excluir este clube? Esta ação não pode ser desfeita.",
      )
    ) {
      deleteClub(club.id);
      navigate("/clubs");
    }
  };

  const renderActionButton = () => {
    if (isOwner) {
      return (
        <div className="flex items-center gap-2">
          <button
            onClick={() => setIsManageModalOpen(true)}
            className="w-9 h-9 flex items-center justify-center rounded-full border border-neutral-200 dark:border-neutral-800 bg-transparent text-neutral-500 hover:text-neutral-900 dark:text-neutral-400 dark:hover:text-neutral-100 hover:bg-neutral-100 dark:hover:bg-neutral-800 transition-colors"
            title={t("club.action.manage")}
          >
            <Settings size={18} strokeWidth={2} />
          </button>
          <button
            onClick={handleDeleteClub}
            className="w-9 h-9 flex items-center justify-center rounded-full border border-red-200 dark:border-red-900/30 bg-transparent text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 transition-colors"
            title="Deletar Clube"
          >
            <Trash2 size={18} strokeWidth={2} />
          </button>
        </div>
      );
    }
    if (isMember) {
      return (
        <button
          onClick={handleJoinLeave}
          className="h-9 px-4 rounded-lg border border-red-500/50 text-red-500 hover:bg-red-50 dark:hover:bg-red-900/20 text-sm font-medium flex items-center gap-2 transition-colors"
        >
          <LogOut size={16} /> {t("club.action.leave")}
        </button>
      );
    }
    return (
      <button
        onClick={handleJoinLeave}
        className="h-9 px-6 rounded-lg bg-neutral-900 dark:bg-white text-white dark:text-neutral-900 text-sm font-bold shadow-sm hover:opacity-90 transition-opacity"
      >
        {t("club.action.join")}
      </button>
    );
  };

  const renderTabs = () => {
    const tabs = [
      { id: "overview", label: t("club.tab.overview") },
      { id: "discussions", label: t("club.tab.discussions") },
      { id: "members", label: t("club.tab.members") },
      { id: "history", label: t("club.tab.history") },
    ];
    return (
      <div className="flex items-center gap-6 overflow-x-auto no-scrollbar">
        {tabs.map((tab) => (
          <button
            key={tab.id}
            onClick={() => setActiveTab(tab.id)}
            className={cx(
              "pb-3 text-sm font-medium transition-colors relative whitespace-nowrap",
              activeTab === tab.id
                ? "text-indigo-600 dark:text-indigo-400"
                : "text-neutral-500 hover:text-neutral-800 dark:hover:text-neutral-300",
            )}
          >
            {tab.label}
            {activeTab === tab.id && (
              <span className="absolute bottom-0 left-0 w-full h-0.5 bg-indigo-600 dark:bg-indigo-400 rounded-t-full" />
            )}
          </button>
        ))}
      </div>
    );
  };

  const getTopicsByContext = (contextId) => {
    return club.topics?.filter((t) => t.context === contextId) || [];
  };

  const bannerStyle = club.bannerUrl
    ? {
        backgroundImage: `url(${club.bannerUrl})`,
        backgroundSize: "cover",
        backgroundPosition: "center",
      }
    : {};
  const bannerClass = club.bannerUrl
    ? "w-full pt-24 pb-8 relative overflow-hidden"
    : cx("w-full pt-24 pb-8 bg-gradient-to-b", club.coverGradient);

  return (
    <div className={cx(theme === "dark" ? "dark" : "", "font-sans")}>
      <div className="min-h-screen bg-neutral-50 text-neutral-900 dark:bg-neutral-950 dark:text-neutral-100 transition-colors duration-300">
        <HeaderBar
          theme={theme}
          setTheme={setTheme}
          lang={lang}
          setLang={setLang}
          t={t}
        />

        <div className={bannerClass} style={bannerStyle}>
          {club.bannerUrl && (
            <div className="absolute inset-0 bg-black/60 backdrop-blur-[2px]" />
          )}
          <div className="max-w-7xl mx-auto px-4 relative z-10">
            <Link
              to="/clubs"
              className="text-white/80 hover:text-white mb-6 flex items-center gap-1 text-sm font-medium w-fit"
            >
              <ChevronLeft size={16} /> {t("clubs.title")}
            </Link>
            <div className="flex flex-col gap-4">
              <h1 className="text-4xl md:text-5xl font-bold text-white shadow-sm tracking-tight">
                {club.name}
              </h1>
              <div className="flex items-center gap-4 text-white/90 font-medium">
                <span className="opacity-80 font-mono bg-white/10 px-2 py-0.5 rounded">
                  @{club.id}
                </span>
                <span className="w-1 h-1 rounded-full bg-white/50" />
                <span className="flex items-center gap-1.5">
                  <Users size={16} /> {club.membersCount}{" "}
                  {t("club.role.member")}s
                </span>
              </div>
              <p className="text-lg text-white/90 max-w-2xl leading-relaxed">
                {club.description}
              </p>
              <div className="flex flex-wrap gap-2 mt-2">
                {club.tags.map((tag) => (
                  <span
                    key={tag}
                    className="px-3 py-1 rounded-full bg-black/20 backdrop-blur-sm border border-white/10 text-white text-xs font-medium"
                  >
                    {t ? t(tag) : tag}
                  </span>
                ))}
              </div>
            </div>
          </div>
        </div>

        <main className="max-w-7xl mx-auto px-4">
          <div className="sticky top-16 z-20 bg-neutral-50/95 dark:bg-neutral-950/95 backdrop-blur-sm border-b border-neutral-200 dark:border-neutral-800 pt-4 mb-8 flex items-center justify-between">
            {renderTabs()}
            <div className="pb-2">{renderActionButton()}</div>
          </div>

          <div className="grid grid-cols-1 lg:grid-cols-12 gap-8 pb-16">
            <div className="lg:col-span-8 flex flex-col gap-8 min-h-0">
              {activeTab === "overview" && (
                <>
                  <section>
                    <div className="flex items-center justify-between mb-4">
                      <h3 className="text-lg font-bold flex items-center gap-2 text-neutral-800 dark:text-neutral-100">
                        <BookOpen className="w-5 h-5 text-indigo-500" />
                        {t("club.section.active_works")}
                      </h3>
                      {canManage && (
                        <button
                          className="w-8 h-8 flex items-center justify-center rounded-full border border-neutral-200 dark:border-neutral-800 bg-transparent text-neutral-500 hover:text-indigo-600 dark:hover:text-indigo-400 transition-colors"
                          title="Adicionar nova obra"
                        >
                          <Plus size={18} strokeWidth={2.5} />
                        </button>
                      )}
                    </div>
                    {/* PROTEÇÃO CONTRA FALTA DE DADOS */}
                    {club.activeWorks && club.activeWorks.length > 0 ? (
                      <div className="grid grid-cols-1 gap-4">
                        {club.activeWorks.map((work, idx) => (
                          <ClubWorkCard
                            key={idx}
                            work={work}
                            variant="overview"
                            t={t}
                          />
                        ))}
                      </div>
                    ) : (
                      <div className="p-6 rounded-xl border border-dashed text-center text-neutral-500">
                        {t("club.placeholder.no_activity")}
                      </div>
                    )}
                  </section>
                </>
              )}

              {activeTab === "discussions" && (
                <div className="flex flex-col gap-8">
                  <div>
                    <div className="flex items-center justify-between mb-4">
                      <h3 className="text-lg font-bold text-neutral-900 dark:text-neutral-100">
                        {t("club.section.general_topics")}
                      </h3>
                      <button className="w-8 h-8 flex items-center justify-center rounded-full border border-neutral-200 dark:border-neutral-800 bg-transparent text-neutral-500 hover:text-neutral-900 dark:text-neutral-400 dark:hover:text-neutral-100 hover:bg-neutral-100 dark:hover:bg-neutral-800 transition-colors">
                        <Plus size={18} strokeWidth={2.5} />
                      </button>
                    </div>
                    <div className="bg-white dark:bg-neutral-900 border border-neutral-200 dark:border-neutral-800 rounded-2xl overflow-hidden">
                      {getTopicsByContext("general").map((topic) => (
                        <DiscussionRow
                          key={topic.id}
                          topic={topic}
                          t={t}
                          clubId={club.id}
                        />
                      ))}
                      <DiscussionRow
                        topic={{
                          title: "Sugestões para o próximo ciclo",
                          author: "maris",
                          replies: 5,
                          isPinned: false,
                        }}
                        isExtra={true}
                        t={t}
                        clubId={club.id}
                      />
                    </div>
                  </div>
                  <div>
                    <div className="grid grid-cols-1 gap-3">
                      {club.activeWorks?.map((work) => (
                        <ClubWorkCard
                          key={work.id}
                          work={work}
                          variant="discussions"
                          t={t}
                        />
                      ))}
                    </div>
                  </div>
                </div>
              )}

              {activeTab === "members" && (
                <section>
                  <div className="mb-4 flex items-center justify-between">
                    <h3 className="font-bold text-lg">
                      {t("club.tab.members")} ({club.membersCount})
                    </h3>
                    <div
                      className={cx(
                        "flex items-center border rounded-full transition-all duration-300 ease-in-out overflow-hidden bg-transparent",
                        isMemberSearchOpen
                          ? "w-64 pl-3 pr-4 border-neutral-300 dark:border-neutral-700"
                          : "w-9 border-transparent justify-end",
                      )}
                    >
                      <button
                        onClick={() => setIsMemberSearchOpen(true)}
                        className={cx(
                          "w-9 h-9 flex items-center justify-center shrink-0 transition-colors text-neutral-500 hover:text-indigo-500 dark:hover:text-indigo-400",
                          !isMemberSearchOpen &&
                            "rounded-full hover:bg-neutral-100 dark:hover:bg-neutral-800",
                        )}
                      >
                        <Search size={18} strokeWidth={2} />
                      </button>
                      <input
                        ref={memberSearchInputRef}
                        type="text"
                        value={memberSearch}
                        onChange={(e) => setMemberSearch(e.target.value)}
                        onBlur={() => setIsMemberSearchOpen(false)}
                        onKeyDown={(e) => {
                          if (e.key === "Escape") {
                            setIsMemberSearchOpen(false);
                            setMemberSearch("");
                            e.currentTarget.blur();
                          }
                        }}
                        placeholder={t("search.placeholder")}
                        className={cx(
                          "bg-transparent border-none outline-none text-sm text-neutral-900 dark:text-neutral-100 placeholder-neutral-400 h-9 transition-all duration-300",
                          isMemberSearchOpen
                            ? "w-full opacity-100 ml-2"
                            : "w-0 opacity-0 ml-0",
                        )}
                      />
                    </div>
                  </div>
                  {filteredMembers.length > 0 ? (
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                      {filteredMembers.map((member, idx) => (
                        <MemberCard
                          key={idx}
                          name={member.name}
                          handle={member.handle}
                          role={member.role}
                          avatar={member.avatar}
                          t={t}
                        />
                      ))}
                    </div>
                  ) : (
                    <p className="text-center text-neutral-500 py-8 border border-dashed rounded-xl border-neutral-300 dark:border-neutral-700">
                      {t("club.placeholder.no_member")}
                    </p>
                  )}
                </section>
              )}

              {activeTab === "history" && (
                <section className="flex flex-col gap-4">
                  <ClubWorkCard
                    work={{
                      title: "Neuromancer",
                      type: "livro",
                      id: "b_neuromancer_old",
                    }}
                    variant="history"
                    t={t}
                  />
                </section>
              )}
            </div>

            <div className="lg:col-span-4 flex flex-col gap-6 sticky top-36 h-fit">
              <div>
                <h3 className="text-lg font-bold mb-4 flex items-center gap-2 text-neutral-800 dark:text-neutral-100">
                  <Info size={18} />
                  {t("club.section.rules")}
                </h3>
                <div className="p-5 rounded-2xl bg-amber-50 dark:bg-amber-900/10 border border-amber-200 dark:border-amber-800/30">
                  <div className="text-amber-900/80 dark:text-amber-100/70 text-sm leading-relaxed whitespace-pre-line">
                    {club.rules || "Nenhuma regra definida."}
                  </div>
                </div>
              </div>

              {/* CARD PRÓXIMO ENCONTRO - RECOLOCADO COMO PEDIDO */}
              <div
                className={cx(
                  "p-5 rounded-2xl shadow-lg text-white bg-gradient-to-br",
                  club.coverGradient,
                )}
              >
                <h3 className="text-white/80 text-xs font-bold uppercase tracking-wider mb-3">
                  {t("club.next_meeting")}
                </h3>
                <div className="flex items-center gap-3 mb-4">
                  <div className="w-10 h-10 rounded-full bg-white/20 flex items-center justify-center text-white backdrop-blur-sm">
                    <Calendar size={20} />
                  </div>
                  <span className="text-lg font-bold text-white shadow-sm">
                    {club.nextMeeting}
                  </span>
                </div>
                <button className="w-full py-2 bg-white/20 hover:bg-white/30 rounded-lg text-sm font-semibold text-white transition-colors backdrop-blur-sm">
                  {t("club.add_to_calendar")}
                </button>
              </div>
              {/* FIM CARD PRÓXIMO ENCONTRO */}
            </div>
          </div>
        </main>

        <ManageClubModal
          isOpen={isManageModalOpen}
          onClose={() => setIsManageModalOpen(false)}
          clubData={club}
          t={t}
        />
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/ClubsDiscoveryPage/ClubsDiscoveryPage.jsx">
import React, { useState, useMemo, useRef, useEffect } from "react";
import { Search, Plus } from "lucide-react";
import { cx } from "../../utils/formatters";
import { useUserProfileData } from "../../hooks/useUserProfileData.js";

import HeaderBar from "../../components/layout/HeaderBar/HeaderBar.jsx";
import ClubCard from "../../components/club/ClubCard/ClubCard.jsx";
import CreateClubModal from "../../components/club/CreateClubModal/CreateClubModal.jsx"; // IMPORTADO

export default function ClubsDiscoveryPage({
  theme,
  setTheme,
  lang,
  setLang,
  t,
}) {
  const { clubs } = useUserProfileData();

  const [searchQuery, setSearchQuery] = useState("");
  const [activeFilter, setActiveFilter] = useState("all");

  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const searchInputRef = useRef(null);

  // ESTADO PARA O MODAL
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);

  useEffect(() => {
    if (isSearchOpen && searchInputRef.current) {
      searchInputRef.current.focus();
    }
  }, [isSearchOpen]);

  const filteredClubs = useMemo(() => {
    if (!clubs) return [];

    return clubs.filter((club) => {
      const matchesSearch =
        club.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        club.description.toLowerCase().includes(searchQuery.toLowerCase());

      let matchesCategory = true;
      if (activeFilter === "reading")
        matchesCategory = club.tags.includes("tag.literatura");
      else if (activeFilter === "cinema")
        matchesCategory = club.tags.includes("tag.cinema");
      else if (activeFilter === "gaming")
        matchesCategory = club.tags.includes("tag.jogos");
      else if (activeFilter === "music")
        matchesCategory = club.tags.includes("tag.musica");

      return matchesSearch && matchesCategory;
    });
  }, [clubs, searchQuery, activeFilter]);

  const renderFilters = () => {
    const filters = [
      { id: "all", label: t("clubs.filter_all") },
      { id: "reading", label: t("clubs.filter_reading") },
      { id: "cinema", label: t("clubs.filter_cinema") },
      { id: "gaming", label: t("clubs.filter_gaming") },
      { id: "music", label: t("clubs.filter_music") },
    ];

    return (
      <div className="flex flex-wrap gap-2 items-center">
        {filters.map((f) => (
          <button
            key={f.id}
            onClick={() => setActiveFilter(f.id)}
            className={cx(
              "px-4 py-2 rounded-full text-sm font-medium transition-all duration-200 border whitespace-nowrap",
              activeFilter === f.id
                ? "bg-indigo-600 border-indigo-600 text-white shadow-md shadow-indigo-500/20"
                : "bg-transparent border-neutral-200 dark:border-neutral-800 text-neutral-600 dark:text-neutral-400 hover:border-neutral-300 dark:hover:border-neutral-700",
            )}
          >
            {f.label}
          </button>
        ))}
      </div>
    );
  };

  const iconButtonClass =
    "w-10 h-10 flex items-center justify-center rounded-full border border-neutral-200 dark:border-neutral-800 bg-transparent text-neutral-500 dark:text-neutral-400 hover:text-neutral-900 dark:hover:text-neutral-100 hover:bg-neutral-100 dark:hover:bg-neutral-800 transition-colors";

  return (
    <div className={cx(theme === "dark" ? "dark" : "", "font-sans")}>
      <div className="min-h-screen bg-neutral-50 text-neutral-900 dark:bg-neutral-950 dark:text-neutral-100 transition-colors duration-300">
        <HeaderBar
          theme={theme}
          setTheme={setTheme}
          lang={lang}
          setLang={setLang}
          t={t}
        />

        <main className="max-w-7xl mx-auto px-4 pt-24 pb-16">
          <div className="mb-8 flex flex-col gap-6">
            <div>
              <h1 className="text-3xl font-bold mb-2 text-neutral-900 dark:text-neutral-100">
                {t("clubs.title")}
              </h1>
              <p className="text-neutral-500 dark:text-neutral-400 max-w-xl">
                {t("clubs.subtitle")}
              </p>
            </div>

            <div className="flex flex-col md:flex-row items-start md:items-center justify-between gap-4 border-b border-neutral-200/50 dark:border-neutral-800/50 pb-6">
              <div className="flex items-center gap-2">
                {/* Botão Criar Clube (+) - Agora abre o Modal */}
                <button
                  className={iconButtonClass}
                  title="Criar novo clube"
                  onClick={() => setIsCreateModalOpen(true)}
                >
                  <Plus size={20} strokeWidth={2} />
                </button>

                {/* Busca Expansível */}
                <div
                  className={cx(
                    "flex items-center border rounded-full transition-all duration-300 ease-in-out overflow-hidden bg-transparent",
                    isSearchOpen
                      ? "w-64 pl-3 pr-4 border-neutral-300 dark:border-neutral-700"
                      : "w-10 border-transparent",
                  )}
                >
                  <button
                    onClick={() => setIsSearchOpen(true)}
                    className={cx(
                      iconButtonClass,
                      isSearchOpen
                        ? "border-0 w-auto h-auto p-0 hover:bg-transparent cursor-default"
                        : "",
                    )}
                  >
                    <Search size={20} strokeWidth={2} />
                  </button>

                  <input
                    ref={searchInputRef}
                    type="text"
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    onBlur={() => setIsSearchOpen(false)}
                    onKeyDown={(e) => {
                      if (e.key === "Escape") {
                        setIsSearchOpen(false);
                        setSearchQuery("");
                        e.currentTarget.blur();
                      }
                    }}
                    placeholder="Buscar..."
                    className={cx(
                      "bg-transparent border-none outline-none text-sm text-neutral-900 dark:text-neutral-100 placeholder-neutral-400 h-10 transition-all duration-300",
                      isSearchOpen
                        ? "w-full opacity-100 ml-2"
                        : "w-0 opacity-0 ml-0",
                    )}
                  />
                </div>
              </div>

              <div className="w-full md:w-auto overflow-x-auto no-scrollbar">
                {renderFilters()}
              </div>
            </div>
          </div>

          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
            {filteredClubs.map((club) => (
              <ClubCard key={club.id} club={club} t={t} />
            ))}
          </div>

          {filteredClubs.length === 0 && (
            <div className="text-center py-20">
              <div className="inline-flex items-center justify-center w-16 h-16 rounded-full bg-neutral-100 dark:bg-neutral-900 mb-4">
                <Search className="w-8 h-8 text-neutral-400" />
              </div>
              <h3 className="text-lg font-semibold text-neutral-900 dark:text-neutral-100">
                {t("list.no_results")}
              </h3>
              <p className="text-neutral-500 mt-2">
                Tente buscar por outro termo ou mude o filtro.
              </p>
            </div>
          )}

          {/* MODAL DE CRIAÇÃO */}
          <CreateClubModal
            isOpen={isCreateModalOpen}
            onClose={() => setIsCreateModalOpen(false)}
            t={t}
          />
        </main>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/ClubTopicPage/ClubTopicPage.jsx">
import React, { useState } from "react";
import { useParams, Link } from "react-router-dom";
import { ChevronLeft, MessageSquare, Send } from "lucide-react";
import { useUserProfileData } from "../../hooks/useUserProfileData.js";
import { cx } from "../../utils/formatters";
import HeaderBar from "../../components/layout/HeaderBar/HeaderBar.jsx";

export default function ClubTopicPage({ theme, setTheme, lang, setLang, t }) {
  const { clubId, topicId } = useParams();
  const { clubs } = useUserProfileData();

  const club = clubs?.find((c) => c.id === clubId);
  const topic = club?.topics?.find((t) => t.id === topicId);

  const [replyText, setReplyText] = useState("");

  if (!club || !topic) {
    return (
      <div className={cx(theme === "dark" ? "dark" : "", "font-sans")}>
        <div className="min-h-screen bg-neutral-50 dark:bg-neutral-950 flex items-center justify-center text-neutral-500">
          {t("topic.content_unavailable")}
        </div>
      </div>
    );
  }

  return (
    <div className={cx(theme === "dark" ? "dark" : "", "font-sans")}>
      <div className="min-h-screen bg-neutral-50 text-neutral-900 dark:bg-neutral-950 dark:text-neutral-100 transition-colors duration-300">
        <HeaderBar
          theme={theme}
          setTheme={setTheme}
          lang={lang}
          setLang={setLang}
          t={t}
        />

        <main className="max-w-4xl mx-auto px-4 pt-24 pb-16">
          {/* Breadcrumb */}
          <Link
            to={`/club/${clubId}`}
            className="inline-flex items-center gap-1 text-sm text-neutral-500 hover:text-indigo-600 dark:hover:text-indigo-400 mb-6 transition-colors"
          >
            <ChevronLeft size={16} /> {t("topic.back_to")} {club.name}
          </Link>

          {/* POST PRINCIPAL */}
          <article className="bg-white dark:bg-neutral-900 border border-neutral-200 dark:border-neutral-800 rounded-2xl p-6 mb-8 shadow-sm">
            <h1 className="text-2xl md:text-3xl font-bold mb-4 text-neutral-900 dark:text-neutral-100">
              {topic.title}
            </h1>

            <div className="flex items-center gap-3 mb-6 pb-6 border-b border-neutral-100 dark:border-neutral-800">
              <div className="w-10 h-10 rounded-full bg-indigo-100 dark:bg-indigo-900/30 flex items-center justify-center text-indigo-600 dark:text-indigo-400 font-bold">
                {topic.author[0].toUpperCase()}
              </div>
              <div>
                <Link
                  to={`/profile/${topic.author}`}
                  className="font-semibold text-sm hover:underline"
                >
                  @{topic.author}
                </Link>
                <p className="text-xs text-neutral-500">
                  {t("topic.started_on")} {topic.date || "20 Out 2025"}
                </p>
              </div>
              {topic.isPinned && (
                <span className="ml-auto px-2 py-1 bg-indigo-100 dark:bg-indigo-900/30 text-indigo-600 dark:text-indigo-400 text-xs font-bold uppercase rounded">
                  {t("topic.pinned")}
                </span>
              )}
            </div>

            <div className="prose dark:prose-invert max-w-none text-neutral-700 dark:text-neutral-300 whitespace-pre-wrap leading-relaxed">
              {topic.body || t("topic.content_unavailable")}
            </div>
          </article>

          {/* SEÇÃO DE RESPOSTAS */}
          <section>
            <h3 className="text-lg font-bold mb-4 flex items-center gap-2">
              <MessageSquare size={20} />
              {topic.replies?.length || 0} {t("topic.replies_count")}
            </h3>

            {/* Lista de Respostas */}
            <div className="flex flex-col gap-4 mb-8">
              {topic.replies?.map((reply) => (
                <div
                  key={reply.id}
                  className="flex gap-4 p-4 rounded-xl bg-neutral-100/50 dark:bg-neutral-900 border border-transparent hover:border-neutral-200 dark:hover:border-neutral-800 transition-colors"
                >
                  <div className="w-8 h-8 rounded-full bg-neutral-200 dark:bg-neutral-800 flex items-center justify-center text-xs font-bold shrink-0">
                    {reply.author[0].toUpperCase()}
                  </div>
                  <div className="flex-1">
                    <div className="flex items-baseline justify-between mb-1">
                      <span className="font-semibold text-sm">
                        @{reply.author}
                      </span>
                      <span className="text-xs text-neutral-400">
                        {reply.date}
                      </span>
                    </div>
                    <p className="text-sm text-neutral-700 dark:text-neutral-300 leading-relaxed">
                      {reply.text}
                    </p>
                  </div>
                </div>
              ))}

              {(!topic.replies || topic.replies.length === 0) && (
                <p className="text-neutral-500 text-center py-8 italic">
                  {t("topic.no_replies")}
                </p>
              )}
            </div>

            {/* Editor de Resposta */}
            <div className="bg-white dark:bg-neutral-900 border border-neutral-200 dark:border-neutral-800 rounded-2xl p-4 sticky bottom-4 shadow-lg">
              <textarea
                value={replyText}
                onChange={(e) => setReplyText(e.target.value)}
                placeholder={t("topic.reply_placeholder")}
                className="w-full p-3 rounded-xl bg-neutral-50 dark:bg-neutral-950 border border-neutral-200 dark:border-neutral-800 focus:border-indigo-500 outline-none resize-none text-sm min-h-[80px]"
              />
              <div className="flex justify-end mt-3">
                <button
                  className="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-bold rounded-lg flex items-center gap-2 transition-colors"
                  onClick={() =>
                    alert("Funcionalidade de responder virá na próxima etapa!")
                  }
                >
                  <Send size={16} /> {t("topic.reply_button")}
                </button>
              </div>
            </div>
          </section>
        </main>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/FavoritesPage/FavoritesPage.jsx">
import React from "react";
import { useParams, useNavigate } from "react-router-dom";

// Importando componentes, hooks e utilitários
import { cx } from "../../utils/formatters";
import { useUserProfileData } from "../../hooks/useUserProfileData.js";
import { useUserDatabase } from "../../contexts/UserDatabaseContext.jsx"; // 1. Importar o Contexto
import HeaderBar from "../../components/layout/HeaderBar/HeaderBar.jsx";
import MediaCard from "../../components/ui/MediaCard/MediaCard.jsx";

// ==========================
// MOCK DE AUTENTICAÇÃO
const LOGGED_IN_USER_HANDLE = "alexl";
// ==========================

// ==========================
// Componente da Página de Favoritos
// ==========================
export default function FavoritesPage({ theme, setTheme, lang, setLang, t }) {
  const { handle } = useParams();
  const navigate = useNavigate();

  // 2. Usar o Contexto para ler a "memória" e pegar as funções
  const { toggleFavorite } = useUserDatabase();
  // O 'useUserProfileData' agora lê do Contexto, então 'profile' e 'favorites'
  // estarão sempre atualizados com a "memória" da sessão.
  const { profile, favorites } = useUserProfileData(handle);

  const isOwner = profile?.handle === `@${LOGGED_IN_USER_HANDLE}`;

  const handleRemoveFavorite = (mediaIdToRemove) => {
    // 3. Ação de remover agora chama a função do Contexto
    // Precisamos do 'mediaData' completo para a função 'toggleFavorite'
    // Como esta página só lista favoritos, o item já está nos dados
    const itemToRemove = favorites.find((fav) => fav.id === mediaIdToRemove);
    if (itemToRemove) {
      // Passamos o item completo, pois 'toggleFavorite' precisa dele
      toggleFavorite(profile.handle, itemToRemove);
    }
  };

  if (!profile) {
    return <div className="text-center py-20">Utilizador não encontrado.</div>;
  }

  // Lógica de Título Dinâmico
  const pageTitle = isOwner ? (
    t("favorites.my_title") // "Meus favoritos"
  ) : (
    <>
      {t("favorites.title_prefix")} {/* "Favoritos de" */}
      <span>{profile.name}</span> {/* "Marina Silva" */}
    </>
  );

  return (
    <div className={cx(theme === "dark" ? "dark" : "", "font-sans")}>
      <div className="min-h-screen bg-neutral-50 text-neutral-900 dark:bg-neutral-950 dark:text-neutral-100">
        <HeaderBar
          theme={theme}
          setTheme={setTheme}
          lang={lang}
          setLang={setLang}
          t={t}
        />

        <main className="max-w-7xl mx-auto px-4 pt-24 pb-16 flex flex-col gap-8">
          <h1 className="text-3xl font-bold tracking-tight text-neutral-800 dark:text-neutral-100">
            {pageTitle}
          </h1>

          {/* 4. A grelha agora lê 'favorites' direto do hook, que vem do Contexto */}
          {favorites && favorites.length > 0 ? (
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6">
              {favorites.map((item) => (
                <MediaCard
                  key={item.id}
                  item={item}
                  onClick={() => navigate(`/media/${item.id}`)}
                  onRemove={isOwner ? handleRemoveFavorite : undefined}
                />
              ))}
            </div>
          ) : (
            <div className="text-center py-20 border-2 border-dashed border-neutral-200 dark:border-neutral-800 rounded-2xl">
              <p className="text-neutral-500 dark:text-neutral-400">
                Este utilizador ainda não adicionou favoritos.
              </p>
            </div>
          )}
        </main>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/ForgotPasswordPage/ForgotPasswordPage.jsx">
import React, { useState } from "react";
import { Link } from "react-router-dom";
// Importando 'Mail' para o campo e 'MailCheck' para o sucesso
import { Mail, MailCheck } from "lucide-react";
import HeaderBar from "../../components/layout/HeaderBar/HeaderBar.jsx";

function ForgotPasswordPage({ theme, setTheme, lang, setLang, t }) {
  const [email, setEmail] = useState("");
  // Estado para controlar a exibição do formulário ou da mensagem de sucesso
  const [isSubmitted, setIsSubmitted] = useState(false);

  // Função 'safeT' (get translation)
  const getT = (key, fallback) => {
    if (typeof t === "function") {
      const translated = t(key);
      if (translated === key && fallback) {
        return fallback;
      }
      return translated;
    }
    return fallback || key;
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    // Lógica de backend (POSTERGADA)
    // Aqui chamaria a API para enviar o email

    // Ação atual (placeholder):
    alert(`(Simulação) Enviando link de recuperação para: ${email}`);

    // Muda para o estado de "Sucesso"
    setIsSubmitted(true);
  };

  return (
    <div className="min-h-screen w-full bg-neutral-50 dark:bg-neutral-950 text-neutral-900 dark:text-neutral-100">
      <HeaderBar
        theme={theme}
        setTheme={setTheme}
        lang={lang}
        setLang={setLang}
        t={getT}
      />

      <main className="pt-20">
        <div className="flex flex-col items-center justify-center px-4 py-12 sm:px-6 lg:px-8">
          {/* Usando o mesmo tamanho de card do Login */}
          <div className="w-full max-w-sm">
            <div className="rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white/80 dark:bg-neutral-900/70 backdrop-blur-sm shadow-sm overflow-hidden">
              <div className="p-6 sm:p-8">
                {/* Renderização Condicional:
                  Se 'isSubmitted' for true, mostra a mensagem de sucesso.
                  Senão, mostra o formulário.
                */}

                {!isSubmitted ? (
                  // --- ESTADO 1: FORMULÁRIO ---
                  <>
                    <div className="flex flex-col items-center text-center mb-6">
                      <h2 className="text-2xl sm:text-3xl font-semibold tracking-tight">
                        {getT("forgot.title", "Recuperar Senha")}
                      </h2>
                      <p className="text-sm text-neutral-600 dark:text-neutral-400 mt-2">
                        {getT(
                          "forgot.subtitle",
                          "Insira seu e-mail e enviaremos um link para criar uma nova senha.",
                        )}
                      </p>
                    </div>

                    <form onSubmit={handleSubmit} className="space-y-4">
                      <div className="relative">
                        <span className="absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500">
                          <Mail className="w-5 h-5" />
                        </span>
                        <input
                          type="email"
                          id="email"
                          value={email}
                          onChange={(e) => setEmail(e.target.value)}
                          required
                          placeholder={getT("form.email", "Email")}
                          className="w-full pl-10 pr-4 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
                        />
                      </div>

                      <button
                        type="submit"
                        className="w-full inline-flex items-center justify-center rounded-lg bg-blue-600 px-4 py-2.5 text-sm font-medium text-white shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-neutral-900"
                      >
                        {getT("forgot.button", "Enviar link de recuperação")}
                      </button>
                    </form>
                  </>
                ) : (
                  // --- ESTADO 2: SUCESSO ---
                  <div className="flex flex-col items-center text-center py-8">
                    <MailCheck className="w-12 h-12 text-green-500 mb-4" />
                    <h2 className="text-2xl font-semibold tracking-tight">
                      {getT("forgot.success_title", "Link enviado!")}
                    </h2>
                    <p className="text-sm text-neutral-600 dark:text-neutral-400 mt-2">
                      {getT(
                        "forgot.success_text",
                        "Verifique sua caixa de entrada (e pasta de spam) nos próximos minutos.",
                      )}
                    </p>
                  </div>
                )}
              </div>

              {/* Link para Voltar ao Login (aparece nos dois estados) */}
              <div className="border-t border-neutral-200 dark:border-neutral-800 bg-neutral-50/50 dark:bg-neutral-900/30 px-6 py-4">
                <p className="text-center text-sm text-neutral-600 dark:text-neutral-400">
                  <Link
                    to="/login"
                    className="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-500 dark:hover:text-blue-400"
                  >
                    {getT(
                      "forgot.back_to_login",
                      "Lembrou a senha? Voltar para o Login",
                    )}
                  </Link>
                </p>
              </div>
            </div>
          </div>
        </div>
      </main>
    </div>
  );
}

export default ForgotPasswordPage;
</file>

<file path="client/src/pages/HomePage/HomePage.jsx">
import React, { useMemo, useState, useRef, useLayoutEffect } from "react";
import { motion } from "framer-motion";
import { Link } from "react-router-dom";
import { Star as StarIcon, Clock, MessageSquare, Users } from "lucide-react";

import { cx } from "../../utils/formatters";

import HeaderBar from "../../components/layout/HeaderBar/HeaderBar.jsx";
import SectionHeader from "../../components/layout/SectionHeader/SectionHeader.jsx";
import MediaCard from "../../components/ui/MediaCard/MediaCard.jsx";
import ReviewCard from "../../components/user/ReviewCard/ReviewCard.jsx";
import MediaBadge from "../../components/ui/MediaBadge/MediaBadge.jsx";
import AvatarStack from "../../components/ui/AvatarStack/AvatarStack.jsx";

// ==========================
// DADOS SIMULADOS (MOCK DATA)
// ==========================

const highlightsMock = [
  {
    id: "m1",
    type: "filme",
    title: "Duna: Parte Dois",
    year: 2024,
    score: 9.2,
  },
  { id: "g1", type: "jogo", title: "Baldur's Gate 3", year: 2023, score: 9.7 },
  { id: "b1", type: "livro", title: "O Nome do Vento", year: 2007, score: 9.3 },
  {
    id: "a1",
    type: "album",
    title: "To Pimp a Butterfly",
    year: 2015,
    score: 9.6,
  },
  { id: "m5", type: "filme", title: "Oppenheimer", year: 2023, score: 9.0 },
  { id: "g2", type: "jogo", title: "Elden Ring", year: 2022, score: 9.5 },
  { id: "b3", type: "livro", title: "1984", year: 1949, score: 9.2 },
  { id: "a3", type: "album", title: "Abbey Road", year: 1969, score: 9.4 },
];

const communityReviewsMock = [
  {
    id: "cr1",
    type: "filme",
    date: "2 min atrás",
    score: 9.5,
    title: "Oppenheimer",
    tags: ["tag.biografia", "tag.drama"],
    text: "A tensão construída apenas com diálogos é algo que só Nolan consegue fazer. Cillian Murphy entrega a atuação da vida.",
    user: { name: "Marina", handle: "@maris", avatar: "M" },
  },
  {
    id: "cr2",
    type: "livro",
    date: "15 min atrás",
    score: 8.0,
    title: "Torto Arado",
    tags: ["tag.drama", "tag.historia"],
    text: "Uma narrativa potente sobre ancestralidade e terra. O realismo mágico é sutil, mas golpeia com força.",
    user: { name: "Lucas", handle: "@lucas_l", avatar: "L" },
  },
  {
    id: "cr3",
    type: "jogo",
    date: "1 hora atrás",
    score: 10,
    title: "Elden Ring",
    tags: ["tag.rpg", "tag.fantasia"],
    text: "O mundo aberto definitivo. A sensação de descoberta é genuína, sem marcadores segurando sua mão a cada passo.",
    user: { name: "Dante", handle: "@dante_g", avatar: "D" },
  },
  {
    id: "cr4",
    type: "album",
    date: "3 horas atrás",
    score: 9.0,
    title: "Renaissance",
    tags: ["tag.pop", "tag.dance"],
    text: "Beyoncé celebra a cultura ballroom com uma produção impecável. As transições entre as faixas são arte pura.",
    user: { name: "Gui", handle: "@gui_music", avatar: "G" },
  },
];

// 3. Atividade dos Amigos (LISTA EXPANDIDA PARA TESTE DE SCROLL)
const friendsFeed = [
  {
    id: "f1",
    who: "Marina",
    handle: "@maris",
    type: "filme",
    item: "Oppenheimer",
    score: 9.0,
    when: "há 2 h",
    note: "Roteiro e montagem impecáveis. O som cria uma tensão contínua.",
  },
  {
    id: "f2",
    who: "Diego",
    handle: "@dgs",
    type: "album",
    item: "Random Access Memories",
    score: 9.0,
    when: "ontem",
    note: "Produção cristalina com arranjos que respiram.",
  },
  {
    id: "f3",
    who: "Lívia",
    handle: "@livz",
    type: "jogo",
    item: "Hades",
    score: 9.2,
    when: "há 3 dias",
    note: "Loop perfeito: a narrativa cresce a cada run sem cansar.",
  },
  {
    id: "f4",
    who: "Caio",
    handle: "@caiod",
    type: "livro",
    item: "Ensaio Sobre a Cegueira",
    score: 9.4,
    when: "há 1 semana",
    note: "Assustador de tão atual.",
  },
  {
    id: "f5",
    who: "Júlia",
    handle: "@ju",
    type: "filme",
    item: "Duna: Parte Dois",
    score: 9.1,
    when: "há 1 h",
    note: "Visual imersivo e trilha absurda.",
  },
  {
    id: "f6",
    who: "Rafa",
    handle: "@raf",
    type: "jogo",
    item: "Elden Ring",
    score: 9.7,
    when: "há 4 h",
    note: "Mundo vivo e desafiador.",
  },
  {
    id: "f7",
    who: "Nina",
    handle: "@nina",
    type: "album",
    item: "Anima",
    score: 8.6,
    when: "hoje",
    note: "Climas eletrônicos hipnóticos.",
  },
  {
    id: "f8",
    who: "Tom",
    handle: "@tom",
    type: "filme",
    item: "La La Land",
    score: 8.2,
    when: "há 9 h",
    note: "Encantador e melancólico.",
  },
  {
    id: "f9",
    who: "Bia",
    handle: "@bia",
    type: "livro",
    item: "1984",
    score: 9.5,
    when: "há 2 dias",
    note: "Releitura necessária. Cada vez mais atual.",
  },
  {
    id: "f10",
    who: "Pedro",
    handle: "@pedro",
    type: "jogo",
    item: "God of War",
    score: 9.8,
    when: "há 5 h",
    note: "Narrativa paternal incrível e combate visceral.",
  },
  {
    id: "f11",
    who: "Sofia",
    handle: "@sof",
    type: "filme",
    item: "Interestelar",
    score: 10,
    when: "ontem",
    note: "Chorei tudo de novo. A trilha do Hans Zimmer é outro nível.",
  },
  {
    id: "f12",
    who: "Iuri",
    handle: "@iuri",
    type: "album",
    item: "Dark Side of the Moon",
    score: 9.9,
    when: "há 3 dias",
    note: "O álbum perfeito para ouvir no escuro.",
  },
  {
    id: "f13",
    who: "Ana",
    handle: "@ana",
    type: "livro",
    item: "Dom Casmurro",
    score: 9.0,
    when: "há 1 semana",
    note: "Machado é gênio. A dúvida permanece.",
  },
  {
    id: "f14",
    who: "Leo",
    handle: "@leo",
    type: "jogo",
    item: "Cyberpunk 2077",
    score: 8.5,
    when: "hoje",
    note: "Night City é linda, mas ainda tem seus bugs.",
  },
  {
    id: "f15",
    who: "Carla",
    handle: "@carla",
    type: "filme",
    item: "Barbie",
    score: 8.0,
    when: "há 6 h",
    note: "Divertido e com uma crítica social bem colocada.",
  },
  {
    id: "f16",
    who: "Bruno",
    handle: "@bruno",
    type: "album",
    item: "Folklore",
    score: 9.2,
    when: "ontem",
    note: "Taylor Swift contando histórias como ninguém.",
  },
  {
    id: "f17",
    who: "Gabi",
    handle: "@gabi",
    type: "livro",
    item: "Harry Potter 1",
    score: 8.5,
    when: "há 2 dias",
    note: "Nostalgia pura relendo isso.",
  },
  {
    id: "f18",
    who: "Vitor",
    handle: "@vitor",
    type: "jogo",
    item: "Hollow Knight",
    score: 9.6,
    when: "há 4 dias",
    note: "Atmosfera e design de som impecáveis.",
  },
];

const clubs = [
  {
    id: "c1",
    name: "Clube Sci‑Fi",
    about: "Clássicos da ficção.",
    members: ["Ana", "Leo"],
    next: "27/10",
  },
  {
    id: "c2",
    name: "Latino‑América",
    about: "Romances do continente.",
    members: ["Helena", "Gus"],
    next: "02/11",
  },
  {
    id: "c3",
    name: "Indie Games",
    about: "Jogos independentes.",
    members: ["Nico", "Tom"],
    next: "10/11",
  },
];

export default function HomePage({ theme, setTheme, lang, setLang, t }) {
  const [filterHigh, setFilterHigh] = useState("todos");
  const [filterRecent, setFilterRecent] = useState("todos");

  const startRef = useRef(null);
  const endRef = useRef(null);
  const [spanHeight, setSpanHeight] = useState(null);

  const highlights = useMemo(() => {
    return highlightsMock
      .filter((i) => (filterHigh === "todos" ? true : i.type === filterHigh))
      .slice(0, 8);
  }, [filterHigh]);

  const communityReviews = useMemo(() => {
    return communityReviewsMock.filter((i) =>
      filterRecent === "todos" ? true : i.type === filterRecent,
    );
  }, [filterRecent]);

  // Recalcular altura da coluna esquerda
  useLayoutEffect(() => {
    if (typeof window === "undefined") return;
    const update = () => {
      const s = startRef.current?.getBoundingClientRect();
      const e = endRef.current?.getBoundingClientRect();
      if (!s || !e) return;
      setSpanHeight(e.bottom - s.top);
    };
    const timer = setTimeout(update, 50);
    window.addEventListener("resize", update);
    return () => clearTimeout(timer);
  }, [highlights, communityReviews]);

  const renderCategoryChips = (current, setter) => {
    const chips = [
      { k: "todos", label: t("filter.all") },
      { k: "filme", label: t("filter.movies") },
      { k: "livro", label: t("filter.books") },
      { k: "jogo", label: t("filter.games") },
      { k: "album", label: t("filter.albums") },
    ];
    return (
      <>
        {chips.map((f) => (
          <button
            key={f.k}
            onClick={() => setter(f.k)}
            className={cx(
              "px-3 py-1.5 rounded-full border",
              current === f.k
                ? "bg-neutral-900 text-white dark:bg-white dark:text-neutral-900 border-neutral-900 dark:border-white"
                : "border-neutral-200 dark:border-neutral-700 hover:bg-neutral-50 dark:hover:bg-neutral-800/60",
            )}
          >
            {f.label}
          </button>
        ))}
      </>
    );
  };

  return (
    <div className={cx(theme === "dark" ? "dark" : "", "font-sans")}>
      <div className="min-h-screen bg-neutral-50 text-neutral-900 dark:bg-neutral-950 dark:text-neutral-100">
        <HeaderBar
          theme={theme}
          setTheme={setTheme}
          lang={lang}
          setLang={setLang}
          t={t}
        />

        <main className="max-w-7xl mx-auto px-4 pt-24 pb-16">
          <section className="grid grid-cols-1 xl:grid-cols-12 gap-8 items-start">
            {/* COLUNA ESQUERDA */}
            <div className="xl:col-span-8 flex flex-col gap-10 min-h-0">
              {/* DESTAQUES */}
              <div ref={startRef}>
                <SectionHeader
                  title={t("section.highlights")}
                  icon={<StarIcon className="w-4 h-4" />}
                  href="#"
                  filters={renderCategoryChips(filterHigh, setFilterHigh)}
                  t={t}
                />
                <div className="grid grid-cols-2 md:grid-cols-3 xl:grid-cols-4 gap-3">
                  {highlights.map((m) => (
                    <Link to={`/media/${m.id}`} key={m.id}>
                      <MediaCard
                        item={m}
                        wide
                        badgeLabel={t(`badge.${m.type}`)}
                      />
                    </Link>
                  ))}
                </div>
              </div>

              {/* VOZES DA COMUNIDADE */}
              <div>
                <SectionHeader
                  title={t("section.communityReviews") || "Vozes da Comunidade"}
                  icon={<Clock className="w-4 h-4" />}
                  href="#"
                  filters={renderCategoryChips(filterRecent, setFilterRecent)}
                  t={t}
                />
                <div className="grid grid-cols-1 gap-4">
                  {communityReviews.map((review) => (
                    <ReviewCard key={review.id} review={review} t={t} />
                  ))}
                </div>
              </div>

              {/* CLUBES */}
              <div ref={endRef}>
                <SectionHeader
                  title={t("section.clubs")}
                  icon={<Users className="w-4 h-4" />}
                  href="/clubs"
                  t={t}
                />
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                  {clubs.map((c) => (
                    <motion.div
                      key={c.id}
                      whileHover={{ y: -2 }}
                      className="rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 p-4 flex flex-col gap-3"
                    >
                      <div className="h-24 rounded-xl bg-gradient-to-br from-sky-500/20 via-purple-500/10 to-emerald-500/10" />
                      <div>
                        <h4 className="font-semibold leading-tight">
                          {c.name}
                        </h4>
                        <p className="text-sm text-neutral-600 dark:text-neutral-300 line-clamp-2">
                          {c.about}
                        </p>
                      </div>
                      <div className="flex items-center justify-between mt-auto">
                        <AvatarStack names={c.members} />
                        <span className="text-xs text-neutral-500">
                          {t("label.next")}: {c.next}
                        </span>
                      </div>
                    </motion.div>
                  ))}
                </div>
              </div>
            </div>

            {/* COLUNA DIREITA (Atividade) */}
            <aside
              style={{ maxHeight: spanHeight ?? "100vh" }}
              className="xl:col-span-4 flex flex-col sticky top-24 min-h-0"
            >
              <SectionHeader
                title={t("section.friends")}
                icon={<MessageSquare className="w-4 h-4" />}
                t={t}
              />
              {/* mt-2 para alinhamento fino */}
              <div className="mt-2 rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 divide-y divide-neutral-200 dark:divide-neutral-800 flex-1 min-h-0 overflow-y-auto">
                {friendsFeed.map((f) => (
                  <div key={f.id} className="p-4 flex items-start gap-3">
                    <Link
                      to={`/profile/${f.handle.replace("@", "")}`}
                      className="shrink-0"
                    >
                      <div className="w-9 h-9 rounded-full bg-gradient-to-br from-neutral-200 to-neutral-400 dark:from-neutral-700 dark:to-neutral-600 flex items-center justify-center text-[11px] font-semibold text-neutral-700 dark:text-neutral-100">
                        {f.who.substring(0, 1)}
                      </div>
                    </Link>
                    <div className="min-w-0 flex-1">
                      <div className="flex items-center gap-2 text-sm">
                        <Link
                          to={`/profile/${f.handle.replace("@", "")}`}
                          className="font-medium truncate hover:underline"
                        >
                          {f.who}
                        </Link>
                        <span className="text-neutral-500 truncate">
                          {f.handle}
                        </span>
                        <MediaBadge
                          type={f.type}
                          compact
                          label={t(`badge.${f.type}`)}
                        />
                        <span className="ml-auto text-xs text-neutral-500 whitespace-nowrap">
                          {f.when}
                        </span>
                      </div>
                      <div className="mt-1 flex items-center gap-2">
                        <span className="text-sm font-medium truncate">
                          {f.item}
                        </span>
                        <span className="text-xs text-neutral-500">
                          ★ {f.score}
                        </span>
                      </div>
                      <p className="mt-1.5 text-sm text-neutral-700 dark:text-neutral-200 line-clamp-3">
                        {f.note}
                      </p>
                    </div>
                  </div>
                ))}
              </div>
            </aside>
          </section>
        </main>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/ListManagementPage/ListManagementPage.jsx">
import React, { useState, useEffect, useMemo } from "react";
import { useNavigate, Link, useSearchParams } from "react-router-dom";
import { List, Plus, Edit3, Trash2, Search, Save, X } from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import { useUserDatabase } from "../../contexts/UserDatabaseContext.jsx";
import { cx } from "../../utils/formatters";
import HeaderBar from "../../components/layout/HeaderBar/HeaderBar.jsx";
import MediaCard from "../../components/ui/MediaCard/MediaCard.jsx";

const LOGGED_IN_USER_HANDLE = "alexl";

// --- Hook para "hidratar" os itens da lista ---
function useHydratedItems(collectionItems, allFavorites) {
  return useMemo(() => {
    if (!collectionItems || !allFavorites) return [];
    return collectionItems
      .map((item) => allFavorites.find((fav) => fav.id === item.id))
      .filter(Boolean);
  }, [collectionItems, allFavorites]);
}

// --- Hook para buscar mídias (simulado) ---
function useMediaSearch(query) {
  const { mediaDatabase } = useUserDatabase();
  return useMemo(() => {
    if (query.length < 2) return [];
    const normalizedQuery = query.toLowerCase();
    return Object.values(mediaDatabase)
      .filter((media) => {
        const titlePT = media.title.PT?.toLowerCase() || "";
        const titleEN = media.title.EN?.toLowerCase() || "";
        const titleES = media.title.ES?.toLowerCase() || "";
        return (
          titlePT.includes(normalizedQuery) ||
          titleEN.includes(normalizedQuery) ||
          titleES.includes(normalizedQuery)
        );
      })
      .slice(0, 10);
  }, [query, mediaDatabase]);
}

// ==========================
// COMPONENTE PRINCIPAL
// ==========================
export default function ListManagementPage(props) {
  const { t } = props;
  const { db } = useUserDatabase();
  const { collections, favorites } = db[LOGGED_IN_USER_HANDLE] || {};

  // Leitura da URL para pegar o ID
  const [searchParams] = useSearchParams();
  const initialListId = searchParams.get("id");

  const [mode, setMode] = useState("viewing"); // 'viewing', 'creating', 'editing', 'deleting'
  const [selectedListId, setSelectedListId] = useState(null);

  // Efeito para selecionar a lista quando a página carrega
  useEffect(() => {
    if (initialListId) {
      setSelectedListId(initialListId);
    }
  }, [initialListId]);

  const selectedCollection = useMemo(
    () => collections?.find((c) => c.id === selectedListId),
    [collections, selectedListId],
  );

  const handleSetMode = (newMode) => {
    if (mode === newMode) {
      setMode("viewing");
    } else {
      setMode(newMode);
    }
    if (newMode === "creating") {
      setSelectedListId(null);
    }
  };

  const handleSelectList = (id) => {
    if (mode === "deleting") return;
    if (mode === "creating") {
      setMode("viewing");
    }
    setSelectedListId(id);
  };

  const onListDeleted = () => {
    setSelectedListId(null);
    setMode("viewing");
  };

  const renderMiddleColumn = () => {
    if (mode === "creating") {
      return (
        <ListForm
          t={t}
          isCreating={true}
          onListCreated={(newId) => {
            setMode("viewing");
            setSelectedListId(newId);
          }}
        />
      );
    }

    if (mode === "editing" && selectedCollection) {
      return <ListForm t={t} isCreating={false} list={selectedCollection} />;
    }

    if (selectedCollection) {
      return (
        <ListContentViewer
          key={selectedCollection.id}
          list={selectedCollection}
          allFavorites={favorites}
          t={t}
        />
      );
    }

    let promptKey = "list.select_prompt";
    if (mode === "editing") promptKey = "list.select_to_edit_prompt";
    if (mode === "deleting") promptKey = "list.select_to_delete_prompt";

    return (
      <div className="h-96 flex flex-col items-center justify-center rounded-2xl border-2 border-dashed border-neutral-300 dark:border-neutral-800 text-neutral-500 text-center px-4">
        <List className="w-10 h-10" />
        <p className="mt-2 text-lg font-medium">
          {t(promptKey, "Selecione uma lista")}
        </p>
        {mode === "viewing" && (
          <p>{t("list.or_create_prompt", "ou crie uma nova.")}</p>
        )}
      </div>
    );
  };

  return (
    <div className="min-h-screen w-full bg-neutral-100 dark:bg-neutral-950 text-neutral-900 dark:text-neutral-100">
      <HeaderBar {...props} />
      <main className="max-w-7xl mx-auto px-4 pt-24 pb-16">
        <div className="grid grid-cols-1 lg:grid-cols-6 gap-6">
          {/* Coluna Esquerda (Ações) */}
          <div className="lg:col-span-1">
            <h2 className="text-sm font-semibold text-neutral-500 uppercase tracking-wider mb-3">
              {t("list.actions_title", "Ações")}
            </h2>
            <nav className="flex flex-col gap-2">
              <ActionButton
                icon={<Plus />}
                label={t("list.create_new", "Criar Nova Lista")}
                isActive={mode === "creating"}
                onClick={() => handleSetMode("creating")}
              />
              <ActionButton
                icon={<Edit3 />}
                label={t("list.edit_mode", "Editar Listas")}
                isActive={mode === "editing"}
                onClick={() => handleSetMode("editing")}
              />
              <ActionButton
                icon={<Trash2 />}
                label={t("list.delete_mode", "Apagar Listas")}
                isActive={mode === "deleting"}
                isDestructive={true}
                onClick={() => handleSetMode("deleting")}
              />
            </nav>
          </div>

          {/* Coluna do Meio */}
          <div className="lg:col-span-4">{renderMiddleColumn()}</div>

          {/* Coluna da Direita */}
          <div className="lg:col-span-1">
            <h2 className="text-sm font-semibold text-neutral-500 uppercase tracking-wider mb-3">
              {t("section.collections", "Minhas Listas")}
            </h2>
            <div className="flex flex-col gap-2">
              {(collections || []).map((col) => (
                <HotlistButton
                  key={col.id}
                  list={col}
                  isSelected={selectedListId === col.id}
                  mode={mode}
                  onClick={() => handleSelectList(col.id)}
                  onListDeleted={onListDeleted}
                  t={t}
                />
              ))}
            </div>
          </div>
        </div>
      </main>
    </div>
  );
}

// --- Componentes Internos ---

function ActionButton({
  icon,
  label,
  isActive,
  onClick,
  isDestructive = false,
}) {
  const activeClasses = isDestructive
    ? "bg-red-100 dark:bg-red-900/40 text-red-700 dark:text-red-300"
    : "bg-neutral-200 dark:bg-neutral-800 text-neutral-900 dark:text-neutral-100";

  const inactiveClasses = isDestructive
    ? "text-red-600 dark:text-red-500 hover:bg-red-50 dark:hover:bg-red-900/30"
    : "text-neutral-600 dark:text-neutral-300 hover:bg-neutral-100/50 dark:hover:bg-neutral-900/50";

  return (
    <button
      onClick={onClick}
      className={cx(
        "w-full flex items-center gap-3 px-3.5 py-2.5 rounded-lg transition-colors text-sm font-medium",
        isActive ? activeClasses : inactiveClasses,
      )}
    >
      {React.cloneElement(icon, { className: "w-5 h-5" })}
      <span>{label}</span>
    </button>
  );
}

function HotlistButton({ list, isSelected, mode, onClick, onListDeleted, t }) {
  const { deleteCollection } = useUserDatabase();

  const handleClick = () => {
    if (mode === "deleting") {
      if (
        window.confirm(
          t("list.delete_confirm", "Tem certeza que quer apagar esta lista?"),
        )
      ) {
        deleteCollection("@" + LOGGED_IN_USER_HANDLE, list.id);
        onListDeleted();
      }
    } else {
      onClick();
    }
  };

  const modeClasses =
    mode === "editing"
      ? "ring-2 ring-blue-500/80 ring-offset-2 ring-offset-neutral-100 dark:ring-offset-neutral-950"
      : mode === "deleting"
        ? "ring-2 ring-red-500/80 ring-offset-2 ring-offset-neutral-100 dark:ring-offset-neutral-950"
        : "";

  return (
    <button
      onClick={handleClick}
      className={cx(
        "w-full text-left p-3 rounded-xl border transition-all",
        "bg-neutral-50/50 dark:bg-neutral-900/50",
        isSelected
          ? "border-neutral-400 dark:border-neutral-600 bg-white dark:bg-neutral-900"
          : "border-neutral-200/80 dark:border-neutral-800/60 hover:border-neutral-300 dark:hover:border-neutral-700",
        modeClasses,
      )}
    >
      <div className="flex items-center justify-between">
        <span className="font-semibold text-sm text-neutral-800 dark:text-neutral-100 line-clamp-1">
          {list.title}
        </span>
        <span className="text-xs text-neutral-500 flex-shrink-0 ml-2">
          {list.items.length}{" "}
          {list.items.length === 1
            ? t("list.item_singular", "item")
            : t("list.item_plural", "itens")}
        </span>
      </div>
      <p className="text-xs text-neutral-500 dark:text-neutral-400 mt-1 line-clamp-1">
        {list.description}
      </p>
    </button>
  );
}

// Conteúdo da Coluna do Meio (Modo "Viewing")
function ListContentViewer({ list, allFavorites, t }) {
  const navigate = useNavigate();
  const { addMediaToCollection, removeMediaFromCollection } = useUserDatabase();
  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");

  const hydratedItems = useHydratedItems(list.items, allFavorites);
  const searchResults = useMediaSearch(searchQuery);

  const handleAddItem = (mediaId) => {
    addMediaToCollection("@" + LOGGED_IN_USER_HANDLE, list.id, mediaId);
  };

  const handleRemoveItem = (mediaId) => {
    removeMediaFromCollection("@" + LOGGED_IN_USER_HANDLE, list.id, mediaId);
  };

  return (
    <div className="space-y-6">
      {/* Cabeçalho */}
      <div className="flex items-center justify-between gap-4">
        <h2 className="text-2xl font-bold">
          {t("list.current_items_title", "Itens na Lista")}
        </h2>

        {/* Botão + / Barra de Busca */}
        <div className="relative flex-1 flex justify-end">
          <AnimatePresence>
            {isSearchOpen ? (
              <motion.div
                key="search-bar"
                className="relative w-full"
                initial={{ maxWidth: "0px", opacity: 0 }}
                animate={{ maxWidth: "500px", opacity: 1 }}
                exit={{ maxWidth: "0px", opacity: 0 }}
                transition={{ type: "tween", duration: 0.3 }}
              >
                <div className="absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500">
                  <Search className="w-5 h-5" />
                </div>
                <input
                  type="text"
                  autoFocus
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  placeholder={t(
                    "list.search_placeholder",
                    "Procurar mídias para adicionar...",
                  )}
                  className="w-full pl-10 pr-10 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
                />
                <button
                  onClick={() => {
                    setIsSearchOpen(false);
                    setSearchQuery("");
                  }}
                  className="absolute right-3 top-1/2 -translate-y-1/2 text-neutral-500 hover:text-neutral-800 dark:hover:text-neutral-200"
                >
                  <X className="w-5 h-5" />
                </button>
              </motion.div>
            ) : (
              <motion.button
                key="add-button"
                onClick={() => setIsSearchOpen(true)}
                // CORREÇÃO: Classes padronizadas para o estilo Outline (igual ClubsDiscovery)
                className="w-10 h-10 flex items-center justify-center rounded-full border border-neutral-200 dark:border-neutral-800 bg-transparent text-neutral-500 hover:text-neutral-900 dark:text-neutral-400 dark:hover:text-neutral-100 hover:bg-neutral-100 dark:hover:bg-neutral-800 transition-colors"
                title={t("list.add_media", "Adicionar Mídias")}
                initial={{ scale: 0, opacity: 0 }}
                animate={{ scale: 1, opacity: 1 }}
                exit={{ scale: 0, opacity: 0 }}
              >
                <Plus className="w-5 h-5" strokeWidth={2} />
              </motion.button>
            )}
          </AnimatePresence>
        </div>
      </div>

      {/* Área de Resultados da Busca */}
      <AnimatePresence>
        {isSearchOpen && searchQuery.length > 1 && (
          <motion.div
            className="rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 p-4 overflow-hidden"
            initial={{ maxHeight: 0, opacity: 0 }}
            animate={{ maxHeight: "300px", opacity: 1 }}
            exit={{ maxHeight: 0, opacity: 0 }}
            transition={{ type: "tween", duration: 0.3 }}
          >
            <div className="overflow-y-auto max-h-[280px] grid grid-cols-1 sm:grid-cols-2 gap-4">
              {searchResults.length > 0 ? (
                searchResults.map((item) => (
                  <button
                    key={item.id}
                    onClick={() => handleAddItem(item.id)}
                    className="w-full flex items-center gap-3 p-2 rounded-lg hover:bg-neutral-100 dark:hover:bg-neutral-800/60"
                  >
                    <img
                      src={item.posterUrl}
                      alt=""
                      className="w-10 h-14 object-cover rounded-md flex-shrink-0"
                    />
                    <div className="text-left">
                      <p className="text-sm font-semibold line-clamp-1">
                        {item.title.PT || item.title.EN}
                      </p>
                      <p className="text-xs text-neutral-500">
                        {item.details?.Ano}
                      </p>
                    </div>
                  </button>
                ))
              ) : (
                <p className="text-sm text-neutral-500 text-center col-span-2 py-4">
                  {t("list.no_results", "Nenhum resultado encontrado.")}
                </p>
              )}
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Grelha de Itens Atuais */}
      {hydratedItems.length > 0 ? (
        <div className="flex flex-wrap gap-6">
          {hydratedItems.map((item) => (
            <MediaCard
              key={item.id}
              item={item}
              onClick={() => navigate(`/media/${item.id}`)}
              onRemove={handleRemoveItem}
            />
          ))}
        </div>
      ) : (
        <div className="text-center py-10 border-2 border-dashed border-neutral-300 dark:border-neutral-800 rounded-2xl">
          <p className="text-neutral-500 dark:text-neutral-400">
            {t(
              "list.empty_state_editor",
              "Adicione mídias usando a busca acima.",
            )}
          </p>
        </div>
      )}
    </div>
  );
}

function ListForm({ list, isCreating, onListCreated, t }) {
  const { createCollection, updateCollectionDetails } = useUserDatabase();
  const [title, setTitle] = useState(list?.title || "");
  const [description, setDescription] = useState(list?.description || "");

  useEffect(() => {
    setTitle(list?.title || "");
    setDescription(list?.description || "");
  }, [list]);

  const handleSaveDetails = (e) => {
    e.preventDefault();
    if (!title.trim()) {
      alert("O nome da lista não pode ficar em branco.");
      return;
    }

    if (isCreating) {
      const newId = createCollection(
        "@" + LOGGED_IN_USER_HANDLE,
        title,
        description,
      );
      onListCreated(newId);
    } else {
      updateCollectionDetails(
        "@" + LOGGED_IN_USER_HANDLE,
        list.id,
        title,
        description,
      );
      alert("Alterações salvas!");
    }
  };

  return (
    <div className="rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 overflow-hidden">
      <form onSubmit={handleSaveDetails}>
        <div className="p-6 sm:p-8 space-y-4">
          <h2 className="text-xl font-semibold">
            {isCreating
              ? t("list.create_new", "Criar Nova Lista")
              : t("list.edit_title", "Editar Lista")}
          </h2>
          <div>
            <label
              htmlFor="listTitle"
              className="block text-sm font-medium mb-1.5"
            >
              {t("list.form_name", "Nome")}
            </label>
            <input
              type="text"
              id="listTitle"
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder={t(
                "list.form_name_placeholder",
                "Ex: Clássicos da Fantasia",
              )}
              className="w-full px-3.5 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
            />
          </div>
          <div>
            <label
              htmlFor="listDesc"
              className="block text-sm font-medium mb-1.5"
            >
              {t("list.form_desc", "Descrição")}
            </label>
            <textarea
              id="listDesc"
              rows="3"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder={t(
                "list.form_desc_placeholder",
                "Uma breve descrição da sua lista...",
              )}
              className="w-full px-3.5 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
            ></textarea>
          </div>
        </div>
        <div className="px-6 py-4 sm:px-8 border-t border-neutral-200 dark:border-neutral-800 bg-neutral-50/50 dark:bg-neutral-900/30 flex justify-end">
          <button
            type="submit"
            className="inline-flex items-center justify-center gap-2 rounded-lg bg-blue-600 px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-blue-700 focus:outline-none"
          >
            <Save className="w-4 h-4" />
            {isCreating
              ? t("list.form_create_button", "Criar Lista")
              : t("list.form_save_button", "Salvar Alterações")}
          </button>
        </div>
      </form>
    </div>
  );
}
</file>

<file path="client/src/pages/ProfilePage/ProfilePage.jsx">
import React, { useEffect, useRef, useState } from "react";
import { useParams } from "react-router-dom";

import { cx } from "../../utils/formatters";
import { useUserProfileData } from "../../hooks/useUserProfileData.js";
import { useAuth } from "../../contexts/AuthContext.jsx";

import HeaderBar from "../../components/layout/HeaderBar/HeaderBar.jsx";
import ProfileHeader from "../../components/user/ProfileHeader/ProfileHeader.jsx";
import BadgesRibbon from "../../components/user/BadgesRibbon/BadgesRibbon.jsx";
import FavoritesSection from "../../components/user/FavoritesSection/FavoritesSection.jsx";
import ReviewsPanel from "../../components/user/ReviewsPanel/ReviewsPanel.jsx";

export default function ProfilePage({ theme, setTheme, lang, setLang, t }) {
  const { handle } = useParams();
  const { currentUser } = useAuth();

  // --- LÓGICA CORRIGIDA (CASE INSENSITIVE) ---
  // Verifica se o usuário existe, se a URL tem handle, e se são iguais (ignorando Alex vs alex)
  const isOwner =
    currentUser &&
    handle &&
    currentUser.handle.toLowerCase() === handle.toLowerCase();

  // Define qual perfil carregar.
  const dataHandle = handle || "maris";

  const { profile, badges, favorites, reviews, dynamicTags } =
    useUserProfileData(dataHandle);

  const leftRef = useRef(null);
  const [containerH, setContainerH] = useState(0);

  useEffect(() => {
    const measure = () => {
      const rect = leftRef.current?.getBoundingClientRect();
      if (rect) setContainerH(rect.height);
    };
    measure();
    const ro = new ResizeObserver(measure);
    if (leftRef.current) ro.observe(leftRef.current);
    window.addEventListener("resize", measure);
    return () => {
      window.removeEventListener("resize", measure);
      ro.disconnect();
    };
  }, []);

  return (
    <div className={cx(theme === "dark" ? "dark" : "", "font-sans")}>
      <div className="min-h-screen bg-neutral-50 text-neutral-900 dark:bg-neutral-950 dark:text-neutral-100">
        <HeaderBar
          theme={theme}
          setTheme={setTheme}
          lang={lang}
          setLang={setLang}
          t={t}
        />

        <main className="max-w-7xl mx-auto px-4 pt-24 pb-16">
          <ProfileHeader profile={profile} tags={dynamicTags} t={t} />
          <div className="h-8" />

          {/* O botão só aparecerá se isOwner for estritamente verdadeiro */}
          <BadgesRibbon
            badges={badges}
            t={t}
            handle={dataHandle}
            isOwner={isOwner}
          />

          <div className="h-8" />

          <section className="grid grid-cols-1 lg:grid-cols-12 gap-6 items-start min-h-0">
            <div ref={leftRef} className="lg:col-span-7 min-h-0">
              <FavoritesSection items={favorites} t={t} handle={dataHandle} />
            </div>
            <div className="lg:col-span-5 min-h-0">
              <ReviewsPanel
                reviews={reviews}
                t={t}
                containerHeight={containerH}
                handle={dataHandle}
              />
            </div>
          </section>
        </main>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/ResetPasswordPage/ResetPasswordPage.jsx">
import React, { useState } from "react";
// useNavigate para redirecionar após o sucesso, Link para o botão de sucesso
import { useNavigate, Link } from "react-router-dom";
// Ícones
import { Lock, CheckCircle } from "lucide-react";
import HeaderBar from "../../components/layout/HeaderBar/HeaderBar.jsx";

// Página de Resetar Senha (acessada pelo link do email)
function ResetPasswordPage({ theme, setTheme, lang, setLang, t }) {
  const [newPassword, setNewPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  // Estado para controlar a exibição do formulário ou da mensagem de sucesso
  const [isSubmitted, setIsSubmitted] = useState(false);

  const navigate = useNavigate();

  // Função 'safeT' (get translation)
  const getT = (key, fallback) => {
    if (typeof t === "function") {
      const translated = t(key);
      if (translated === key && fallback) {
        return fallback;
      }
      return translated;
    }
    return fallback || key;
  };

  const handleSubmit = (e) => {
    e.preventDefault();

    // 1. Validação de senha (client-side)
    if (newPassword !== confirmPassword) {
      alert(getT("alert.password_mismatch", "As senhas não conferem!"));
      return;
    }

    // 2. Lógica de backend (POSTERGADA)
    // Aqui chamaria a API (POST /api/reset-password) com:
    // - o 'token' (que viria da URL, ex: /reset-password?token=...)
    // - a 'newPassword'

    // Ação atual (placeholder):
    alert(`(Simulação) Senha redefinida com sucesso para: ${newPassword}`);

    // 3. Muda para o estado de "Sucesso"
    setIsSubmitted(true);
  };

  return (
    <div className="min-h-screen w-full bg-neutral-50 dark:bg-neutral-950 text-neutral-900 dark:text-neutral-100">
      {/* Esta página não tem o HeaderBar, pois é uma página isolada
          acessada por um link externo (email). Isso é uma prática
          comum para evitar distrações. Se preferir, podemos adicioná-lo.
          Vamos testar sem ele primeiro.
      */}
      {/* <HeaderBar
        theme={theme}
        setTheme={setTheme}
        lang={lang}
        setLang={setLang}
        t={getT}
      />
      */}

      {/* Centraliza o card na tela */}
      <main className="pt-20">
        <div className="flex flex-col items-center justify-center px-4 py-12 sm:px-6 lg:px-8">
          <div className="w-full max-w-sm">
            {/* Logo acima do card */}
            <div className="flex justify-center mb-4">
              <Link to="/" className="font-semibold text-lg">
                Mazarbul
              </Link>
            </div>

            <div className="rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white/80 dark:bg-neutral-900/70 backdrop-blur-sm shadow-sm overflow-hidden">
              <div className="p-6 sm:p-8">
                {!isSubmitted ? (
                  // --- ESTADO 1: FORMULÁRIO ---
                  <>
                    <div className="flex flex-col items-center text-center mb-6">
                      <h2 className="text-2xl sm:text-3xl font-semibold tracking-tight">
                        {getT("reset.title", "Crie sua nova senha")}
                      </h2>
                      <p className="text-sm text-neutral-600 dark:text-neutral-400 mt-2">
                        {getT(
                          "reset.subtitle",
                          "Quase lá! Insira sua nova senha abaixo.",
                        )}
                      </p>
                    </div>

                    <form onSubmit={handleSubmit} className="space-y-4">
                      {/* Nova Senha */}
                      <div className="relative">
                        <span className="absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500">
                          <Lock className="w-5 h-5" />
                        </span>
                        <input
                          type="password"
                          id="newPassword"
                          value={newPassword}
                          onChange={(e) => setNewPassword(e.target.value)}
                          required
                          placeholder={getT(
                            "settings.account.password.new",
                            "Nova Senha",
                          )}
                          className="w-full pl-10 pr-4 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
                        />
                      </div>

                      {/* Confirmar Nova Senha */}
                      <div className="relative">
                        <span className="absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500">
                          <Lock className="w-5 h-5" />
                        </span>
                        <input
                          type="password"
                          id="confirmPassword"
                          value={confirmPassword}
                          onChange={(e) => setConfirmPassword(e.target.value)}
                          required
                          placeholder={getT(
                            "settings.account.password.confirm",
                            "Confirmar Nova Senha",
                          )}
                          className="w-full pl-10 pr-4 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
                        />
                      </div>

                      <button
                        type="submit"
                        className="w-full inline-flex items-center justify-center rounded-lg bg-blue-600 px-4 py-2.5 text-sm font-medium text-white shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-neutral-900"
                      >
                        {getT("reset.button", "Salvar Nova Senha")}
                      </button>
                    </form>
                  </>
                ) : (
                  // --- ESTADO 2: SUCESSO ---
                  <div className="flex flex-col items-center text-center py-8">
                    <CheckCircle className="w-12 h-12 text-green-500 mb-4" />
                    <h2 className="text-2xl font-semibold tracking-tight">
                      {getT("reset.success.title", "Senha Redefinida!")}
                    </h2>
                    <p className="text-sm text-neutral-600 dark:text-neutral-400 mt-2">
                      {getT(
                        "reset.success.subtitle",
                        "Sua senha foi alterada com sucesso.",
                      )}
                    </p>
                    <button
                      type="button"
                      onClick={() => navigate("/login")}
                      className="mt-6 w-full inline-flex items-center justify-center rounded-lg bg-blue-600 px-4 py-2.5 text-sm font-medium text-white shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-neutral-900"
                    >
                      {getT("reset.success.button", "Ir para o Login")}
                    </button>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      </main>
    </div>
  );
}

export default ResetPasswordPage;
</file>

<file path="client/src/pages/ReviewsPage/ReviewsPage.jsx">
import React from "react";
import { useParams, useNavigate } from "react-router-dom";

// Importando componentes, hooks e utilitários
import { cx } from "../../utils/formatters";
import { useUserProfileData } from "../../hooks/useUserProfileData.js";
import HeaderBar from "../../components/layout/HeaderBar/HeaderBar.jsx";
import ReviewCard from "../../components/user/ReviewCard/ReviewCard.jsx";

// ==========================
// MOCK DE AUTENTICAÇÃO
const LOGGED_IN_USER_HANDLE = "alexl";
// ==========================

// ==========================
// Componente da Página de Reviews
// ==========================
export default function ReviewsPage({ theme, setTheme, lang, setLang, t }) {
  const { handle } = useParams();
  const navigate = useNavigate();

  // Busca os dados do perfil específico usando o handle da URL
  const { profile, reviews } = useUserProfileData(handle);

  // Determina se o utilizador logado é o dono do perfil
  const isOwner = profile?.handle === `@${LOGGED_IN_USER_HANDLE}`;

  if (!profile || !reviews) {
    return (
      <div className="text-center py-20">
        Utilizador não encontrado ou sem reviews.
      </div>
    );
  }

  // Lógica de Título Dinâmico
  const pageTitle = isOwner ? (
    t("reviews.my_title") // "Minhas resenhas"
  ) : (
    <>
      {t("reviews.title_prefix")} {/* "Resenhas de" */}
      <span>{profile.name}</span> {/* "Marina Silva" */}
    </>
  );

  return (
    <div className={cx(theme === "dark" ? "dark" : "", "font-sans")}>
      <div className="min-h-screen bg-neutral-50 text-neutral-900 dark:bg-neutral-950 dark:text-neutral-100">
        <HeaderBar
          theme={theme}
          setTheme={setTheme}
          lang={lang}
          setLang={setLang}
          t={t}
        />

        <main className="max-w-7xl mx-auto px-4 pt-24 pb-16 flex flex-col gap-8">
          {/* Título com a fonte corrigida e lógica condicional */}
          <h1 className="text-3xl font-bold tracking-tight text-neutral-800 dark:text-neutral-100">
            {pageTitle}
          </h1>

          {/* Lista de Reviews */}
          {reviews.length > 0 ? (
            <div className="flex flex-col gap-4">
              {reviews.map((review) => (
                <div
                  key={review.id}
                  className="rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900"
                >
                  <ReviewCard review={review} t={t} />
                </div>
              ))}
            </div>
          ) : (
            <div className="text-center py-20 border-2 border-dashed border-neutral-200 dark:border-neutral-800 rounded-2xl">
              <p className="text-neutral-500 dark:text-neutral-400">
                Este utilizador ainda não escreveu reviews.
              </p>
            </div>
          )}
        </main>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/SettingsPage/SettingsPage.jsx">
import React, { useState, useRef, useEffect } from "react";
import { Link } from "react-router-dom";
import HeaderBar from "../../components/layout/HeaderBar/HeaderBar.jsx";
// Ícones
import {
  User,
  Shield,
  SlidersHorizontal,
  AtSign,
  Camera,
  Mail,
  KeyRound,
  Bell,
  Trash2,
} from "lucide-react";

// IMPORTAÇÕES DE CONTEXTO (NOVO)
import { useUserDatabase } from "../../contexts/UserDatabaseContext.jsx";
import { useAuth } from "../../contexts/AuthContext.jsx";

// --- COMPONENTE DE TOGGLE REUTILIZÁVEL ---
function ToggleSwitch({ enabled, setEnabled, "aria-label": ariaLabel }) {
  return (
    <button
      type="button"
      role="switch"
      aria-checked={enabled}
      aria-label={ariaLabel}
      onClick={() => setEnabled(!enabled)}
      className={`relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out ${
        enabled ? "bg-blue-600" : "bg-neutral-200 dark:bg-neutral-700"
      } focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-neutral-900`}
    >
      <span
        aria-hidden="true"
        className={`inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out ${
          enabled ? "translate-x-5" : "translate-x-0"
        }`}
      />
    </button>
  );
}

/**
 * SectionRow
 * Linha padrão para os blocos 2 e 3 de cada aba.
 */
function SectionRow({ title, description, right, titleId }) {
  return (
    <div className="py-5" aria-labelledby={titleId}>
      <div className="grid grid-cols-1 sm:grid-cols-12 gap-4 items-center">
        <div className="sm:col-span-9">
          <h3 id={titleId} className="text-lg font-semibold">
            {title}
          </h3>
          {description ? (
            <p className="text-sm text-neutral-600 dark:text-neutral-400 mt-1">
              {description}
            </p>
          ) : null}
        </div>
        <div className="sm:col-span-3 justify-self-start sm:justify-self-end self-center">
          {right}
        </div>
      </div>
    </div>
  );
}

// --- COMPONENTE PRINCIPAL DA PÁGINA ---
function SettingsPage({ theme, setTheme, lang, setLang, t }) {
  const [activeSection, setActiveSection] = useState("profile");

  const getT = (key, fallback) => {
    if (typeof t === "function") {
      const translated = t(key);
      if (translated === key && fallback) {
        return fallback;
      }
      return translated;
    }
    return fallback || key;
  };

  return (
    <div className="min-h-screen w-full bg-neutral-50 dark:bg-neutral-950 text-neutral-900 dark:text-neutral-100">
      <HeaderBar
        theme={theme}
        setTheme={setTheme}
        lang={lang}
        setLang={setLang}
        t={getT}
      />

      <main className="pt-28 max-w-5xl mx-auto px-4 pb-16">
        <h1 className="text-3xl font-semibold tracking-tight">
          {getT("settings.title", "Configurações")}
        </h1>

        <div className="grid grid-cols-1 md:grid-cols-4 gap-8 mt-8">
          {/* Coluna Esquerda: Menu */}
          <aside className="md:col-span-1">
            <nav className="flex flex-col space-y-1">
              <SettingsMenuButton
                label={getT("settings.nav.profile", "Perfil")}
                icon={<User className="w-5 h-5" />}
                isActive={activeSection === "profile"}
                onClick={() => setActiveSection("profile")}
              />
              <SettingsMenuButton
                label={getT("settings.nav.account", "Conta")}
                icon={<Shield className="w-5 h-5" />}
                isActive={activeSection === "account"}
                onClick={() => setActiveSection("account")}
              />
              <SettingsMenuButton
                label={getT("settings.nav.preferences", "Preferências")}
                icon={<SlidersHorizontal className="w-5 h-5" />}
                isActive={activeSection === "preferences"}
                onClick={() => setActiveSection("preferences")}
              />
            </nav>
          </aside>

          {/* Coluna Direita: Conteúdo */}
          <section className="md:col-span-3">
            {activeSection === "profile" && <ProfileSection getT={getT} />}
            {activeSection === "account" && <AccountSection getT={getT} />}
            {activeSection === "preferences" && (
              <PreferencesSection getT={getT} />
            )}
          </section>
        </div>
      </main>
    </div>
  );
}

// --- Botão de Menu reutilizável ---
function SettingsMenuButton({ label, icon, isActive, onClick }) {
  const activeClasses =
    "bg-neutral-100 dark:bg-neutral-800 text-neutral-900 dark:text-neutral-100";
  const inactiveClasses =
    "hover:bg-neutral-100/50 dark:hover:bg-neutral-800/50 text-neutral-600 dark:text-neutral-300";

  return (
    <button
      onClick={onClick}
      className={`flex w-full items-center gap-3 px-3 py-2.5 rounded-lg text-sm font-medium transition-colors ${
        isActive ? activeClasses : inactiveClasses
      }`}
    >
      {icon}
      <span>{label}</span>
    </button>
  );
}

// --- Seção 1: Perfil (CONECTADA) ---
function ProfileSection({ getT }) {
  const fileInputRef = useRef(null);
  const { currentUser } = useAuth(); // Dados Reais
  const { updateUserProfile } = useUserDatabase(); // Função Real

  // Estados iniciais vazios (preenchidos pelo useEffect)
  const [avatar, setAvatar] = useState("");
  const [firstname, setFirstname] = useState("");
  const [lastname, setLastname] = useState("");
  const [bio, setBio] = useState("");
  const [saveState, setSaveState] = useState("idle");

  // Carrega dados reais quando a página monta ou usuário muda
  useEffect(() => {
    if (currentUser) {
      setAvatar(
        currentUser.avatarUrl ||
          "https://placehold.co/128x128/E0E0E0/333333?text=A",
      );

      // Separa Nome e Sobrenome (supondo que no banco é "Alex Lima")
      const names = (currentUser.name || "").split(" ");
      setFirstname(names[0] || "");
      setLastname(names.slice(1).join(" ") || "");

      setBio(currentUser.bio || "");
    }
  }, [currentUser]);

  const handleAvatarChange = (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        setAvatar(reader.result);
      };
      reader.readAsDataURL(file);
    }
  };

  const handleSaveProfile = (e) => {
    e.preventDefault();
    setSaveState("saving");

    // Simula um pequeno delay para feedback visual, mas salva de verdade
    setTimeout(() => {
      updateUserProfile(currentUser.handle, {
        name: `${firstname} ${lastname}`.trim(),
        bio: bio,
        avatarUrl: avatar,
      });
      setSaveState("saved");
      setTimeout(() => setSaveState("idle"), 2500);
    }, 600);
  };

  const getButtonText = (keyIdle, keySaving, keySaved) => {
    if (saveState === "saving") return getT(keySaving, "Salvando...");
    if (saveState === "saved") return getT(keySaved, "Salvo!");
    return getT(keyIdle, "Salvar");
  };

  return (
    <div className="rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 overflow-hidden">
      {/* Header */}
      <div className="px-6 py-5 sm:px-8 border-b border-neutral-200 dark:border-neutral-800">
        <h2 className="text-lg font-semibold">
          {getT("settings.profile.title", "Perfil Público")}
        </h2>
        <p className="text-sm text-neutral-600 dark:text-neutral-400 mt-1">
          {getT(
            "settings.profile.subtitle",
            "Como você aparece para outros no Mazarbul.",
          )}
        </p>
      </div>

      {/* Formulário */}
      <form onSubmit={handleSaveProfile}>
        <div className="p-6 sm:p-8 space-y-6">
          {/* Avatar */}
          <div>
            <label className="block text-sm font-medium mb-1.5">
              {getT("settings.profile.avatar", "Foto de Perfil")}
            </label>
            <div className="flex items-center gap-4 mt-1.5">
              <img
                src={avatar}
                alt="Avatar"
                className="w-16 h-16 rounded-full object-cover"
              />
              <input
                type="file"
                ref={fileInputRef}
                hidden
                accept="image/png, image/jpeg"
                onChange={handleAvatarChange}
              />
              <div className="flex items-center gap-2">
                <button
                  type="button"
                  onClick={() => fileInputRef.current.click()}
                  className="flex items-center gap-1.5 text-sm font-medium px-3 py-1.5 rounded-lg border border-neutral-300 dark:border-neutral-700 hover:bg-neutral-50 dark:hover:bg-neutral-800"
                >
                  <Camera className="w-4 h-4" />
                  {getT("settings.profile.avatar.change", "Mudar foto")}
                </button>
                <button
                  type="button"
                  onClick={() =>
                    setAvatar(
                      "https://placehold.co/128x128/E0E0E0/333333?text=A",
                    )
                  }
                  className="text-sm font-medium text-red-600 dark:text-red-500 px-3 py-1.5 rounded-lg hover:bg-red-50 dark:hover:bg-red-900/30"
                >
                  {getT("settings.profile.avatar.remove", "Remover")}
                </button>
              </div>
            </div>
          </div>

          {/* Nome e Sobrenome */}
          <div className="flex flex-col sm:flex-row gap-4">
            <div className="w-full">
              <label
                htmlFor="firstname"
                className="block text-sm font-medium mb-1.5"
              >
                {getT("settings.profile.firstname", "Nome")}
              </label>
              <input
                type="text"
                id="firstname"
                value={firstname}
                onChange={(e) => setFirstname(e.target.value)}
                className="w-full px-3.5 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
              />
            </div>
            <div className="w-full">
              <label
                htmlFor="lastname"
                className="block text-sm font-medium mb-1.5"
              >
                {getT("settings.profile.lastname", "Sobrenome")}
              </label>
              <input
                type="text"
                id="lastname"
                value={lastname}
                onChange={(e) => setLastname(e.target.value)}
                className="w-full px-3.5 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
              />
            </div>
          </div>

          {/* @username */}
          <div>
            <label
              htmlFor="username"
              className="block text-sm font-medium mb-1.5"
            >
              {getT("settings.profile.username", "Nome de usuário (@)")}
            </label>
            <div className="relative">
              <span className="absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500">
                <AtSign className="w-5 h-5" />
              </span>
              <input
                type="text"
                id="username"
                value={currentUser?.handle || "@alexl"} // Valor real
                readOnly
                disabled
                className="w-full pl-10 pr-4 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-neutral-100 dark:bg-neutral-800/50 text-neutral-500 dark:text-neutral-400 cursor-not-allowed text-sm"
              />
            </div>
            <p className="text-xs text-neutral-500 dark:text-neutral-400 mt-1.5 px-1">
              {getT(
                "settings.profile.username.locked",
                "Nomes de usuário não podem ser alterados.",
              )}
            </p>
          </div>

          {/* Bio */}
          <div>
            <label htmlFor="bio" className="block text-sm font-medium mb-1.5">
              {getT("settings.profile.bio", "Sua Bio")}
            </label>
            <textarea
              id="bio"
              rows="4"
              value={bio}
              onChange={(e) => setBio(e.target.value)}
              placeholder={getT(
                "settings.profile.bio.placeholder",
                "Escreva um pouco sobre você...",
              )}
              className="w-full px-3.5 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
            ></textarea>
          </div>
        </div>

        {/* Footer */}
        <div className="px-6 py-4 sm:px-8 border-t border-neutral-200 dark:border-neutral-800 bg-neutral-50/50 dark:bg-neutral-900/30 flex justify-end">
          <button
            type="submit"
            disabled={saveState === "saving"}
            className={`inline-flex items-center justify-center rounded-lg px-4 py-2 text-sm font-medium text-white shadow-sm transition-colors ${
              saveState === "saved"
                ? "bg-green-600"
                : "bg-blue-600 hover:bg-blue-700"
            } focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-neutral-900 disabled:opacity-50`}
          >
            {getButtonText(
              "settings.profile.save_button",
              "settings.profile.save_button.saving",
              "settings.profile.save_button.saved",
            )}
          </button>
        </div>
      </form>
    </div>
  );
}

// --- Seção 2: Conta (Mantida igual, mas conectável futuramente) ---
function AccountSection({ getT }) {
  const email = "alexl@exemplo.com";
  const [currentPassword, setCurrentPassword] = useState("");
  const [newPassword, setNewPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");

  const handlePasswordSave = (e) => {
    e.preventDefault();
    alert("Simulação: Senha alterada com sucesso!");
    setCurrentPassword("");
    setNewPassword("");
    setConfirmPassword("");
  };

  const handleDeleteAccount = () => {
    alert("Simulação: Conta excluída.");
  };

  return (
    <div className="space-y-6">
      {/* Card de Email e Senha */}
      <div className="rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 overflow-hidden">
        {/* Header */}
        <div className="px-6 py-5 sm:px-8 border-b border-neutral-200 dark:border-neutral-800">
          <h2 className="text-lg font-semibold">
            {getT("settings.account.title", "Conta")}
          </h2>
          <p className="text-sm text-neutral-600 dark:text-neutral-400 mt-1">
            {getT(
              "settings.account.subtitle",
              "Gerencie suas informações de login e segurança.",
            )}
          </p>
        </div>

        {/* Conteúdo */}
        <div className="px-6 sm:px-8 py-0">
          {/* Email */}
          <SectionRow
            title={getT("settings.account.email", "Email")}
            description={
              <>
                {getT(
                  "settings.account.email.subtitle",
                  "Seu email de login é",
                )}{" "}
                <strong>{email}</strong>
              </>
            }
            titleId="account-email-title"
            right={
              <button
                type="button"
                onClick={() =>
                  alert("Fluxo de mudança de email (backend postergado)")
                }
                className="h-9 inline-flex items-center justify-center text-sm font-medium px-3.5 rounded-lg border border-neutral-300 dark:border-neutral-700 hover:bg-neutral-50 dark:hover:bg-neutral-800"
              >
                {getT("settings.account.email.change_button", "Mudar Email")}
              </button>
            }
          />

          <div className="border-b border-neutral-200 dark:border-neutral-800 -mx-6 sm:-mx-8"></div>

          {/* Mudar Senha */}
          <div className="py-5">
            <h3 className="text-lg font-semibold">
              {getT("settings.account.password.subtitle", "Mudar Senha")}
            </h3>
            <form onSubmit={handlePasswordSave} className="space-y-4 mt-4">
              <div>
                <label
                  htmlFor="currentPassword"
                  className="block text-sm font-medium mb-1.5"
                >
                  {getT("settings.account.password.current", "Senha Atual")}
                </label>
                <input
                  type="password"
                  id="currentPassword"
                  value={currentPassword}
                  onChange={(e) => setCurrentPassword(e.target.value)}
                  className="w-full sm:max-w-md px-3.5 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
                />
              </div>

              <div>
                <label
                  htmlFor="newPassword"
                  className="block text-sm font-medium mb-1.5"
                >
                  {getT("settings.account.password.new", "Nova Senha")}
                </label>
                <input
                  type="password"
                  id="newPassword"
                  value={newPassword}
                  onChange={(e) => setNewPassword(e.target.value)}
                  className="w-full sm:max-w-md px-3.5 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
                />
              </div>

              <div>
                <label
                  htmlFor="confirmPassword"
                  className="block text-sm font-medium mb-1.5"
                >
                  {getT(
                    "settings.account.password.confirm",
                    "Confirmar Nova Senha",
                  )}
                </label>
                <input
                  type="password"
                  id="confirmPassword"
                  value={confirmPassword}
                  onChange={(e) => setConfirmPassword(e.target.value)}
                  className="w-full sm:max-w-md px-3.5 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
                />
              </div>

              <div className="pt-2">
                <button
                  type="submit"
                  className="inline-flex items-center justify-center rounded-lg bg-blue-600 px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-neutral-900"
                >
                  {getT(
                    "settings.account.password.save_button",
                    "Salvar Nova Senha",
                  )}
                </button>
              </div>
            </form>
          </div>
        </div>
      </div>

      {/* Zona de Perigo */}
      <div className="rounded-2xl border border-red-500/50 dark:border-red-500/30 bg-white dark:bg-neutral-900 overflow-hidden">
        <div className="p-6 sm:p-8">
          <h3 className="text-lg font-semibold text-red-600 dark:text-red-500">
            {getT("settings.account.danger_zone", "Zona de Perigo")}
          </h3>
          <p className="text-sm text-neutral-600 dark:text-neutral-400 mt-1">
            {getT(
              "settings.account.delete.text",
              "Esta ação é permanente e irreversível.",
            )}
          </p>
          <button
            type="button"
            onClick={handleDeleteAccount}
            className="mt-4 inline-flex items-center gap-2 justify-center rounded-lg bg-red-600 px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 dark:focus:ring-offset-neutral-900"
          >
            <Trash2 className="w-4 h-4" />
            {getT("settings.account.delete.button", "Excluir minha conta")}
          </button>
        </div>
      </div>
    </div>
  );
}

// --- Seção 3: Preferências (Mantida igual, sem botões extras) ---
function PreferencesSection({ getT }) {
  const [isPrivate, setIsPrivate] = useState(false);
  const [emailNotifications, setEmailNotifications] = useState(true);
  const [saveState, setSaveState] = useState("idle");

  const handleSavePrefs = (e) => {
    e.preventDefault();
    setSaveState("saving");
    setTimeout(() => {
      setSaveState("saved");
      setTimeout(() => setSaveState("idle"), 2500);
    }, 1500);
  };

  const getButtonText = (keyIdle, keySaving, keySaved) => {
    if (saveState === "saving") return getT(keySaving, "Salvando...");
    if (saveState === "saved") return getT(keySaved, "Salvo!");
    return getT(keyIdle, "Salvar");
  };

  return (
    <form
      onSubmit={handleSavePrefs}
      className="rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white dark:bg-neutral-900 overflow-hidden"
    >
      {/* Header */}
      <div className="px-6 py-5 sm:px-8 border-b border-neutral-200 dark:border-neutral-800">
        <h2 className="text-lg font-semibold">
          {getT("settings.preferences.title", "Preferências")}
        </h2>
        <p className="text-sm text-neutral-600 dark:text-neutral-400 mt-1">
          {getT(
            "settings.preferences.subtitle",
            "Controle a privacidade do seu perfil e notificações.",
          )}
        </p>
      </div>

      {/* Conteúdo */}
      <div className="px-6 sm:px-8 py-0">
        <SectionRow
          title={getT("settings.preferences.privacy", "Privacidade")}
          description={getT(
            "settings.preferences.privacy.private_profile.desc",
            "Se ativado, seu perfil e atividades só serão visíveis para você.",
          )}
          titleId="preferences-privacy-title"
          right={
            <ToggleSwitch
              enabled={isPrivate}
              setEnabled={setIsPrivate}
              aria-label={getT(
                "settings.preferences.privacy.private_profile",
                "Perfil Privado",
              )}
            />
          }
        />

        <div className="border-b border-neutral-200 dark:border-neutral-800 -mx-6 sm:-mx-8"></div>

        <SectionRow
          title={getT("settings.preferences.notifications", "Notificações")}
          description={getT(
            "settings.preferences.notifications.email.desc",
            "Receber emails quando alguém seguir você ou comentar em suas reviews.",
          )}
          titleId="preferences-notifications-title"
          right={
            <ToggleSwitch
              enabled={emailNotifications}
              setEnabled={setEmailNotifications}
              aria-label={getT(
                "settings.preferences.notifications.email.title",
                "Notificações por Email",
              )}
            />
          }
        />
      </div>

      {/* Footer */}
      <div className="px-6 py-4 sm:px-8 border-t border-neutral-200 dark:border-neutral-800 bg-neutral-50/50 dark:bg-neutral-900/30 flex justify-end">
        <button
          type="submit"
          disabled={saveState === "saving"}
          className={`inline-flex items-center justify-center rounded-lg px-4 py-2 text-sm font-medium text-white shadow-sm transition-colors ${
            saveState === "saved"
              ? "bg-green-600"
              : "bg-blue-600 hover:bg-blue-700"
          } focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-neutral-900 disabled:opacity-50`}
        >
          {getButtonText(
            "settings.preferences.save_button",
            "settings.profile.save_button.saving",
            "settings.profile.save_button.saved",
          )}
        </button>
      </div>
    </form>
  );
}

export default SettingsPage;
</file>

<file path="client/src/services/api.js">
import axios from 'axios';

const api = axios.create({
    baseURL: 'http://localhost:3000/api', // Endereço do nosso Backend
});

// Interceptor: Antes de cada requisição, veja se tem token e anexe
api.interceptors.request.use((config) => {
    const token = localStorage.getItem('@Mazarbul:token');

    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }

    return config;
});

export default api;
</file>

<file path="client/src/styles/main.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="client/src/utils/formatters.js">
// Função para juntar nomes de classes de CSS de forma condicional.
// Ex: cx('classe1', false, 'classe2') retorna "classe1 classe2"
export const cx = (...classes) => classes.filter(Boolean).join(" ");

// Funções de ajuda para notas de 0 a 10
export const clamp10 = (n) => Math.min(10, Math.max(0, n));
export const roundToQuarter = (n) => Math.round(n * 4) / 4;

// Formata a nota para exibição, removendo casas decimais desnecessárias.
// Ex: 8.0 -> "8", 8.5 -> "8.5", 8.75 -> "8.75"
export const formatScore = (n) =>
  Number.isInteger(n)
    ? n.toFixed(0)
    : n % 1 === 0.5
      ? n.toFixed(1)
      : n.toFixed(2).replace(/0$/, "");

// Retorna o percentual de preenchimento (0 a 1) de uma estrela para uma dada nota.
// A nota é de 0-10, mas temos 5 estrelas, então uma nota 10 equivale a 5 estrelas.
export const starFillFor = (score, index) => {
  const s = roundToQuarter(clamp10(score));
  const starCount = s / 2; // Converte a nota 0-10 para uma contagem de estrelas 0-5
  return Math.max(0, Math.min(1, starCount - index));
};
</file>

<file path="client/src/App.jsx">
import React, { useEffect } from "react";
import { BrowserRouter, Routes, Route } from "react-router-dom";

// IMPORTAÇÃO DO CONTEXTO
import { AuthProvider } from "./contexts/AuthContext.jsx";

// Importar as páginas
import HomePage from "./pages/HomePage/HomePage.jsx";
import ProfilePage from "./pages/ProfilePage/ProfilePage.jsx";
import DashboardPage from "./pages/DashboardPage/DashboardPage.jsx";
import MediaDetailsPage from "./pages/MediaDetailsPage/MediaDetailsPage.jsx";
import LoginPage from "./pages/LoginPage/LoginPage.jsx";
import RegisterPage from "./pages/RegisterPage/RegisterPage.jsx";
import ForgotPasswordPage from "./pages/ForgotPasswordPage/ForgotPasswordPage.jsx";
import SettingsPage from "./pages/SettingsPage/SettingsPage.jsx";
import ResetPasswordPage from "./pages/ResetPasswordPage/ResetPasswordPage.jsx";
import FavoritesPage from "./pages/FavoritesPage/FavoritesPage.jsx";
import ReviewsPage from "./pages/ReviewsPage/ReviewsPage.jsx";
import AchievementsPage from "./pages/AchievementsPage/AchievementsPage.jsx";
import ListManagementPage from "./pages/ListManagementPage/ListManagementPage.jsx";
import ClubsDiscoveryPage from "./pages/ClubsDiscoveryPage/ClubsDiscoveryPage.jsx";
import ClubDetailsPage from "./pages/ClubDetailsPage/ClubDetailsPage.jsx";
import ClubTopicPage from "./pages/ClubTopicPage/ClubTopicPage.jsx"; // NOVA IMPORTAÇÃO

// Importar os hooks
import { useTheme } from "./hooks/useTheme";
import { useI18n } from "./hooks/useI18n";

function App() {
  const { theme, setTheme } = useTheme();
  const { lang, setLang, t } = useI18n();

  const pageProps = { theme, setTheme, lang, setLang, t };

  useEffect(() => {
    const root = window.document.documentElement;
    root.classList.remove("light", "dark");
    root.classList.add(theme);
  }, [theme]);

  useEffect(() => {
    const root = window.document.documentElement;
    root.setAttribute("lang", lang.toLowerCase());
  }, [lang]);

  return (
    <AuthProvider>
      <BrowserRouter>
        <Routes>
          <Route path="/" element={<HomePage {...pageProps} />} />
          <Route
            path="/profile/:handle"
            element={<ProfilePage {...pageProps} />}
          />
          <Route
            path="/profile/:handle/favorites"
            element={<FavoritesPage {...pageProps} />}
          />
          <Route
            path="/profile/:handle/reviews"
            element={<ReviewsPage {...pageProps} />}
          />
          <Route
            path="/profile/:handle/achievements"
            element={<AchievementsPage {...pageProps} />}
          />
          <Route path="/dashboard" element={<DashboardPage {...pageProps} />} />
          <Route
            path="/dashboard/lists"
            element={<ListManagementPage {...pageProps} />}
          />
          <Route
            path="/media/:mediaId"
            element={<MediaDetailsPage {...pageProps} />}
          />

          {/* ROTAS DE CLUBES */}
          <Route
            path="/clubs"
            element={<ClubsDiscoveryPage {...pageProps} />}
          />
          <Route
            path="/club/:clubId"
            element={<ClubDetailsPage {...pageProps} />}
          />

          {/* NOVA ROTA DE TÓPICO DE CLUBE */}
          <Route
            path="/club/:clubId/topic/:topicId"
            element={<ClubTopicPage {...pageProps} />}
          />

          <Route path="/login" element={<LoginPage {...pageProps} />} />
          <Route path="/register" element={<RegisterPage {...pageProps} />} />
          <Route
            path="/forgot-password"
            element={<ForgotPasswordPage {...pageProps} />}
          />
          <Route
            path="/reset-password"
            element={<ResetPasswordPage {...pageProps} />}
          />
          <Route path="/settings" element={<SettingsPage {...pageProps} />} />
        </Routes>
      </BrowserRouter>
    </AuthProvider>
  );
}

export default App;
</file>

<file path="client/src/main.jsx">
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.jsx";
import "./styles/main.css"; // Importando os estilos globais

// 1. Importar o novo Provedor de Contexto
import { UserDatabaseProvider } from "./contexts/UserDatabaseContext.jsx";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    {/* 2. "Abraçar" a aplicação com o Provedor */}
    <UserDatabaseProvider>
      <App />
    </UserDatabaseProvider>
  </React.StrictMode>,
);
</file>

<file path="client/index.html">
<!doctype html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Mazarbul</title>
    </head>
    <body>
        <div id="root"></div>
        <script type="module" src="/src/main.jsx"></script>
    </body>
</html>
</file>

<file path="client/mazarbul@0.0.0">

</file>

<file path="client/postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="client/project_tree.txt">
.
├── index.html
├── LICENSE
├── mazarbul@0.0.0
├── package.json
├── package-lock.json
├── postcss.config.js
├── project_tree.txt
├── public
├── src
│   ├── App.jsx
│   ├── assets
│   │   ├── fonts
│   │   └── images
│   ├── components
│   │   ├── dashboard
│   │   │   ├── ActivityCalendar
│   │   │   │   └── ActivityCalendar.jsx
│   │   │   └── CollectionList
│   │   │       └── CollectionList.jsx
│   │   ├── layout
│   │   │   ├── HeaderBar
│   │   │   │   └── HeaderBar.jsx
│   │   │   └── SectionHeader
│   │   │       └── SectionHeader.jsx
│   │   ├── media
│   │   │   ├── CommunityReviewsFeed
│   │   │   │   └── CommunityReviewsFeed.jsx
│   │   │   ├── TechnicalDetails
│   │   │   │   └── TechnicalDetails.jsx
│   │   │   └── UserReviewEditor
│   │   │       └── UserReviewEditor.jsx
│   │   ├── ui
│   │   │   ├── AvatarStack
│   │   │   │   └── AvatarStack.jsx
│   │   │   ├── MediaBadge
│   │   │   │   └── MediaBadge.jsx
│   │   │   ├── MediaCard
│   │   │   │   └── MediaCard.jsx
│   │   │   ├── RatingStars
│   │   │   │   └── RatingStars.jsx
│   │   │   └── ReviewsPanel
│   │   │       └── ReviewsPanel.jsx
│   │   └── user
│   │       ├── BadgesRibbon
│   │       │   └── BadgesRibbon.jsx
│   │       ├── FavoritesSection
│   │       │   └── FavoritesSection.jsx
│   │       ├── ProfileHeader
│   │       │   └── ProfileHeader.jsx
│   │       └── ReviewsPanel
│   │           └── ReviewsPanel.jsx
│   ├── hooks
│   │   ├── useI18n.js
│   │   ├── useTheme.js
│   │   └── useUserProfileData.js
│   ├── main.jsx
│   ├── pages
│   │   ├── DashboardPage
│   │   │   └── DashboardPage.jsx
│   │   ├── HomePage
│   │   │   └── HomePage.jsx
│   │   ├── MediaDetailsPage
│   │   │   └── MediaDetailsPage.jsx
│   │   └── ProfilePage
│   │       └── ProfilePage.jsx
│   ├── services
│   ├── styles
│   │   └── main.css
│   └── utils
│       └── formatters.js
├── tailwind.config.js
├── vite
└── vite.config.js

37 directories, 37 files
</file>

<file path="client/tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}", // Diz ao Tailwind para escanear todos os arquivos relevantes na pasta src
  ],
  darkMode: "class", // Habilita o modo escuro baseado em classe (ex: <div class="dark">)
  theme: {
    extend: {},
  },
  plugins: [],
};
</file>

<file path="client/vite">

</file>

<file path="client/vite.config.js">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
});
</file>

<file path="server/prisma/migrations/20251216231129_init_user_table/migration.sql">
-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,
    "handle" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "User_handle_key" ON "User"("handle");
</file>

<file path="server/prisma/migrations/20251217004733_b2_core_schema/migration.sql">
-- AlterTable
ALTER TABLE "User" ADD COLUMN     "avatarUrl" TEXT,
ADD COLUMN     "bio" TEXT;

-- CreateTable
CREATE TABLE "MediaReference" (
    "id" TEXT NOT NULL,
    "type" TEXT NOT NULL,
    "titles" JSONB NOT NULL,
    "synopses" JSONB,
    "posterUrl" TEXT,
    "backdropUrl" TEXT,
    "releaseYear" INTEGER,
    "tags" TEXT[],
    "externalIds" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "MediaReference_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Review" (
    "id" TEXT NOT NULL,
    "rating" DOUBLE PRECISION NOT NULL,
    "content" TEXT,
    "tags" TEXT[],
    "containsSpoilers" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "userId" TEXT NOT NULL,
    "mediaId" TEXT NOT NULL,

    CONSTRAINT "Review_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "UserAchievement" (
    "id" TEXT NOT NULL,
    "achievementId" TEXT NOT NULL,
    "unlockedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "progress" INTEGER NOT NULL DEFAULT 0,
    "userId" TEXT NOT NULL,

    CONSTRAINT "UserAchievement_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "_UserFavorites" (
    "A" TEXT NOT NULL,
    "B" TEXT NOT NULL
);

-- CreateIndex
CREATE INDEX "MediaReference_type_idx" ON "MediaReference"("type");

-- CreateIndex
CREATE UNIQUE INDEX "UserAchievement_userId_achievementId_key" ON "UserAchievement"("userId", "achievementId");

-- CreateIndex
CREATE UNIQUE INDEX "_UserFavorites_AB_unique" ON "_UserFavorites"("A", "B");

-- CreateIndex
CREATE INDEX "_UserFavorites_B_index" ON "_UserFavorites"("B");

-- AddForeignKey
ALTER TABLE "Review" ADD CONSTRAINT "Review_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Review" ADD CONSTRAINT "Review_mediaId_fkey" FOREIGN KEY ("mediaId") REFERENCES "MediaReference"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "UserAchievement" ADD CONSTRAINT "UserAchievement_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_UserFavorites" ADD CONSTRAINT "_UserFavorites_A_fkey" FOREIGN KEY ("A") REFERENCES "MediaReference"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_UserFavorites" ADD CONSTRAINT "_UserFavorites_B_fkey" FOREIGN KEY ("B") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="server/prisma/migrations/20260104190000_add_media_alias/migration.sql">
-- CreateTable
CREATE TABLE "MediaAlias" (
    "aliasId" TEXT NOT NULL,
    "canonicalId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "MediaAlias_pkey" PRIMARY KEY ("aliasId")
);

-- CreateIndex
CREATE INDEX "MediaAlias_canonicalId_idx" ON "MediaAlias"("canonicalId");

-- AddForeignKey
ALTER TABLE "MediaAlias" ADD CONSTRAINT "MediaAlias_canonicalId_fkey"
FOREIGN KEY ("canonicalId") REFERENCES "MediaReference"("id")
ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="server/prisma/migrations/20260104220716_npx_prisma_generate/migration.sql">
-- AlterTable
ALTER TABLE "MediaReference" ADD COLUMN     "countries" JSONB,
ADD COLUMN     "details" JSONB,
ADD COLUMN     "director" TEXT,
ADD COLUMN     "genres" JSONB,
ADD COLUMN     "runtime" INTEGER;
</file>

<file path="server/prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
</file>

<file path="server/src/controllers/auth.controller.js">
import { registerUser, loginUser } from '../services/auth.service.js';

export const register = async (req, res) => {
    try {
        // Pegamos os dados que vieram no corpo da requisição
        const result = await registerUser(req.body);

        // Devolvemos 201 (Created) e o usuário criado
        res.status(201).json(result);
    } catch (error) {
        // Se der erro (ex: email duplicado), devolvemos 400 (Bad Request)
        res.status(400).json({ error: error.message });
    }
};

export const login = async (req, res) => {
    try {
        const { email, password } = req.body;
        const result = await loginUser(email, password);

        res.json(result);
    } catch (error) {
        res.status(401).json({ error: error.message });
    }
};
</file>

<file path="server/src/controllers/review.controller.js">
import { PrismaClient } from '@prisma/client';
import { checkAndUnlockAchievements } from '../services/gamification.service.js';

const prisma = new PrismaClient();

// Criar ou Editar Review
export const upsertReview = async (req, res) => {
    try {
        const userId = req.userId; // Vem do middleware de auth
        const { mediaId, rating, content, tags, containsSpoilers } = req.body;

        if (!mediaId || rating === undefined) {
            return res.status(400).json({ error: "MediaId e Rating são obrigatórios." });
        }

        // 1. Salvar no Banco
        // Usamos 'upsert' para que, se o usuário já tiver review dessa mídia, ela seja atualizada.
        const review = await prisma.review.upsert({
            where: {
                // Precisamos garantir que o usuário só tenha 1 review por mídia?
                // O Prisma precisa de um campo único composto para isso, mas nosso schema
                // atual usa ID uuid. Vamos buscar primeiro para simplificar a lógica B2.
                // *Nota: Para simplificar MVP, vamos criar sempre uma nova se não mandarem ID,
                // ou você pode restringir no futuro. Aqui vou assumir criação simples.*
                id: req.body.id || "novo-id-inexistente"
            },
            update: {
                rating,
                content,
                tags,
                containsSpoilers
            },
            create: {
                userId,
                mediaId,
                rating,
                content,
                tags,
                containsSpoilers
            }
        });

        // 2. DISPARAR GAMIFICAÇÃO 🏆
        // Não esperamos isso terminar para responder o usuário (fire and forget),
        // ou esperamos se quisermos mostrar o troféu na hora. Vamos esperar por segurança.
        const gamificationResult = await checkAndUnlockAchievements(userId);

        res.status(201).json({
            review,
            achievements: gamificationResult.newUnlocks || [] // Se tiver novos troféus, o front avisa
        });

    } catch (error) {
        console.error("Erro ao salvar review:", error);
        res.status(500).json({ error: "Erro interno ao processar review." });
    }
};

// Listar Reviews de uma Mídia
export const getMediaReviews = async (req, res) => {
    try {
        const { mediaId } = req.params;

        const reviews = await prisma.review.findMany({
            where: { mediaId },
            include: {
                user: {
                    select: { name: true, handle: true, avatarUrl: true } // Só dados públicos
                }
            },
            orderBy: { createdAt: 'desc' }
        });

        res.json(reviews);
    } catch (error) {
        res.status(500).json({ error: "Erro ao buscar reviews." });
    }
};
</file>

<file path="server/src/lib/prisma.js">
import { PrismaClient } from '@prisma/client';

// Essa lógica evita criar múltiplas conexões com o banco
// toda vez que o servidor reinicia no modo "watch" (dev)
const globalForPrisma = global;

const prisma = globalForPrisma.prisma || new PrismaClient();

if (process.env.NODE_ENV !== 'production') {
    globalForPrisma.prisma = prisma;
}

export default prisma;
</file>

<file path="server/src/middlewares/auth.middleware.js">
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET || 'chave-secreta-super-segura-do-mazarbul';

export const authenticateToken = (req, res, next) => {
    // O token vem no header: "Authorization: Bearer <token>"
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Pega só o código depois do 'Bearer'

    if (!token) {
        return res.status(401).json({ error: "Acesso negado. Token não fornecido." });
    }

    try {
        const user = jwt.verify(token, JWT_SECRET);
        // Injeta o ID do usuário na requisição para os controllers usarem
        req.userId = user.id;
        next();
    } catch (error) {
        return res.status(403).json({ error: "Token inválido ou expirado." });
    }
};
</file>

<file path="server/src/routes/auth.routes.js">
import { Router } from 'express';
import { register, login } from '../controllers/auth.controller.js';

const router = Router();

// POST http://localhost:3000/api/auth/register
router.post('/register', register);

// POST http://localhost:3000/api/auth/login
router.post('/login', login);

export default router;
</file>

<file path="server/src/routes/review.routes.js">
import { Router } from 'express';
import { upsertReview, getMediaReviews } from '../controllers/review.controller.js';
import { authenticateToken } from '../middlewares/auth.middleware.js';

const router = Router();

// POST /api/reviews
// Exige Login (authenticateToken)
router.post('/', authenticateToken, upsertReview);

// GET /api/reviews/:mediaId
// Público (Qualquer um pode ler reviews)
router.get('/:mediaId', getMediaReviews);

export default router;
</file>

<file path="server/src/services/gamification.service.js">
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Definição das Regras de cada Conquista
// Baseado nos tiers do seu frontend: [Bronze, Prata, Ouro]
const ACHIEVEMENT_RULES = {
    // --- CONTAGEM POR TIPO (Os Anéis de Poder) ---
    'the-one': { type: 'livro', tiers: [12, 25, 52] }, // Livros lidos
    'vilya':   { type: 'filme', tiers: [12, 25, 52] }, // Filmes vistos
    'nenya':   { type: 'jogo',  tiers: [12, 25, 52] }, // Jogos jogados
    'narya':   { type: 'album', tiers: [12, 25, 52] }, // Álbuns ouvidos

    // --- GÊNEROS ESPECÍFICOS ---
    'horror-business': {
        tag: 'tag.horror',
        tiers: [1, 6, 12]
    },
    'life-universe-everything': {
        tag: 'tag.scifi',
        tiers: [1, 6, 12] // 42 seria o ideal, mas mantive sua lista [1, 6, 12]
    },
    'once-upon-time-west': {
        tag: 'tag.western',
        tiers: [1, 6, 12]
    },

    // --- OUTROS (Exemplos baseados na lógica de tags) ---
    'kagemusha': {
        // Como conversamos, usaremos tag de samurai/histórico
        tags: ['tag.samurai', 'tag.feudal', 'tag.japan'],
        tiers: [1, 6, 12]
    }
};

/**
 * Engine Principal: Verifica e desbloqueia troféus para um usuário
 * Deve ser chamado SEMPRE que uma review for criada ou apagada.
 */
export const checkAndUnlockAchievements = async (userId) => {
    console.log(`[GAMIFICATION] Verificando troféus para o user: ${userId}`);

    // 1. Buscar todas as reviews do usuário incluindo os dados da mídia (tags/tipo)
    const userReviews = await prisma.review.findMany({
        where: { userId },
        include: { media: true }
    });

    // 2. Calcular estatísticas atuais
    const stats = {
        livro: 0,
        filme: 0,
        jogo: 0,
        album: 0,
        tags: {} // Ex: { 'tag.horror': 5, 'tag.scifi': 2 }
    };

    userReviews.forEach(review => {
        const media = review.media;

        // Contagem por Tipo
        if (stats[media.type] !== undefined) {
            stats[media.type]++;
        }

        // Contagem por Tags
        if (media.tags && Array.isArray(media.tags)) {
            media.tags.forEach(tag => {
                // Normaliza a tag para garantir
                const cleanTag = tag.toLowerCase();
                stats.tags[cleanTag] = (stats.tags[cleanTag] || 0) + 1;
            });
        }
    });

    // 3. Verificar Regras vs Estatísticas
    const newUnlocks = [];

    for (const [achievementId, rule] of Object.entries(ACHIEVEMENT_RULES)) {
        let currentCount = 0;

        // Lógica A: É troféu de contagem por Tipo? (Ex: Ler 10 livros)
        if (rule.type) {
            currentCount = stats[rule.type] || 0;
        }

        // Lógica B: É troféu de Tag específica? (Ex: Ver filmes de Terror)
        else if (rule.tag) {
            currentCount = stats.tags[rule.tag] || 0;
        }

        // Lógica C: É troféu de Lista de Tags? (Ex: Kagemusha - samurai OU japan)
        else if (rule.tags) {
            // Soma reviews que tenham PELO MENOS UMA das tags da lista
            // (Lógica simplificada: se a review tiver 2 tags da lista, conta 1 vez por review)
            currentCount = userReviews.filter(r =>
            r.media.tags.some(t => rule.tags.includes(t))
            ).length;
        }

        // 4. Salvar/Atualizar Progresso no Banco
        // Sempre atualizamos o "progress" para a barra encher no frontend
        try {
            await prisma.userAchievement.upsert({
                where: {
                    userId_achievementId: {
                        userId,
                        achievementId
                    }
                },
                update: {
                    progress: currentCount,
                    // Não atualizamos unlockedAt se já existir, para manter a data original
                },
                create: {
                    userId,
                    achievementId,
                    progress: currentCount,
                    unlockedAt: new Date()
                }
            });

            // Nota: No futuro, podemos disparar notificação aqui se currentCount acabou de bater uma meta (tier)

        } catch (error) {
            console.error(`Erro ao atualizar troféu ${achievementId}:`, error);
        }
    }

    return { success: true, stats };
};
</file>

<file path="server/.gitignore">
node_modules
# Keep environment variables out of version control
.env

/src/generated/prisma
</file>

<file path=".gitignore">
<<<<<<< HEAD
# Dependencies
/node_modules

# Vite build output
/dist

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local
=======
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.*
!.env.example

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Sveltekit cache directory
.svelte-kit/

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# Firebase cache directory
.firebase/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v3
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

# Vite logs files
vite.config.js.timestamp-*
vite.config.ts.timestamp-*
>>>>>>> 114ce924b543a17d26d8c5ad410e5eacfe72f9a7
</file>

<file path="LICENSE">

</file>

<file path="README.md">
# Mazarbul

Mazarbul é uma aplicação web focada no registro e partilha de atividades culturais. A plataforma permite que os utilizadores cataloguem, avaliem e organizem mídias como filmes, livros, jogos e álbuns, funcionando como um diário pessoal de consumo cultural que pode ser partilhado publicamente.

## Stack Técnica

-   **Framework:** React
-   **Build Tool:** Vite
-   **Estilização:** Tailwind CSS
-   **Roteamento:** React Router DOM
-   **Ícones:** Lucide React

## Estrutura e Funcionalidades do Projeto

### Funcionalidades Implementadas (UI)

-   **`HomePage.jsx`** (Rota: `/`)
    A página inicial do Mazarbul. A sua estrutura existe, mas o conteúdo dinâmico (destaques, atividade de amigos) ainda não foi implementado.

-   **`DashboardPage.jsx`** (Rota: `/dashboard`)
    O perfil privado do utilizador autenticado, exibindo seus favoritos, reviews, listas e conquistas.

-   **`ProfilePage.jsx`** (Rota: `/profile/:handle`)
    A página de perfil público de outro utilizador, com um layout idêntico ao do Dashboard.

-   **`MediaDetailsPage.jsx`** (Rota: `/media/:mediaId`)
    A página de detalhes de um item (filme, livro, etc.), mostrando sinopse, ficha técnica e o editor para o utilizador submeter a sua própria review.

-   **`LoginPage.jsx`** (Rota: `/login`)
    Permite que um utilizador existente faça login com e-mail e palavra-passe.

-   **`RegisterPage.jsx`** (Rota: `/register`)
    Permite que um novo utilizador se registe com nome, e-mail, @username e palavra-passe.

-   **`ForgotPasswordPage.jsx`** (Rota: `/forgot-password`)
    Formulário para o utilizador inserir o e-mail para iniciar a recuperação de palavra-passe.

-   **`ResetPasswordPage.jsx`** (Rota: `/reset-password`)
    Página acedida via e-mail onde o utilizador define uma nova palavra-passe.

-   **`SettingsPage.jsx`** (Rota: `/settings`)
    Página de configurações com seções para Perfil, Conta e Preferências.

-   **Busca Instantânea no HeaderBar**
    Funcionalidade de autocomplete focada na descoberta de mídias. Sugere resultados em tempo real enquanto o utilizador digita, com suporte multilíngue e para aliases.

### Funcionalidades Planeadas (Roadmap)

-   **Páginas de Expansão do Perfil ("Ver Mais")**
    -   `FavoritesPage.jsx` (ex: `/profile/alexl/favorites`): Grelha com todos os favoritos do utilizador.
    -   `ReviewsPage.jsx` (ex: `/profile/alexl/reviews`): Lista paginada de todas as reviews do utilizador.
    -   `AchievementsPage.jsx` (ex: `/profile/alexl/achievements`): Página mostrando todas as conquistas do utilizador.

-   **Páginas de Listas (Collections)**
    -   `ListDetailsPage.jsx` (ex: `/profile/alexl/list/classicos`): Mostra o conteúdo completo de uma lista específica.
    -   `ListEditorPage.jsx` (ex: `/list/new`): Um editor para o utilizador criar e modificar listas, adicionando mídias a elas.

-   **Páginas de Clubes**
    -   `ClubsDiscoveryPage.jsx` (ex: `/clubs`): Página para explorar e procurar todos os clubes existentes através de uma busca contextual.
    -   `ClubDetailsPage.jsx` (ex: `/club/guerra-nas-estrelas`): Página de um clube, mostrando membros e discussões.

## Como Executar Localmente

1.  **Clonar o repositório:**
    ```bash
    git clone [[https://github.com/0zzmandias/Mazarbul.git]](https://github.com/0zzmandias/Mazarbul.git)
    ```

2.  **Aceder ao diretório do projeto:**
    ```bash
    cd Mazarbul
    ```

3.  **Instalar as dependências:**
    ```bash
    npm install
    ```

4.  **Iniciar o servidor de desenvolvimento:**
    ```bash
    npm run dev
</file>

<file path="client/src/components/layout/HeaderBar/HeaderBar.jsx">
import React, { useState, useEffect, useRef } from "react";
import { Link, useNavigate } from "react-router-dom";
import { Sun, Moon, User, Settings, Search as SearchIcon, Loader2 } from "lucide-react";

import api from "../../../services/api";
import { useAuth } from "../../../contexts/AuthContext";

function HeaderBar({ theme, setTheme, lang, setLang, t }) {
  const [searchOpen, setSearchOpen] = useState(false);
  const [langOpen, setLangOpen] = useState(false);
  const [query, setQuery] = useState("");
  const [searchResults, setSearchResults] = useState([]);
  const [isLoading, setIsLoading] = useState(false);

  const { currentUser } = useAuth();

  const searchInputRef = useRef(null);
  const searchContainerRef = useRef(null);
  const navigate = useNavigate();

  useEffect(() => {
    if (searchOpen) {
      searchInputRef.current?.focus();
    }
  }, [searchOpen]);

  useEffect(() => {
    if (query.length < 2) {
      setSearchResults([]);
      return;
    }

    const delayDebounceFn = setTimeout(async () => {
      setIsLoading(true);

      try {
        const promises = [
          api.get("/media/search", { params: { q: query, type: "filme" } }),
                                       api.get("/media/search", { params: { q: query, type: "jogo" } }),
                                       api.get("/media/search", { params: { q: query, type: "livro" } }),
                                       api.get("/media/search", { params: { q: query, type: "album" } }),
        ];

        const results = await Promise.allSettled(promises);

        let combinedResults = [];

        results.forEach((res) => {
          if (res.status === "fulfilled" && Array.isArray(res.value.data)) {
            combinedResults.push(...res.value.data);
          }
        });

        const normalizedQuery = query.toLowerCase().trim();

        const scoredResults = combinedResults.map((item) => {
          const title = (item.title || "").toLowerCase();
          let score = 0;

          if (title === normalizedQuery) score = 100;
          else if (title.startsWith(normalizedQuery)) score = 50;
          else if (title.includes(normalizedQuery)) score = 10;
          else score = 0;

          return { ...item, score };
        });

        const filteredResults = scoredResults.filter((item) => item.score > 0);

        filteredResults.sort((a, b) => {
          if (a.score !== b.score) return b.score - a.score;

          const typePriority = { livro: 3, filme: 2, jogo: 1, album: 1 };
          const pA = typePriority[a.type] || 0;
          const pB = typePriority[b.type] || 0;
          if (pA !== pB) return pB - pA;

          return (a.title || "").localeCompare(b.title || "");
        });

        setSearchResults(filteredResults.slice(0, 20));
      } catch (error) {
        console.error("Erro na busca global:", error);
      } finally {
        setIsLoading(false);
      }
    }, 600);

    return () => clearTimeout(delayDebounceFn);
  }, [query]);

  useEffect(() => {
    function handleClickOutside(event) {
      if (
        searchContainerRef.current &&
        !searchContainerRef.current.contains(event.target)
      ) {
        setSearchOpen(false);
        setSearchResults([]);
      }
    }
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [searchContainerRef]);

  function handleSearchSubmit(q) {
    if (!q) return;
    setSearchOpen(false);
    setSearchResults([]);
    setQuery("");
  }

  const safeT = (key, fallback) => {
    if (typeof t === "function") {
      const translated = t(key);
      return translated === key && fallback ? fallback : translated;
    }
    return fallback || key;
  };

  return (
    <header className="fixed top-0 inset-x-0 z-40 h-20 bg-transparent pointer-events-none">
    <div className="max-w-5xl mx-auto h-full px-4 flex items-center pointer-events-auto">
    <div ref={searchContainerRef} className="w-full relative">
    <div className="rounded-full border border-neutral-200 dark:border-neutral-800 bg-white/80 dark:bg-neutral-900/70 backdrop-blur shadow-sm transition-all duration-200">
    {!searchOpen ? (
      <div className="grid grid-cols-[auto_1fr_auto] items-center gap-2 px-3 py-2">
      <button
      aria-label={safeT("a11y.open_search", "Abrir busca")}
      onClick={() => setSearchOpen(true)}
      className="p-2 rounded-full hover:bg-neutral-100 dark:hover:bg-neutral-800 transition-colors"
      >
      <SearchIcon className="w-5 h-5 text-neutral-600 dark:text-neutral-400" />
      </button>

      <div className="flex items-center justify-center">
      <Link
      to="/"
      className="font-bold text-lg tracking-tight text-neutral-900 dark:text-white"
      >
      Mazarbul
      </Link>
      </div>

      <div className="flex items-center justify-end gap-2">
      <button
      onClick={() => setTheme(theme === "dark" ? "light" : "dark")}
      className="h-9 w-9 inline-flex items-center justify-center rounded-xl border border-neutral-200 dark:border-neutral-700 hover:bg-neutral-100 dark:hover:bg-neutral-800 transition-colors"
      >
      {theme === "dark" ? (
        <Moon className="w-5 h-5" />
      ) : (
        <Sun className="w-5 h-5" />
      )}
      </button>

      <div className="relative">
      <button
      onClick={() => setLangOpen((v) => !v)}
      className="h-9 px-3 inline-flex items-center justify-center rounded-xl border border-neutral-200 dark:border-neutral-700 text-sm font-medium hover:bg-neutral-100 dark:hover:bg-neutral-800 transition-colors"
      >
      {lang}
      </button>
      {langOpen && (
        <div className="absolute right-0 mt-2 w-20 rounded-xl border border-neutral-200 dark:border-neutral-700 bg-white dark:bg-neutral-900 shadow-xl overflow-hidden py-1">
        {["PT", "EN", "ES"]
          .filter((c) => c !== lang)
          .map((c) => (
            <button
            key={c}
            onClick={() => {
              setLang(c);
              setLangOpen(false);
            }}
            className="w-full text-left px-3 py-2 text-sm hover:bg-neutral-50 dark:hover:bg-neutral-800 transition-colors"
            >
            {c}
            </button>
          ))}
          </div>
      )}
      </div>

      <Link
      to="/settings"
      className="h-9 w-9 inline-flex items-center justify-center rounded-xl hover:bg-neutral-100 dark:hover:bg-neutral-800 transition-colors"
      >
      <Settings className="w-5 h-5" />
      </Link>

      <Link
      to="/dashboard"
      className="h-9 w-9 inline-flex items-center justify-center rounded-xl hover:bg-neutral-100 dark:hover:bg-neutral-800 overflow-hidden border border-transparent hover:border-neutral-200 dark:hover:border-neutral-700 transition-all"
      >
      {currentUser?.avatarUrl ? (
        <img
        src={currentUser.avatarUrl}
        alt=""
        className="w-full h-full object-cover"
        />
      ) : (
        <User className="w-5 h-5" />
      )}
      </Link>
      </div>
      </div>
    ) : (
      <form
      onSubmit={(e) => {
        e.preventDefault();
        handleSearchSubmit(query);
      }}
      className="flex items-center gap-3 px-4 py-2"
      >
      {isLoading ? (
        <Loader2 className="w-5 h-5 text-amber-500 animate-spin flex-shrink-0" />
      ) : (
        <SearchIcon className="w-5 h-5 text-neutral-400 flex-shrink-0" />
      )}

      <input
      ref={searchInputRef}
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      onKeyDown={(e) => {
        if (e.key === "Escape") setSearchOpen(false);
      }}
      className="flex-1 bg-transparent outline-none text-base text-neutral-900 dark:text-neutral-100 placeholder:text-neutral-400"
      placeholder={safeT(
        "search.placeholder",
        "Busque filmes, jogos, livros..."
      )}
      />
      </form>
    )}
    </div>

    {searchOpen && searchResults.length > 0 && (
      <div className="absolute top-full mt-2 w-full max-h-[70vh] overflow-y-auto rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white/95 dark:bg-neutral-900/95 backdrop-blur-md shadow-2xl z-50 scrollbar-thin scrollbar-thumb-neutral-300 dark:scrollbar-thumb-neutral-700">
      <ul className="divide-y divide-neutral-100 dark:divide-neutral-800">
      {searchResults.map((media) => (
        <li key={media.id}>
        <Link
        to={`/media/${media.id}`}
        onClick={() => {
          setSearchOpen(false);
          setSearchResults([]);
          setQuery("");
        }}
        className="flex items-center gap-4 p-3 hover:bg-neutral-50 dark:hover:bg-neutral-800/80 transition-colors group"
        >
        <div className="w-10 h-14 bg-neutral-200 dark:bg-neutral-800 rounded overflow-hidden flex-shrink-0 shadow-sm">
        {media.poster || media.posterUrl ? (
          <img
          src={media.poster || media.posterUrl}
          alt=""
          className="w-full h-full object-cover group-hover:scale-105 transition-transform duration-500"
          />
        ) : (
          <div className="w-full h-full flex items-center justify-center text-xs text-neutral-400">
          ?
          </div>
        )}
        </div>

        <div className="flex-1 min-w-0">
        <p className="font-semibold text-sm text-neutral-900 dark:text-neutral-100 truncate">
        {media.title}
        </p>
        <div className="flex items-center gap-2 text-xs text-neutral-500 dark:text-neutral-400 mt-0.5">
        <span className="uppercase tracking-wider font-bold text-[10px] bg-neutral-100 dark:bg-neutral-800 px-1.5 py-0.5 rounded">
        {safeT(`badge.${media.type}`, media.type)}
        </span>
        {media.year && <span>{media.year}</span>}
        {media.author && (
          <span className="truncate max-w-[150px] opacity-70">
          • {media.author}
          </span>
        )}
        </div>
        </div>
        </Link>
        </li>
      ))}
      </ul>
      </div>
    )}
    </div>
    </div>
    </header>
  );
}

export default HeaderBar;
</file>

<file path="client/src/contexts/AuthContext.jsx">
import React, { createContext, useContext, useState, useEffect } from "react";
import api from "../services/api";

const AuthContext = createContext();

export function useAuth() {
  return useContext(AuthContext);
}

export function AuthProvider({ children }) {
  const [currentUser, setCurrentUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Tenta recuperar dados salvos
    const storedUser = localStorage.getItem('@Mazarbul:user');
    const storedToken = localStorage.getItem('@Mazarbul:token');

    if (storedUser && storedToken) {
      // BLINDAGEM: Verifica se não salvou "undefined" como texto por engano
      if (storedUser !== "undefined" && storedUser !== "null") {
        try {
          const parsedUser = JSON.parse(storedUser);
          setCurrentUser(parsedUser);
          api.defaults.headers.common['Authorization'] = `Bearer ${storedToken}`;
        } catch (error) {
          console.error("Storage corrompido, limpando...", error);
          // Se o dado estiver podre, limpamos tudo para não travar o app
          localStorage.removeItem('@Mazarbul:user');
          localStorage.removeItem('@Mazarbul:token');
        }
      } else {
        // Se for "undefined" texto, limpa também
        localStorage.removeItem('@Mazarbul:user');
        localStorage.removeItem('@Mazarbul:token');
      }
    }

    setLoading(false);
  }, []);

  const signIn = async (email, password) => {
    try {
      const response = await api.post('/auth/login', { email, password });

      const { token, user } = response.data;

      // Verificação extra antes de salvar
      if (user && token) {
        localStorage.setItem('@Mazarbul:token', token);
        localStorage.setItem('@Mazarbul:user', JSON.stringify(user));

        api.defaults.headers.common['Authorization'] = `Bearer ${token}`;
        setCurrentUser(user);
        return { success: true };
      } else {
        return { success: false, message: "Resposta inválida do servidor." };
      }

    } catch (error) {
      console.error("Erro no login:", error);
      return {
        success: false,
        message: error.response?.data?.error || "Erro ao conectar com servidor."
      };
    }
  };

  const signOut = () => {
    localStorage.removeItem('@Mazarbul:token');
    localStorage.removeItem('@Mazarbul:user');
    setCurrentUser(null);
    window.location.href = '/login';
  };

  const value = { currentUser, loading, signIn, signOut };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}
</file>

<file path="client/src/hooks/useI18n.js">
import { useState, useEffect } from "react";

// DICIONÁRIO COMPLETO
const I18N = {
  PT: {
    // --- GERAIS ---
    "nav.back_home": "Voltar para o início",
    "search.placeholder": "Busca rápida...",
    "a11y.open_search": "Abrir busca",
    "a11y.toggle_theme": "Alternar tema",
    "a11y.toggle_language": "Mudar idioma",
    "a11y.settings_page": "Configurações",
    "a11y.user_profile": "Meu perfil",
    "a11y.add_favorite": "Adicionar aos favoritos",
    "a11y.remove_favorite": "Remover dos favoritos",

    // --- SEÇÕES E TÍTULOS ---
    "section.highlights": "Destaques",
    "section.recents": "Recentes",
    "section.clubs": "Clubes",
    "section.favorites": "Favoritos",
    "section.reviews": "Resenhas recentes",
    "section.collections": "Minhas Listas",
    "section.friends": "Atividade dos Amigos",
    "section.synopsis": "Sinopse",
    "section.techDetails": "Ficha Técnica",
    "section.yourReview": "Sua Review",
    "section.communityAverage": "Média da Comunidade",
    "section.communityReviews": "Vozes da Comunidade",

    // --- CLUBES (GERAL) ---
    "clubs.title": "Explorar Clubes",
    "clubs.subtitle":
    "Encontre sua tribo, participe de leituras conjuntas e discuta suas obras favoritas.",
    "club.reading_now": "Lendo Agora",
    "action.visit_club": "Visitar Clube",
    "clubs.search_placeholder": "Buscar clubes por nome ou tag...",
    "clubs.filter_all": "Todos",
    "clubs.filter_reading": "Leitura",
    "clubs.filter_cinema": "Cinema",
    "clubs.filter_gaming": "Games",
    "clubs.filter_music": "Música",

    // --- CRIAÇÃO DE CLUBE (NOVO) ---
    "club.create.title": "Criar Novo Clube",
    "club.create.name_label": "Nome do Clube",
    "club.create.name_placeholder": "Ex: Sociedade do Anel",
    "club.create.handle_label": "Identificador do Clube (@)",
    "club.create.handle_placeholder": "ex: sociedade_anel",
    "club.create.desc_label": "Descrição Curta",
    "club.create.desc_placeholder": "Sobre o que é este clube?",
    "club.create.banner_label": "Banner do Clube",
    "club.create.banner_help": "Envie uma imagem para ser a capa do clube.",
    "club.create.visual_label": "Identidade Visual",
    "club.create.preview": "Preview do Banner",
    "club.create.tags_label": "Tags (Máx. 3)",
    "club.create.rules_label": "Regras do Clube",
    "club.create.rules_placeholder": "1. Respeito acima de tudo...",
    "club.create.cancel": "Cancelar",
    "club.create.submit": "Criar Clube",

    // --- GESTÃO DE CLUBE ---
    "club.manage.title": "Gerir Clube",
    "club.manage.tab_info": "Informações",
    "club.manage.tab_members": "Membros",
    "club.manage.tab_works": "Obras",
    "club.manage.save": "Salvar Alterações",
    "club.manage.approve": "Aprovar",
    "club.manage.reject": "Recusar",
    "club.manage.kick": "Remover",
    "club.manage.promote": "Promover a Mod",
    "club.manage.demote": "Rebaixar a Membro",
    "club.manage.pending_requests": "Solicitações Pendentes",
    "club.manage.active_members": "Membros Ativos",
    "club.manage.remove_work": "Encerrar Atividade",

    // --- DETALHES DO CLUBE ---
    "club.tab.overview": "Visão Geral",
    "club.tab.discussions": "Discussões",
    "club.tab.members": "Membros",
    "club.tab.history": "Histórico",
    "club.section.active_works": "Em Andamento",
    "club.section.rules": "Regras do Clube",
    "club.section.about": "Sobre",
    "club.section.general_topics": "Tópicos Gerais",
    "club.action.join": "Entrar no Clube",
    "club.action.leave": "Sair do Clube",
    "club.action.manage": "Gerir Clube",
    "club.role.owner": "Fundador",
    "club.role.mod": "Mod",
    "club.role.member": "Membro",
    "club.next_meeting": "Próximo Encontro",
    "club.add_to_calendar": "Adicionar ao Calendário",
    "club.status.pending": "Aguardando Aprovação",

    "club.card.topics_open": "tópicos abertos",
    "club.card.participating": "participando",
    "club.card.cycle_prev": "Ciclo Anterior",
    "club.card.ended_at": "Encerrado em",
    "club.card.view_archived": "Ver tópicos arquivados",
    "club.card.responses": "respostas",
    "club.card.by": "por",
    "club.card.view_details": "Ver ficha técnica",
    "club.placeholder.no_activity": "Nenhuma atividade ativa no momento.",
    "club.placeholder.no_member": "Nenhum membro encontrado.",

    // --- PÁGINA DE TÓPICO (NOVO) ---
    "topic.back_to": "Voltar para",
    "topic.pinned": "Fixado",
    "topic.started_on": "Iniciado em",
    "topic.replies_count": "Respostas",
    "topic.no_replies": "Nenhuma resposta ainda. Seja o primeiro!",
    "topic.reply_placeholder": "Escreva sua resposta...",
    "topic.reply_button": "Responder",
    "topic.content_unavailable": "Conteúdo não disponível.",

    // Textos dinâmicos de atividade
    "club.activity.livro": "Lendo Agora",
    "club.activity.filme": "Assistindo Agora",
    "club.activity.jogo": "Jogando Agora",
    "club.activity.album": "Ouvindo Agora",

    // --- CONQUISTAS ---
    "section.achievements": "Conquistas",
    "achievements.title": "Conquistas",
    "achievements.subtitle":
    "Acompanhe sua jornada através do multiverso cultural.",
    "achievements.progress": "Progresso",
    "achievements.locked": "Bloqueado",
    "achievement.desc.the-one":
    "Registre sua jornada literária ao longo de um ano.",
    "achievement.desc.narya":
    "Registre sua jornada musical ao longo de um ano.",
    "achievement.desc.vilya":
    "Registre sua jornada cinematográfica ao longo de um ano.",
    "achievement.desc.nenya":
    "Registre sua jornada nos games ao longo de um ano.",
    "achievement.desc.life-universe-everything":
    "Complete o ciclo de obras de Ficção Científica em livros, filmes e jogos.",
    "achievement.desc.horror-business":
    "Complete o ciclo de obras de Terror em livros, filmes e jogos.",
    "achievement.desc.wood-between-worlds":
    "Complete o ciclo de obras de Fantasia em livros, filmes e jogos.",
    "achievement.desc.once-upon-time-west":
    "Complete o ciclo de obras de Western em livros, filmes e jogos.",
    "achievement.desc.kagemusha":
    "Complete o ciclo de obras Eastern em livros, filmes e jogos.",
    "achievement.desc.help-me-eros":
    "Complete o ciclo de obras de Romance em livros, filmes e jogos.",
    "achievement.desc.guernica":
    "Complete o ciclo de obras de Guerra em livros, filmes e jogos.",
    "achievement.desc.nighthawks":
    "Complete o ciclo de obras Noir em livros, filmes e jogos.",
    "achievement.desc.perche-leggere-classici":
    "Analise Livros anteriores a 1900, Filmes anteriores a 1950, Álbuns anteriores a 1970 ou Jogos anteriores a 2000.",
    "achievement.desc.zeitgeist":
    "Mantenha-se atualizado analisando obras lançadas na última década.",
    "achievement.desc.moritarnon":
    "Descubra e analise obras que sofreram censura ou banimento histórico.",
    "achievement.desc.arda":
    "Complete o ciclo de análises de obras de todos os 6 continentes.",
    "achievement.desc.rhun":
    "Amplie horizontes com obras de países fora do eixo do Norte Global.",
    "achievement.desc.khazad-dum":
    "Escave profundamente em busca de obras independentes ou de nicho.",
    "achievement.desc.manwe":
    "Defenda uma obra incompreendida: Nota pessoal alta vs. Média geral baixa.",
    "achievement.desc.melkor":
    "Critique um favorito das massas: Nota pessoal baixa vs. Média geral alta.",
    "achievement.desc.trivium": "Complete a jornada de uma trilogia inteira.",
    "achievement.desc.quadrivium":
    "Complete a jornada de uma tetralogia inteira.",
    "achievement.desc.dagor-dagorath":
    "Chegue ao fim de uma saga de livros, filmes ou jogos.",

    // --- AÇÕES E LABELS ---
    "action.explore": "Explorar",
    "action.see_more": "Ver mais",
    "action.see_all": "Ver todas",
    "action.manage": "Gerir",
    "action.saveReview": "Salvar Review",
    "label.next": "Próximo",

    // --- DETALHES DE MÍDIA ---
    "details.author": "Autor",
    "details.pages": "Páginas",
    "details.director": "Diretor",
    "details.duration": "Duração",
    "details.genre": "Gênero",
    "details.year": "Ano",
    "details.country": "País",

    "details.not_informed": "Não informado",
    "details.synopsis_not_available": "Sinopse não disponível neste idioma.",
    "details.no_synopsis": "Sem sinopse.",

    // --- LISTS ---
    "list.actions_title": "Ações",
    "list.owner_prefix": "Lista de",
    "list.empty_state": "Esta lista ainda não tem itens.",
    "list.create_new": "Criar Nova Lista",
    "list.edit_title": "Editar Lista",
    "list.edit_mode": "Editar Listas",
    "list.delete_mode": "Apagar Listas",
    "list.select_prompt": "Selecione uma lista na coluna da direita",
    "list.select_to_edit_prompt":
    "Selecione uma lista na coluna da direita para editar.",
    "list.select_to_delete_prompt":
    "Selecione uma lista na coluna da direita para apagar.",
    "list.or_create_prompt": "ou crie uma nova.",
    "list.form_name": "Nome",
    "list.form_name_placeholder": "Ex: Clássicos da Fantasia",
    "list.form_desc": "Descrição",
    "list.form_desc_placeholder": "Uma breve descrição da sua lista...",
    "list.form_create_button": "Criar Lista",
    "list.form_save_button": "Salvar Alterações",
    "list.form_delete_button": "Apagar Lista",
    "list.delete_confirm": "Tem certeza que quer apagar esta lista?",
    "list.add_items_title": "Adicionar Mídias",
    "list.add_media": "Adicionar Mídias",
    "list.search_placeholder": "Procurar filmes, livros, jogos...",
    "list.no_results": "Nenhum resultado encontrado.",
    "list.current_items_title": "Itens na Lista",
    "list.empty_state_editor": "Adicione mídias usando a busca acima.",
    "list.item_singular": "item",
    "list.item_plural": "itens",

    // --- FILTROS E TAGS ---
    "filter.all": "Todos",
    "filter.movies": "Filmes",
    "filter.books": "Livros",
    "filter.games": "Jogos",
    "filter.albums": "Álbums",
    "badge.filme": "Filme",
    "badge.livro": "Livro",
    "badge.jogo": "Jogo",
    "badge.album": "Álbum",
    "tag.scifi": "Sci-Fi",
    "tag.aventura": "Aventura",
    "tag.drama": "Drama",
    "tag.thriller": "Thriller",
    "tag.comedia": "Comédia",
    "tag.distopia": "Distopia",
    "tag.politica": "Política",
    "tag.roguelike": "Roguelike",
    "tag.mitologia": "Mitologia",
    "tag.indie": "Indie",
    "tag.eletronica": "Eletrônica",
    "tag.disco": "Disco",
    "tag.funk": "Funk",
    "tag.rpg": "RPG",
    "tag.fantasia": "Fantasia",
    "tag.estrategia": "Estratégia",
    "tag.epica": "Épica",
    "tag.hiphop": "Hip-Hop",
    "tag.jazz": "Jazz",
    "tag.criticasocial": "Crítica Social",
    "tag.biografia": "Biografia",
    "tag.historia": "História",
    "tag.noir": "Noir",
    "tag.rock": "Rock",
    "tag.conceitual": "Conceptual",
    "tag.ciberpunk": "Ciberpunk",
    "tag.alternativo": "Alternativo",
    "tag.acao": "Ação",
    "tag.romance": "Romance",
    "tag.horror": "Terror",
    "tag.cinema": "Cinema",
    "tag.suspense": "Suspense",
    "tag.jogos": "Jogos",
    "tag.art": "Arte",
    "tag.literatura": "Literatura",
    "tag.classico": "Clássico",
    "tag.musica": "Música",
    "tag.cultura": "Cultura",
    "tag.futurismo": "Futurismo",
    "tag.tecnologia": "Tecnologia",

    // --- PERFIL E SETTINGS ---
    "favorites.title_prefix": "Favoritos de",
    "favorites.my_title": "Meus favoritos",
    "reviews.title_prefix": "Resenhas de",
    "reviews.my_title": "Minhas resenhas",
    "settings.title": "Configurações",
    "settings.nav.profile": "Perfil",
    "settings.nav.account": "Conta",
    "settings.nav.preferences": "Preferências",
    "settings.profile.title": "Perfil Público",
    "settings.profile.subtitle": "Como você aparece para outros no Mazarbul.",
    "settings.profile.avatar": "Foto de Perfil",
    "settings.profile.avatar.change": "Mudar foto",
    "settings.profile.avatar.remove": "Remover",
    "settings.profile.firstname": "Nome",
    "settings.profile.lastname": "Sobrenome",
    "settings.profile.username": "Nome de usuário (@)",
    "settings.profile.username.locked":
    "Nomes de usuário não podem ser alterados.",
    "settings.profile.bio": "Sua Bio",
    "settings.profile.bio.placeholder": "Escreva um pouco sobre você...",
    "settings.profile.save_button": "Salvar alterações do Perfil",
    "settings.profile.save_button.saving": "Salvando...",
    "settings.profile.save_button.saved": "Salvo!",
    "settings.account.title": "Conta",
    "settings.account.subtitle":
    "Gerencie suas informações de login e segurança.",
    "settings.account.email": "Email",
    "settings.account.email.subtitle": "Seu email de login é",
    "settings.account.email.change_button": "Mudar Email",
    "settings.account.password": "Senha",
    "settings.account.password.subtitle": "Mudar Senha",
    "settings.account.password.current": "Senha Atual",
    "settings.account.password.new": "Nova Senha",
    "settings.account.password.confirm": "Confirmar Nova Senha",
    "settings.account.password.save_button": "Salvar Nova Senha",
    "settings.account.danger_zone": "Zona de Perigo",
    "settings.account.delete.button": "Excluir minha conta",
    "settings.account.delete.text": "Esta ação é permanente e irreversível.",
    "settings.preferences.title": "Preferências",
    "settings.preferences.subtitle":
    "Controle a privacidade do seu perfil e notificações.",
    "settings.preferences.privacy": "Privacidade",
    "settings.preferences.privacy.private_profile": "Perfil Privado",
    "settings.preferences.privacy.private_profile.desc":
    "Se ativado, seu perfil e atividades só serão visíveis para você.",
    "settings.preferences.notifications": "Notificações",
    "settings.preferences.notifications.email.title": "Notificações por Email",
    "settings.preferences.notifications.email.desc":
    "Receber emails quando alguém seguir você ou comentar em suas reviews.",
    "settings.preferences.save_button": "Salvar Preferências",
    "form.firstname": "Nome",
    "form.lastname": "Apellido",
    "form.email": "Email",
    "form.username": "Nome de usuário (@)",
    "form.username_rules":
    "4-20 caracteres. Apenas letras, números e underscores (_).",
    "form.password": "Senha",
    "form.confirm_password": "Confirmar senha",
    "form.placeholder.review": "Escreva sua review...",
    "alert.username_invalid_format": "Formato do @username inválido.",
    "alert.password_mismatch": "As senhas não conferem!",
    "login.title": "Login",
    "login.subtitle": "Acesse sua conta Mazarbul.",
    "login.forgot_password": "Esqueceu a senha?",
    "login.button": "Entrar",
    "login.no_account": "Ainda não tem uma conta?",
    "login.register_link": "Cadastre-se",
    "register.title": "Criar sua conta",
    "register.subtitle": "Junte-se à comunidade Mazarbul.",
    "register.button": "Criar conta",
    "register.already_have_account": "Já tem uma conta?",
    "register.login_link": "Faça login",
    "forgot.title": "Recuperar Senha",
    "forgot.subtitle":
    "Insira seu e-mail e enviaremos um link para criar uma nova senha.",
    "forgot.button": "Enviar link de recuperação",
    "forgot.back_to_login": "Lembrou a senha? Voltar para o Login",
    "forgot.success_title": "Link enviado!",
    "forgot.success_text":
    "Verifique sua caixa de entrada (e pasta de spam) nos próximos minutos.",
    "reset.title": "Crie sua nova senha",
    "reset.subtitle": "Quase lá! Insira sua nova senha abaixo.",
    "reset.button": "Salvar Nova Senha",
    "reset.success.title": "Senha Redefinida!",
    "reset.success.subtitle": "Sua senha foi alterada com sucesso.",
    "reset.success.button": "Ir para o Login",
  },
  EN: {
    // --- GENERAL ---
    "nav.back_home": "Back to home",
    "search.placeholder": "Quick search...",
    "a11y.open_search": "Open search",
    "a11y.toggle_theme": "Toggle theme",
    "a11y.toggle_language": "Change language",
    "a11y.settings_page": "Settings",
    "a11y.user_profile": "My profile",
    "a11y.add_favorite": "Add to favorites",
    "a11y.remove_favorite": "Remove from favorites",

    // --- SECTIONS ---
    "section.highlights": "Highlights",
    "section.recents": "Recents",
    "section.clubs": "Clubs",
    "section.favorites": "Favorites",
    "section.reviews": "Recent reviews",
    "section.collections": "My Lists",
    "section.friends": "Friends Activity",
    "section.synopsis": "Synopsis",
    "section.techDetails": "Technical Details",
    "section.yourReview": "Your Review",
    "section.communityAverage": "Community Average",
    "section.communityReviews": "Community Voices",

    // --- CLUBS (GENERAL) ---
    "clubs.title": "Explore Clubs",
    "clubs.subtitle":
    "Find your tribe, join group readings, and discuss your favorite works.",
    "club.reading_now": "Reading Now",
    "action.visit_club": "Visit Club",
    "clubs.search_placeholder": "Search clubs by name or tag...",
    "clubs.filter_all": "All",
    "clubs.filter_reading": "Reading",
    "clubs.filter_cinema": "Cinema",
    "clubs.filter_gaming": "Games",
    "clubs.filter_music": "Music",

    // --- CLUB CREATION ---
    "club.create.title": "Create New Club",
    "club.create.name_label": "Club Name",
    "club.create.name_placeholder": "Ex: Fellowship of the Ring",
    "club.create.handle_label": "Club Handle (@)",
    "club.create.handle_placeholder": "ex: fellowship_ring",
    "club.create.desc_label": "Short Description",
    "club.create.desc_placeholder": "What is this club about?",
    "club.create.banner_label": "Club Banner",
    "club.create.banner_help": "Upload an image to be the club cover.",
    "club.create.visual_label": "Visual Identity",
    "club.create.preview": "Banner Preview",
    "club.create.tags_label": "Tags (Max 3)",
    "club.create.rules_label": "Club Rules",
    "club.create.rules_placeholder": "1. Respect above all...",
    "club.create.cancel": "Cancel",
    "club.create.submit": "Create Club",

    // --- CLUB MANAGEMENT ---
    "club.manage.title": "Manage Club",
    "club.manage.tab_info": "Information",
    "club.manage.tab_members": "Members",
    "club.manage.tab_works": "Active Works",
    "club.manage.save": "Save Changes",
    "club.manage.approve": "Approve",
    "club.manage.reject": "Reject",
    "club.manage.kick": "Remove",
    "club.manage.promote": "Promote to Mod",
    "club.manage.demote": "Demote to Member",
    "club.manage.pending_requests": "Pending Requests",
    "club.manage.active_members": "Active Members",
    "club.manage.remove_work": "End Activity",

    // --- CLUB DETAILS ---
    "club.tab.overview": "Overview",
    "club.tab.discussions": "Discussions",
    "club.tab.members": "Members",
    "club.tab.history": "History",
    "club.section.active_works": "Active Works",
    "club.section.rules": "Club Rules",
    "club.section.about": "About",
    "club.section.general_topics": "General Topics",
    "club.action.join": "Join Club",
    "club.action.leave": "Leave Club",
    "club.action.manage": "Manage Club",
    "club.role.owner": "Founder",
    "club.role.mod": "Mod",
    "club.role.member": "Member",
    "club.next_meeting": "Next Meeting",
    "club.add_to_calendar": "Add to Calendar",
    "club.status.pending": "Pending Approval",
    "club.card.topics_open": "open topics",
    "club.card.participating": "participating",
    "club.card.cycle_prev": "Previous Cycle",
    "club.card.ended_at": "Ended on",
    "club.card.view_archived": "View archived topics",
    "club.card.responses": "replies",
    "club.card.by": "by",
    "club.card.view_details": "View details",
    "club.placeholder.no_activity": "No active work at the moment.",
    "club.placeholder.no_member": "No members found.",

    // --- TOPIC PAGE (NOVO) ---
    "topic.back_to": "Back to",
    "topic.pinned": "Pinned",
    "topic.started_on": "Started on",
    "topic.replies_count": "Replies",
    "topic.no_replies": "No replies yet. Be the first!",
    "topic.reply_placeholder": "Write your reply...",
    "topic.reply_button": "Reply",
    "topic.content_unavailable": "Content unavailable.",

    // Dynamic Activity Texts
    "club.activity.livro": "Reading Now",
    "club.activity.filme": "Watching Now",
    "club.activity.jogo": "Playing Now",
    "club.activity.album": "Listening Now",

    // --- ACHIEVEMENTS ---
    "section.achievements": "Achievements",
    "achievements.title": "Achievements",
    "achievements.subtitle":
    "Track your journey through the cultural multiverse.",
    "achievements.progress": "Progress",
    "achievements.locked": "Locked",
    "achievement.desc.the-one": "Log your literary journey over a year.",
    "achievement.desc.narya": "Log your musical journey over a year.",
    "achievement.desc.vilya": "Log your cinematic journey over a year.",
    "achievement.desc.nenya": "Log your gaming journey over a year.",
    "achievement.desc.life-universe-everything":
    "Complete the Sci-Fi works cycle in books, films, and games.",
    "achievement.desc.horror-business":
    "Complete the Horror works cycle in books, films, and games.",
    "achievement.desc.wood-between-worlds":
    "Complete the Fantasy works cycle in books, films, and games.",
    "achievement.desc.once-upon-time-west":
    "Complete the Western works cycle in books, films, and games.",
    "achievement.desc.kagemusha":
    "Complete the Eastern works cycle in books, films, and games.",
    "achievement.desc.help-me-eros":
    "Complete the Romance works cycle in books, films, and games.",
    "achievement.desc.guernica":
    "Complete the War works cycle in books, films, and games.",
    "achievement.desc.nighthawks":
    "Complete the Noir works cycle in books, films, and games.",
    "achievement.desc.perche-leggere-classici":
    "Review Books pre-1900, Films pre-1950, Albums pre-1970, or Games pre-2000.",
    "achievement.desc.zeitgeist":
    "Stay current by reviewing works released in the last decade.",
    "achievement.desc.moritarnon":
    "Discover and review historically banned or censored works.",
    "achievement.desc.arda":
    "Complete the analysis cycle of works from all 6 continents.",
    "achievement.desc.rhun":
    "Broaden horizons with works from countries outside the Global North.",
    "achievement.desc.khazad-dum": "Dig deep for independent or niche works.",
    "achievement.desc.manwe":
    "Defend a misunderstood work: High personal score vs. Low general average.",
    "achievement.desc.melkor":
    "Critique a crowd favorite: Low personal score vs. High general average.",
    "achievement.desc.trivium": "Complete the journey of a full trilogy.",
    "achievement.desc.quadrivium": "Complete the journey of a full tetralogy.",
    "achievement.desc.dagor-dagorath":
    "Reach the end of a book, film, or game saga.",

    // --- ACTIONS & LABELS ---
    "action.explore": "Explore",
    "action.see_more": "See more",
    "action.see_all": "See all",
    "action.manage": "Manage",
    "action.saveReview": "Save Review",
    "label.next": "Next",

    // --- DETAILS ---
    "details.author": "Author",
    "details.pages": "Pages",
    "details.director": "Director",
    "details.duration": "Duration",
    "details.genre": "Genre",
    "details.year": "Year",
    "details.country": "Country",

    "details.not_informed": "Not informed",
    "details.synopsis_not_available": "Synopsis not available in this language.",
    "details.no_synopsis": "No synopsis.",

    // --- LISTS ---
    "list.actions_title": "Actions",
    "list.owner_prefix": "List by",
    "list.empty_state": "This list does not have any items yet.",
    "list.create_new": "Create New List",
    "list.edit_title": "Edit List",
    "list.edit_mode": "Edit Lists",
    "list.delete_mode": "Delete Lists",
    "list.select_prompt": "Select a list from the right column",
    "list.select_to_edit_prompt":
    "Select a list from the right column to edit.",
    "list.select_to_delete_prompt":
    "Select a list from the right column to delete.",
    "list.or_create_prompt": "or create a new one.",
    "list.form_name": "Name",
    "list.form_name_placeholder": "Ex: Fantasy Classics",
    "list.form_desc": "Description",
    "list.form_desc_placeholder": "A short description of your list...",
    "list.form_create_button": "Create List",
    "list.form_save_button": "Save Changes",
    "list.form_delete_button": "Delete List",
    "list.delete_confirm": "Are you sure you want to delete this list?",
    "list.add_items_title": "Add Media",
    "list.add_media": "Add Media",
    "list.search_placeholder": "Search for movies, books, games...",
    "list.no_results": "No results found.",
    "list.current_items_title": "Items in List",
    "list.empty_state_editor": "Add media using the search above.",
    "list.item_singular": "item",
    "list.item_plural": "items",

    // --- FILTERS & TAGS ---
    "filter.all": "All",
    "filter.movies": "Movies",
    "filter.books": "Books",
    "filter.games": "Games",
    "filter.albums": "Albums",
    "badge.filme": "Movie",
    "badge.livro": "Book",
    "badge.jogo": "Game",
    "badge.album": "Album",
    "tag.scifi": "Sci-Fi",
    "tag.aventura": "Adventure",
    "tag.drama": "Drama",
    "tag.thriller": "Thriller",
    "tag.comedia": "Comedy",
    "tag.distopia": "Dystopian",
    "tag.politica": "Politics",
    "tag.roguelike": "Roguelike",
    "tag.mitologia": "Mythology",
    "tag.indie": "Indie",
    "tag.eletronica": "Electronic",
    "tag.disco": "Disco",
    "tag.funk": "Funk",
    "tag.rpg": "RPG",
    "tag.fantasia": "Fantasy",
    "tag.estrategia": "Strategy",
    "tag.epica": "Epic",
    "tag.hiphop": "Hip-Hop",
    "tag.jazz": "Jazz",
    "tag.criticasocial": "Social Commentary",
    "tag.biografia": "Biography",
    "tag.historia": "History",
    "tag.noir": "Noir",
    "tag.rock": "Rock",
    "tag.conceitual": "Conceptual",
    "tag.ciberpunk": "Cyberpunk",
    "tag.alternativo": "Alternative",
    "tag.acao": "Action",
    "tag.romance": "Romance",
    "tag.horror": "Horror",
    "tag.cinema": "Cinema",
    "tag.suspense": "Suspense",
    "tag.jogos": "Games",
    "tag.art": "Art",
    "tag.literatura": "Literature",
    "tag.classico": "Classic",
    "tag.musica": "Music",
    "tag.cultura": "Culture",
    "tag.futurismo": "Futurism",
    "tag.tecnologia": "Technology",

    // --- PROFILE & SETTINGS ---
    "favorites.title_prefix": "Favorites of",
    "favorites.my_title": "My favorites",
    "reviews.title_prefix": "Reviews by",
    "reviews.my_title": "My reviews",
    "settings.title": "Settings",
    "settings.nav.profile": "Profile",
    "settings.nav.account": "Account",
    "settings.nav.preferences": "Preferences",
    "settings.profile.title": "Public Profile",
    "settings.profile.subtitle": "How you appear to others on Mazarbul.",
    "settings.profile.avatar": "Profile Photo",
    "settings.profile.avatar.change": "Change photo",
    "settings.profile.avatar.remove": "Remove",
    "settings.profile.firstname": "First Name",
    "settings.profile.lastname": "Last Name",
    "settings.profile.username": "Username (@)",
    "settings.profile.username.locked": "Usernames cannot be changed.",
    "settings.profile.bio": "Your Bio",
    "settings.profile.bio.placeholder": "Write a little about yourself...",
    "settings.profile.save_button": "Save Profile Changes",
    "settings.profile.save_button.saving": "Saving...",
    "settings.profile.save_button.saved": "Saved!",
    "settings.account.title": "Account",
    "settings.account.subtitle": "Manage your login and security information.",
    "settings.account.email": "Email",
    "settings.account.email.subtitle": "Your login email is",
    "settings.account.email.change_button": "Change Email",
    "settings.account.password": "Password",
    "settings.account.password.subtitle": "Change Password",
    "settings.account.password.current": "Current Password",
    "settings.account.password.new": "New Password",
    "settings.account.password.confirm": "Confirm New Password",
    "settings.account.password.save_button": "Save New Password",
    "settings.account.danger_zone": "Danger Zone",
    "settings.account.delete.button": "Delete my account",
    "settings.account.delete.text":
    "This action is permanent and irreversible.",
    "settings.preferences.title": "Preferences",
    "settings.preferences.subtitle":
    "Control your profile privacy and notifications.",
    "settings.preferences.privacy": "Privacy",
    "settings.preferences.privacy.private_profile": "Private Profile",
    "settings.preferences.privacy.private_profile.desc":
    "If enabled, your profile and activities will only be visible to you.",
    "settings.preferences.notifications": "Notifications",
    "settings.preferences.notifications.email.title": "Email Notifications",
    "settings.preferences.notifications.email.desc":
    "Receive emails when someone follows you or comments on your reviews.",
    "settings.preferences.save_button": "Save Preferences",
    "form.firstname": "First Name",
    "form.lastname": "Last Name",
    "form.email": "Email",
    "form.username": "Username (@)",
    "form.username_rules":
    "4-20 characters. Letters, numbers, and underscores (_) only.",
    "form.password": "Password",
    "form.confirm_password": "Confirm password",
    "form.placeholder.review": "Write your review...",
    "alert.username_invalid_format": "@username format is invalid.",
    "alert.password_mismatch": "Passwords do not match!",
    "login.title": "Login",
    "login.subtitle": "Access your Mazarbul account.",
    "login.forgot_password": "Forgot password?",
    "login.button": "Sign In",
    "login.no_account": "Don't have an account yet?",
    "login.register_link": "Sign up",
    "register.title": "Create your account",
    "register.subtitle": "Join the Mazarbul community.",
    "register.button": "Create account",
    "register.already_have_account": "Already have an account?",
    "register.login_link": "Sign in",
    "forgot.title": "Recover Password",
    "forgot.subtitle":
    "Enter your email and we'll send a link to create a new password.",
    "forgot.button": "Send recovery link",
    "forgot.back_to_login": "Remembered your password? Back to Login",
    "forgot.success_title": "Link sent!",
    "forgot.success_text":
    "Check your inbox (and spam folder) in the next few minutes.",
    "reset.title": "Create your new password",
    "reset.subtitle": "Almost there! Enter your new password below.",
    "reset.button": "Save New Password",
    "reset.success.title": "Password Reset!",
    "reset.success.subtitle": "Your password has been changed successfully.",
    "reset.success.button": "Go to Login",
  },
  ES: {
    // --- GENERAL ---
    "nav.back_home": "Volver al inicio",
    "search.placeholder": "Búsqueda rápida...",
    "a11y.open_search": "Abrir búsqueda",
    "a11y.toggle_theme": "Alternar tema",
    "a11y.toggle_language": "Cambiar idioma",
    "a11y.settings_page": "Configuración",
    "a11y.user_profile": "Mi perfil",
    "a11y.add_favorite": "Añadir a favoritos",
    "a11y.remove_favorite": "Quitar de favoritos",

    // --- SECTIONS ---
    "section.highlights": "Destacados",
    "section.recents": "Recientes",
    "section.clubs": "Clubes",
    "section.favorites": "Favoritos",
    "section.reviews": "Reseñas recientes",
    "section.collections": "Mis Listas",
    "section.friends": "Actividad de Amigos",
    "section.synopsis": "Sinopsis",
    "section.techDetails": "Ficha Técnica",
    "section.yourReview": "Tu Reseña",
    "section.communityAverage": "Promedio de la Comunidad",
    "section.communityReviews": "Voces de la Comunidad",

    // --- CLUBES ---
    "clubs.title": "Explorar Clubes",
    "clubs.subtitle":
    "Encuentra tu tribu, participa en lecturas conjuntas y discute tus obras favoritas.",
    "club.reading_now": "Leyendo Ahora",
    "action.visit_club": "Visitar Club",
    "clubs.search_placeholder": "Buscar clubes por nombre o etiqueta...",
    "clubs.filter_all": "Todos",
    "clubs.filter_reading": "Lectura",
    "clubs.filter_cinema": "Cine",
    "clubs.filter_gaming": "Juegos",
    "clubs.filter_music": "Música",

    // --- CLUB CREATION ---
    "club.create.title": "Crear Nuevo Club",
    "club.create.name_label": "Nombre del Club",
    "club.create.name_placeholder": "Ej: La Comunidad del Anillo",
    "club.create.handle_label": "Identificador del Club (@)",
    "club.create.handle_placeholder": "ej: comunidad_anillo",
    "club.create.desc_label": "Descripción Corta",
    "club.create.desc_placeholder": "¿De qué trata este club?",
    "club.create.banner_label": "Banner del Club",
    "club.create.banner_help": "Sube una imagen para ser la portada del club.",
    "club.create.visual_label": "Identidad Visual",
    "club.create.preview": "Vista Previa del Banner",
    "club.create.tags_label": "Etiquetas (Máx. 3)",
    "club.create.rules_label": "Reglas del Club",
    "club.create.rules_placeholder": "1. Respeto ante todo...",
    "club.create.cancel": "Cancelar",
    "club.create.submit": "Crear Club",

    // --- CLUB MANAGEMENT (NOVO) ---
    "club.manage.title": "Gestionar Club",
    "club.manage.tab_info": "Información",
    "club.manage.tab_members": "Miembros",
    "club.manage.tab_works": "Obras Activas",
    "club.manage.save": "Guardar Cambios",
    "club.manage.approve": "Aprobar",
    "club.manage.reject": "Rechazar",
    "club.manage.kick": "Expulsar",
    "club.manage.promote": "Promover a Mod",
    "club.manage.demote": "Degradar a Miembro",
    "club.manage.pending_requests": "Solicitudes Pendientes",
    "club.manage.active_members": "Miembros Activos",
    "club.manage.remove_work": "Finalizar Actividad",

    // --- CLUB DETAILS ---
    "club.tab.overview": "Visión General",
    "club.tab.discussions": "Discusiones",
    "club.tab.members": "Miembros",
    "club.tab.history": "Historial",
    "club.section.active_works": "En Progreso",
    "club.section.rules": "Reglas del Club",
    "club.section.about": "Sobre",
    "club.section.general_topics": "Temas Generales",
    "club.action.join": "Unirse al Club",
    "club.action.leave": "Salir del Club",
    "club.action.manage": "Gestionar Club",
    "club.role.owner": "Fundador",
    "club.role.mod": "Mod",
    "club.role.member": "Miembro",
    "club.next_meeting": "Próxima Reunión",
    "club.add_to_calendar": "Añadir al Calendario",
    "club.status.pending": "Esperando Aprobación",

    "club.card.topics_open": "temas abiertos",
    "club.card.participating": "participando",
    "club.card.cycle_prev": "Ciclo Anterior",
    "club.card.ended_at": "Terminado en",
    "club.card.view_archived": "Ver temas archivados",
    "club.card.responses": "respuestas",
    "club.card.by": "por",
    "club.card.view_details": "Ver detalles",
    "club.placeholder.no_activity": "No hay actividad activa en este momento.",
    "club.placeholder.no_member": "No se encontraron miembros.",

    // --- TOPIC PAGE (NOVO) ---
    "topic.back_to": "Volver a",
    "topic.pinned": "Fijado",
    "topic.started_on": "Iniciado en",
    "topic.replies_count": "Respuestas",
    "topic.no_replies": "Aún no hay respuestas. ¡Sé el primero!",
    "topic.reply_placeholder": "Escribe tu respuesta...",
    "topic.reply_button": "Responder",
    "topic.content_unavailable": "Contenido no disponible.",

    // Dynamic Activity Texts
    "club.activity.livro": "Leyendo Ahora",
    "club.activity.filme": "Viendo Ahora",
    "club.activity.jogo": "Jugando Ahora",
    "club.activity.album": "Escuchando Ahora",

    // --- ACHIEVEMENTS ---
    "section.achievements": "Logros",
    "achievements.title": "Logros",
    "achievements.subtitle": "Sigue tu viaje a través del multiverso cultural.",
    "achievements.progress": "Progreso",
    "achievements.locked": "Bloqueado",
    "achievement.desc.the-one":
    "Registra tu viaje literario a lo largo de un año.",
    "achievement.desc.narya": "Registra tu viaje musical a lo largo de un año.",
    "achievement.desc.vilya":
    "Registra tu viaje cinematográfico a lo largo de un año.",
    "achievement.desc.nenya":
    "Registra tu viaje en videojuegos a lo largo de un año.",
    "achievement.desc.life-universe-everything":
    "Completa el ciclo de obras de Ciencia Ficción en libros, películas y juegos.",
    "achievement.desc.horror-business":
    "Completa el ciclo de obras de Terror en libros, películas y juegos.",
    "achievement.desc.wood-between-worlds":
    "Completa el ciclo de obras de Fantasía en libros, películas y juegos.",
    "achievement.desc.once-upon-time-west":
    "Completa el ciclo de obras Western en libros, películas y juegos.",
    "achievement.desc.kagemusha":
    "Completa el ciclo de obras Orientales en libros, películas y juegos.",
    "achievement.desc.help-me-eros":
    "Completa el ciclo de obras de Romance en libros, películas y juegos.",
    "achievement.desc.guernica":
    "Completa el ciclo de obras de Guerra en libros, películas y juegos.",
    "achievement.desc.nighthawks":
    "Completa el ciclo de obras Noir en libros, películas y juegos.",
    "achievement.desc.perche-leggere-classici":
    "Analiza Libros anteriores a 1900, Películas anteriores a 1950, Álbumes anteriores a 1970 o Juegos anteriores a 2000.",
    "achievement.desc.zeitgeist":
    "Mantente actualizado analizando obras lanzadas en la última década.",
    "achievement.desc.moritarnon":
    "Descubre y analiza obras que sufrieron censura o prohibición histórica.",
    "achievement.desc.arda":
    "Completa el ciclo de análisis de obras de los 6 continentes.",
    "achievement.desc.rhun":
    "Amplía horizontes con obras de países fuera del eje del Norte Global.",
    "achievement.desc.khazad-dum":
    "Excava profundamente en busca de obras independientes o de nicho.",
    "achievement.desc.manwe":
    "Defiende una obra incomprendida: Nota personal alta vs. Promedio general bajo.",
    "achievement.desc.melkor":
    "Critica un favorito de las masas: Nota personal baja vs. Promedio general alto.",
    "achievement.desc.trivium": "Completa el viaje de una trilogía entera.",
    "achievement.desc.quadrivium":
    "Completa el viaje de una tetralogía entera.",
    "achievement.desc.dagor-dagorath":
    "Llega al final de una saga de libros, películas o juegos.",

    // --- ACTIONS & LABELS ---
    "action.explore": "Explorar",
    "action.see_more": "Ver más",
    "action.see_all": "Ver todas",
    "action.manage": "Gestionar",
    "action.saveReview": "Guardar Reseña",
    "label.next": "Próximo",

    // --- DETAILS ---
    "details.author": "Autor",
    "details.pages": "Páginas",
    "details.director": "Director",
    "details.duration": "Duración",
    "details.genre": "Género",
    "details.year": "Año",
    "details.country": "País",

    "details.not_informed": "No informado",
    "details.synopsis_not_available": "Sinopsis no disponible en este idioma.",
    "details.no_synopsis": "Sin sinopsis.",

    // --- LISTS ---
    "list.actions_title": "Acciones",
    "list.owner_prefix": "Lista de",
    "list.empty_state": "Esta lista aún no tiene elementos.",
    "list.create_new": "Crear Nueva Lista",
    "list.edit_title": "Editar Lista",
    "list.edit_mode": "Editar Listas",
    "list.delete_mode": "Eliminar Listas",
    "list.select_prompt": "Selecciona una lista de la derecha",
    "list.select_to_edit_prompt":
    "Selecciona una lista de la derecha para editar.",
    "list.select_to_delete_prompt":
    "Selecciona una lista de la derecha para eliminar.",
    "list.or_create_prompt": "o crea una nueva.",
    "list.form_name": "Nombre",
    "list.form_name_placeholder": "Ej: Clássicos de Fantasía",
    "list.form_desc": "Descripción",
    "list.form_desc_placeholder": "Una breve descripción de tu lista...",
    "list.form_create_button": "Crear Lista",
    "list.form_save_button": "Guardar Cambios",
    "list.form_delete_button": "Eliminar Lista",
    "list.delete_confirm": "¿Estás seguro de que quieres eliminar esta lista?",
    "list.add_items_title": "Añadir Medios",
    "list.add_media": "Añadir Medios",
    "list.search_placeholder": "Buscar películas, libros, juegos...",
    "list.no_results": "No se encontraron resultados.",
    "list.current_items_title": "Elementos en la Lista",
    "list.empty_state_editor": "Añade medios usando la búsqueda de arriba.",
    "list.item_singular": "elemento",
    "list.item_plural": "elementos",

    // --- FILTROS E TAGS ---
    "filter.all": "Todos",
    "filter.movies": "Películas",
    "filter.books": "Libros",
    "filter.games": "Juegos",
    "filter.albums": "Álbumes",
    "badge.filme": "Película",
    "badge.livro": "Libro",
    "badge.jogo": "Juego",
    "badge.album": "Álbum",
    "tag.scifi": "Ciencia-Ficción",
    "tag.aventura": "Aventura",
    "tag.drama": "Drama",
    "tag.thriller": "Suspense",
    "tag.comedia": "Comedia",
    "tag.distopia": "Distopía",
    "tag.politica": "Política",
    "tag.roguelike": "Roguelike",
    "tag.mitologia": "Mitología",
    "tag.indie": "Indie",
    "tag.eletronica": "Electrónica",
    "tag.disco": "Disco",
    "tag.funk": "Funk",
    "tag.rpg": "RPG",
    "tag.fantasia": "Fantasía",
    "tag.estrategia": "Estrategia",
    "tag.epica": "Épica",
    "tag.hiphop": "Hip-Hop",
    "tag.jazz": "Jazz",
    "tag.criticasocial": "Crítica Social",
    "tag.biografia": "Biografía",
    "tag.historia": "Historia",
    "tag.noir": "Noir",
    "tag.rock": "Rock",
    "tag.conceitual": "Conceptual",
    "tag.ciberpunk": "Ciberpunk",
    "tag.alternativo": "Alternative",
    "tag.acao": "Acción",
    "tag.romance": "Romance",
    "tag.horror": "Terror",
    "tag.cinema": "Cine",
    "tag.suspense": "Suspense",
    "tag.jogos": "Juegos",
    "tag.art": "Arte",
    "tag.literatura": "Literatura",
    "tag.classico": "Clásico",
    "tag.musica": "Música",
    "tag.cultura": "Cultura",
    "tag.futurismo": "Futurismo",
    "tag.tecnologia": "Tecnología",

    // --- PERFIL E SETTINGS ---
    "favorites.title_prefix": "Favoritos de",
    "favorites.my_title": "Mis favoritos",
    "reviews.title_prefix": "Reseñas de",
    "reviews.my_title": "Mis reseñas",
    "settings.title": "Configuración",
    "settings.nav.profile": "Perfil",
    "settings.nav.account": "Cuenta",
    "settings.nav.preferences": "Preferencias",
    "settings.profile.title": "Perfil Público",
    "settings.profile.subtitle": "Cómo te ven los demás en Mazarbul.",
    "settings.profile.avatar": "Foto de Perfil",
    "settings.profile.avatar.change": "Cambiar foto",
    "settings.profile.avatar.remove": "Eliminar",
    "settings.profile.firstname": "Nombre",
    "settings.profile.lastname": "Apellido",
    "settings.profile.username": "Nombre de usuario (@)",
    "settings.profile.username.locked":
    "Los nombres de usuario no se pueden cambiar.",
    "settings.profile.bio": "Tu Biografía",
    "settings.profile.bio.placeholder": "Escribe un poco sobre ti...",
    "settings.profile.save_button": "Guardar cambios del Perfil",
    "settings.profile.save_button.saving": "Guardando...",
    "settings.profile.save_button.saved": "¡Guardado!",
    "settings.account.title": "Cuenta",
    "settings.account.subtitle":
    "Gestiona tu información de inicio de sesión y seguridad.",
    "settings.account.email": "Correo electrónico",
    "settings.account.email.subtitle": "Tu correo de inicio de sesión es",
    "settings.account.email.change_button": "Cambiar Correo",
    "settings.account.password": "Contraseña",
    "settings.account.password.subtitle": "Cambiar Contraseña",
    "settings.account.password.current": "Contraseña Actual",
    "settings.account.password.new": "Nueva Contraseña",
    "settings.account.password.confirm": "Confirmar Nueva Contraseña",
    "settings.account.password.save_button": "Guardar Nueva Contraseña",
    "settings.account.danger_zone": "Zona de Peligro",
    "settings.account.delete.button": "Eliminar mi cuenta",
    "settings.account.delete.text": "Esta acción es permanente e irreversible.",
    "settings.preferences.title": "Preferencias",
    "settings.preferences.subtitle":
    "Controla la privacidad de tu perfil y notificaciones.",
    "settings.preferences.privacy": "Privacidad",
    "settings.preferences.privacy.private_profile": "Perfil Privado",
    "settings.preferences.privacy.private_profile.desc":
    "Si está activado, tu perfil y actividades solo serán visibles para ti.",
    "settings.preferences.notifications": "Notificaciones",
    "settings.preferences.notifications.email.title":
    "Notificaciones por Correo",
    "settings.preferences.notifications.email.desc":
    "Recibir correos cuando alguien te siga o comente en tus reseñas.",
    "settings.preferences.save_button": "Guardar Preferencias",
    "form.firstname": "Nombre",
    "form.lastname": "Apellido",
    "form.email": "Correo electrónico",
    "form.username": "Nombre de usuario (@)",
    "form.username_rules":
    "4-20 caracteres. Solo letras, números y guiones bajos (_).",
    "form.password": "Contraseña",
    "form.confirm_password": "Confirmar contraseña",
    "form.placeholder.review": "Escribe tu reseña...",
    "alert.username_invalid_format": "El formato del @username no es válido.",
    "alert.password_mismatch": "¡Las contraseñas no coinciden!",
    "login.title": "Iniciar sesión",
    "login.subtitle": "Accede a tu cuenta Mazarbul.",
    "login.forgot_password": "¿Olvidaste tu contraseña?",
    "login.button": "Entrar",
    "login.no_account": "¿Aún no tienes una conta?",
    "login.register_link": "Regístrate",
    "register.title": "Crea tu cuenta",
    "register.subtitle": "Únete a la comunidad Mazarbul.",
    "register.button": "Crear cuenta",
    "register.already_have_account": "¿Ya tienes una conta?",
    "register.login_link": "Iniciar sesión",
    "forgot.title": "Recuperar Contraseña",
    "forgot.subtitle":
    "Ingresa tu correo y te enviaremos un enlace para crear una nueva contraseña.",
    "forgot.button": "Enviar enlace de recuperación",
    "forgot.back_to_login":
    "¿Recordaste tu contraseña? Volver a Iniciar Sesión",
    "forgot.success_title": "¡Enlace enviado!",
    "forgot.success_text":
    "Revisa tu bandeja de entrada (y la carpeta de spam) en los próximos minutos.",
    "reset.title": "Crea tu nueva contraseña",
    "reset.subtitle":
    "¡Casi listo! Ingresa tu nueva contraseña a continuación.",
    "reset.button": "Guardar Nueva Contraseña",
    "reset.success.title": "¡Contraseña Restablecida!",
    "reset.success.subtitle": "Tu contraseña ha sido cambiada exitosamente.",
    "reset.success.button": "Ir a Iniciar Sesión",
  },
};

export function useI18n() {
  const [lang, setLang] = useState(() => {
    if (typeof window === "undefined") return "PT";
    const saved = localStorage.getItem("lang_v1");
    if (saved === "PT" || saved === "EN" || saved === "ES") return saved;
    return "PT";
  });

  useEffect(() => {
    try {
      localStorage.setItem("lang_v1", lang);
    } catch (e) {
      console.error("Failed to save lang to localStorage", e);
    }
  }, [lang]);

  const t = (key, fallback) => {
    return (I18N[lang] && I18N[lang][key]) || I18N.PT[key] || fallback || key;
  };

  return { lang, setLang, t };
}
</file>

<file path="client/src/pages/DashboardPage/DashboardPage.jsx">
import React, { useEffect, useRef, useState } from "react";
import { Link } from "react-router-dom";
import { Loader2, Plus } from "lucide-react"; // Importando Loader e Plus

import { cx } from "../../utils/formatters";
import { useAuth } from "../../contexts/AuthContext.jsx";

import HeaderBar from "../../components/layout/HeaderBar/HeaderBar.jsx";
import ProfileHeader from "../../components/user/ProfileHeader/ProfileHeader.jsx";
import FavoritesSection from "../../components/user/FavoritesSection/FavoritesSection.jsx";
import BadgesRibbon from "../../components/user/BadgesRibbon/BadgesRibbon.jsx";
import ReviewsPanel from "../../components/user/ReviewsPanel/ReviewsPanel.jsx";
import ActivityCalendar from "../../components/dashboard/ActivityCalendar/ActivityCalendar.jsx";
import CollectionList from "../../components/dashboard/CollectionList/CollectionList.jsx";

export default function DashboardPage({ theme, setTheme, lang, setLang, t }) {
  // 1. Pegamos o loading para evitar o "piscar" do Alex
  const { currentUser, loading } = useAuth();

  const rightColumnRef = useRef(null);
  const [leftColumnHeight, setLeftColumnHeight] = useState(0);

  // Observer para layout (mantido igual)
  useEffect(() => {
    const measure = () => {
      if (rightColumnRef.current) {
        setLeftColumnHeight(rightColumnRef.current.offsetHeight);
      }
    };
    const timer = setTimeout(measure, 100);
    const ro = new ResizeObserver(measure);
    if (rightColumnRef.current) ro.observe(rightColumnRef.current);
    window.addEventListener("resize", measure);
    return () => {
      clearTimeout(timer);
      window.removeEventListener("resize", measure);
      if (rightColumnRef.current) ro.unobserve(rightColumnRef.current);
    };
  }, []);

  // 2. PROTEÇÃO CONTRA FLICKER: Enquanto carrega, mostra tela de loading
  if (loading) {
    return (
      <div className="min-h-screen bg-neutral-900 flex items-center justify-center">
      <Loader2 className="w-8 h-8 text-amber-500 animate-spin" />
      </div>
    );
  }

  // 3. CONSTRUÇÃO DO PERFIL REAL (Sem dados do Alex)
  // Se o usuário não tiver dados no banco, usamos defaults "Vazios"
  const realProfile = {
    name: currentUser?.name || "Usuário",
    handle: currentUser?.handle ? `@${currentUser.handle}` : "@usuario",
    avatar: currentUser?.avatarUrl || null, // Se for null, o componente usa placeholder
    // Bio padrão para usuário novo
    bio: currentUser?.bio || "Olá! Eu sou novo no Mazarbul. Ainda estou configurando meu perfil e explorando novos mundos.",
    location: "Terra Média",
    website: ""
  };

  // 4. DADOS VAZIOS (Por enquanto, pois a conta é nova)
  // Isso garante que você não veja os favoritos/reviews do Alex
  const emptyBadges = [];
  const emptyFavorites = [];
  const emptyReviews = [];
  const emptyCollections = [];

  // Tags padrão apenas para não ficar feio visualmente, ou array vazio se preferir
  const defaultTags = ["Novato", "Explorador"];

  return (
    <div className={cx(theme === "dark" ? "dark" : "", "font-sans")}>
    <div className="min-h-screen bg-neutral-50 text-neutral-900 dark:bg-neutral-950 dark:text-neutral-100">
    <HeaderBar
    theme={theme}
    setTheme={setTheme}
    lang={lang}
    setLang={setLang}
    t={t}
    />

    <main className="max-w-7xl mx-auto px-4 pt-24 pb-16 flex flex-col gap-8">
    {/* Header com seus dados reais */}
    <ProfileHeader profile={realProfile} tags={defaultTags} t={t} />

    {/* Seção de Troféus (Vazia por enquanto) */}
    <div className="relative">
    <BadgesRibbon
    badges={emptyBadges}
    t={t}
    handle={currentUser?.handle}
    isOwner={true}
    />
    {/* Mensagem amigável de estado vazio */}
    {emptyBadges.length === 0 && (
      <p className="text-center text-sm text-neutral-500 italic mt-2">
      Sua jornada começou agora. Faça reviews para ganhar emblemas.
      </p>
    )}
    </div>

    {/* Favoritos (Vazio) */}
    <FavoritesSection items={emptyFavorites} t={t} handle={realProfile.handle} />

    <section className="grid grid-cols-1 lg:grid-cols-12 gap-6 items-start">
    <div className="lg:col-span-7">
    {/* Reviews (Vazio) */}
    <ReviewsPanel
    reviews={emptyReviews}
    t={t}
    containerHeight={leftColumnHeight}
    handle={realProfile.handle}
    />
    {emptyReviews.length === 0 && (
      <div className="p-8 border border-dashed border-neutral-800 rounded-xl text-center text-neutral-500">
      <p>Você ainda não publicou nenhuma review.</p>
      <Link to="/" className="text-amber-500 hover:underline mt-2 inline-block">
      Explore mídias para avaliar
      </Link>
      </div>
    )}
    </div>

    <div
    ref={rightColumnRef}
    className="lg:col-span-5 flex flex-col gap-8"
    >
    <div className="mt-11">
    <ActivityCalendar reviews={emptyReviews} t={t} />
    </div>

    <CollectionList collections={emptyCollections} t={t} />
    </div>
    </section>
    </main>
    </div>
    </div>
  );
}
</file>

<file path="client/src/pages/LoginPage/LoginPage.jsx">
import React, { useState } from "react";
import { Link, useNavigate } from "react-router-dom";
import { Mail, Lock } from "lucide-react";
import { useAuth } from "../../contexts/AuthContext"; // Importação do Contexto
import HeaderBar from "../../components/layout/HeaderBar/HeaderBar.jsx";

function LoginPage({ theme, setTheme, lang, setLang, t }) {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");

  // Novos estados apenas para feedback visual (erro/loading)
  const [error, setError] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  const navigate = useNavigate();
  const { signIn } = useAuth(); // Pegamos a função real

  const safeT = (key, fallback) => {
    if (typeof t === "function") {
      const translated = t(key);
      if (translated === key && fallback) {
        return fallback;
      }
      return translated;
    }
    return fallback || key;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    setIsSubmitting(true);

    // --- CONEXÃO REAL ---
    const result = await signIn(email, password);

    if (result.success) {
      navigate("/dashboard");
    } else {
      setError(result.message);
      setIsSubmitting(false);
    }
  };

  return (
    <div className="min-h-screen w-full bg-neutral-50 dark:bg-neutral-950 text-neutral-900 dark:text-neutral-100">
    <HeaderBar
    theme={theme}
    setTheme={setTheme}
    lang={lang}
    setLang={setLang}
    t={safeT}
    />

    <main className="pt-20">
    <div className="flex flex-col items-center justify-center px-4 py-12 sm:px-6 lg:px-8">
    <div className="w-full max-w-sm">
    <div className="rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white/80 dark:bg-neutral-900/70 backdrop-blur-sm shadow-sm overflow-hidden">
    <div className="p-6 sm:p-8">
    <div className="flex flex-col items-center text-center mb-6">
    <h2 className="text-2xl sm:text-3xl font-semibold tracking-tight">
    {safeT("login.title", "Login")}
    </h2>
    <p className="text-sm text-neutral-600 dark:text-neutral-400 mt-2">
    {safeT("login.subtitle", "Acesse sua conta Mazarbul.")}
    </p>
    </div>

    {/* Exibição de Erro (Discreta, mantendo o design) */}
    {error && (
      <div className="mb-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg text-red-600 dark:text-red-400 text-sm text-center">
      {error}
      </div>
    )}

    {/* Formulário */}
    <form onSubmit={handleSubmit} className="space-y-4">
    {/* Campo Email */}
    <div className="relative">
    <span className="absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500">
    <Mail className="w-5 h-5" />
    </span>
    <input
    type="email"
    id="email"
    value={email}
    onChange={(e) => setEmail(e.target.value)}
    required
    placeholder={safeT("form.email", "Email")}
    className="w-full pl-10 pr-4 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
    />
    </div>

    {/* Campo Senha */}
    <div className="relative">
    <span className="absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500">
    <Lock className="w-5 h-5" />
    </span>
    <input
    type="password"
    id="password"
    value={password}
    onChange={(e) => setPassword(e.target.value)}
    required
    placeholder={safeT("form.password", "Senha")}
    className="w-full pl-10 pr-4 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
    />
    </div>

    {/* Esqueci a senha */}
    <div className="text-right">
    <Link
    to="/forgot-password"
    className="text-sm font-medium text-blue-600 hover:text-blue-500 dark:text-blue-500 dark:hover:text-blue-400"
    >
    {safeT("login.forgot_password", "Esqueceu a senha?")}
    </Link>
    </div>

    {/* Botão Entrar */}
    <button
    type="submit"
    disabled={isSubmitting}
    className={`w-full inline-flex items-center justify-center rounded-lg bg-blue-600 px-4 py-2.5 text-sm font-medium text-white shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-neutral-900 ${isSubmitting ? 'opacity-70 cursor-not-allowed' : ''}`}
    >
    {isSubmitting ? "Carregando..." : safeT("login.button", "Entrar")}
    </button>
    </form>
    </div>

    {/* Link para Cadastro */}
    <div className="border-t border-neutral-200 dark:border-neutral-800 bg-neutral-50/50 dark:bg-neutral-900/30 px-6 py-4">
    <p className="text-center text-sm text-neutral-600 dark:text-neutral-400">
    {safeT("login.no_account", "Ainda não tem uma conta?")}{" "}
    <Link
    to="/register"
    className="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-500 dark:hover:text-blue-400"
    >
    {safeT("login.register_link", "Cadastre-se")}
    </Link>
    </p>
    </div>
    </div>
    </div>
    </div>
    </main>
    </div>
  );
}

export default LoginPage;
</file>

<file path="client/src/pages/RegisterPage/RegisterPage.jsx">
import React, { useState } from "react";
import { Link, useNavigate } from "react-router-dom";
import { Mail, Lock, User, AtSign, AlertCircle } from "lucide-react"; // Adicionei AlertCircle
import HeaderBar from "../../components/layout/HeaderBar/HeaderBar.jsx";
import api from "../../services/api"; // Conexão com o Backend
import { useAuth } from "../../contexts/AuthContext"; // Para auto-login

// Regex para validar o FORMATO do @username
const USERNAME_REGEX = /^[a-zA-Z0-9_]{4,20}$/;

function RegisterPage({ theme, setTheme, lang, setLang, t }) {
  const [nome, setNome] = useState("");
  const [sobrenome, setSobrenome] = useState("");
  const [email, setEmail] = useState("");
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");

  // Estados de controle e validação
  const [isUsernameValid, setIsUsernameValid] = useState(true);
  const [isUsernameTouched, setIsUsernameTouched] = useState(false);

  // Novos estados para integração
  const [error, setError] = useState("");
  const [isSubmitting, setIsSubmitting] = useState(false);

  const navigate = useNavigate();
  const { signIn } = useAuth(); // Importamos a função de login

  const getT = (key, fallback) => {
    if (typeof t === "function") {
      const translated = t(key);
      if (translated === key && fallback) {
        return fallback;
      }
      return translated;
    }
    return fallback || key;
  };

  const handleUsernameChange = (e) => {
    const value = e.target.value;
    setUsername(value);

    if (!isUsernameTouched) {
      setIsUsernameTouched(true);
    }
    setIsUsernameValid(USERNAME_REGEX.test(value));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(""); // Limpa erros anteriores

    // 1. Validação de formato (client-side)
    if (!USERNAME_REGEX.test(username)) {
      setIsUsernameValid(false);
      setIsUsernameTouched(true);
      // Aqui podemos definir o erro no estado visual em vez de alert
      setError(getT("alert.username_invalid_format", "Formato do @username inválido."));
      return;
    }

    // 2. Validação de senha (client-side)
    if (password !== confirmPassword) {
      setError(getT("alert.password_mismatch", "As senhas não conferem!"));
      return;
    }

    setIsSubmitting(true);

    try {
      // 3. Concatena Nome e Sobrenome para o padrão do Backend
      const fullName = `${nome.trim()} ${sobrenome.trim()}`;

      // 4. Chamada REAL ao Backend
      await api.post('/auth/register', {
        name: fullName,
        email: email,
        password: password,
        handle: username
      });

      // 5. Se chegou aqui, deu certo! Vamos fazer Login Automático.
      await signIn(email, password);

      // 6. Redireciona para o Dashboard
      navigate("/dashboard");

    } catch (err) {
      console.error("Erro no cadastro:", err);
      // Pega a mensagem de erro do backend (ex: "Email já está em uso")
      const backendMessage = err.response?.data?.error || "Falha ao criar conta. Tente novamente.";
      setError(backendMessage);
      setIsSubmitting(false);
    }
  };

  return (
    <div className="min-h-screen w-full bg-neutral-50 dark:bg-neutral-950 text-neutral-900 dark:text-neutral-100">
    <HeaderBar
    theme={theme}
    setTheme={setTheme}
    lang={lang}
    setLang={setLang}
    t={getT}
    />

    <main className="pt-20">
    <div className="flex flex-col items-center justify-center px-4 py-12 sm:px-6 lg:px-8">
    <div className="w-full max-w-md">
    <div className="rounded-2xl border border-neutral-200 dark:border-neutral-800 bg-white/80 dark:bg-neutral-900/70 backdrop-blur-sm shadow-sm overflow-hidden">
    <div className="p-6 sm:p-8">
    <div className="flex flex-col items-center text-center mb-6">
    <h2 className="text-2xl sm:text-3xl font-semibold tracking-tight">
    {getT("register.title", "Criar sua conta")}
    </h2>
    <p className="text-sm text-neutral-600 dark:text-neutral-400 mt-2">
    {getT("register.subtitle", "Junte-se à comunidade Mazarbul.")}
    </p>
    </div>

    {/* Exibição de Erro do Backend */}
    {error && (
      <div className="mb-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg flex items-center gap-2 text-red-600 dark:text-red-400 text-sm">
      <AlertCircle className="w-4 h-4 shrink-0" />
      <span>{error}</span>
      </div>
    )}

    <form onSubmit={handleSubmit} className="space-y-4">
    {/* --- CAMPOS: NOME E SOBRENOME --- */}
    <div className="flex flex-col sm:flex-row gap-4">
    <div className="relative w-full">
    <span className="absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500">
    <User className="w-5 h-5" />
    </span>
    <input
    type="text"
    id="firstname"
    value={nome}
    onChange={(e) => setNome(e.target.value)}
    required
    placeholder={getT("form.firstname", "Nome")}
    className="w-full pl-10 pr-4 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
    />
    </div>
    <div className="relative w-full">
    <span className="absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500 opacity-0">
    <User className="w-5 h-5" />
    </span>
    <input
    type="text"
    id="lastname"
    value={sobrenome}
    onChange={(e) => setSobrenome(e.target.value)}
    required
    placeholder={getT("form.lastname", "Sobrenome")}
    className="w-full pl-4 sm:pl-3 pr-4 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
    />
    </div>
    </div>

    {/* Campo de Email */}
    <div className="relative">
    <span className="absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500">
    <Mail className="w-5 h-5" />
    </span>
    <input
    type="email"
    id="email"
    value={email}
    onChange={(e) => setEmail(e.target.value)}
    required
    placeholder={getT("form.email", "Email")}
    className="w-full pl-10 pr-4 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
    />
    </div>

    {/* --- CAMPO @USERNAME --- */}
    <div className="relative">
    <span className="absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500">
    <AtSign className="w-5 h-5" />
    </span>
    <input
    type="text"
    id="username"
    value={username}
    onChange={handleUsernameChange}
    onBlur={() => setIsUsernameTouched(true)}
    required
    placeholder={getT("form.username", "Nome de usuário (@)")}
    className={`w-full pl-10 pr-4 py-2.5 rounded-lg border bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm ${
      !isUsernameValid && isUsernameTouched
      ? "border-red-500 dark:border-red-400"
      : "border-neutral-300 dark:border-neutral-700"
    }`}
    />
    </div>

    {/* REGRAS DE VALIDAÇÃO (Visível) */}
    <p
    className={`text-xs px-1 ${
      !isUsernameValid && isUsernameTouched
      ? "text-red-600 dark:text-red-400"
      : "text-neutral-500 dark:text-neutral-400"
    }`}
    >
    {getT(
      "form.username_rules",
      "4-20 caracteres. Apenas letras, números e underscores (_)."
    )}
    </p>

    {/* Campo de Senha */}
    <div className="relative">
    <span className="absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500">
    <Lock className="w-5 h-5" />
    </span>
    <input
    type="password"
    id="password"
    value={password}
    onChange={(e) => setPassword(e.target.value)}
    required
    placeholder={getT("form.password", "Senha")}
    className="w-full pl-10 pr-4 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
    />
    </div>

    {/* Campo de Confirmar Senha */}
    <div className="relative">
    <span className="absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500">
    <Lock className="w-5 h-5" />
    </span>
    <input
    type="password"
    id="confirmPassword"
    value={confirmPassword}
    onChange={(e) => setConfirmPassword(e.target.value)}
    required
    placeholder={getT("form.confirm_password", "Confirmar senha")}
    className="w-full pl-10 pr-4 py-2.5 rounded-lg border border-neutral-300 dark:border-neutral-700 bg-white dark:bg-neutral-900 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-sm"
    />
    </div>

    <button
    type="submit"
    disabled={isSubmitting}
    className={`w-full inline-flex items-center justify-center rounded-lg bg-blue-600 px-4 py-2.5 text-sm font-medium text-white shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-neutral-900 ${isSubmitting ? 'opacity-70 cursor-not-allowed' : ''}`}
    >
    {isSubmitting ? "Cadastrando..." : getT("register.button", "Criar conta")}
    </button>
    </form>
    </div>

    <div className="border-t border-neutral-200 dark:border-neutral-800 bg-neutral-50/50 dark:bg-neutral-900/30 px-6 py-4">
    <p className="text-center text-sm text-neutral-600 dark:text-neutral-400">
    {getT("register.already_have_account", "Já tem uma conta?")}{" "}
    <Link
    to="/login"
    className="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-500 dark:hover:text-blue-400"
    >
    {getT("register.login_link", "Faça login")}
    </Link>
    </p>
    </div>
    </div>
    </div>
    </div>
    </main>
    </div>
  );
}

export default RegisterPage;
</file>

<file path="client/package.json">
{
  "name": "mazarbul",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.13.2",
    "framer-motion": "^11.2.10",
    "lucide-react": "^0.395.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^7.9.4"
  },
  "devDependencies": {
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.19",
    "postcss": "^8.4.38",
    "tailwindcss": "^3.4.4",
    "vite": "^5.2.0"
  }
}
</file>

<file path="server/src/routes/media.routes.js">
import { Router } from 'express';
import { searchMedia, getMediaDetails } from '../controllers/media.controller.js';

const router = Router();

// 1. A Rota de Busca DEVE vir antes da rota de ID
// GET /api/media/search?q=Avatar&type=filme
router.get('/search', searchMedia);

// 2. Rota de Detalhes
// GET /api/media/tmdb_550
router.get('/:id', getMediaDetails);

export default router;
</file>

<file path="server/src/services/auth.service.js">
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

const prisma = new PrismaClient();
const JWT_SECRET = process.env.JWT_SECRET || 'chave-secreta-super-segura-do-mazarbul';

// Função auxiliar para gerar o Token
const generateToken = (userId) => {
    return jwt.sign({ id: userId }, JWT_SECRET, { expiresIn: '7d' });
};

export const registerUser = async (data) => {
    const { name, email, handle, password } = data;

    // 1. Verificar se usuário já existe
    const userExists = await prisma.user.findFirst({
        where: {
            OR: [{ email }, { handle }]
        }
    });

    if (userExists) {
        throw new Error('Email ou Handle já estão em uso.');
    }

    // 2. Criptografar a senha
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    // 3. Criar usuário no Banco
    const user = await prisma.user.create({
        data: {
            name,
            email,
            handle,
            password: hashedPassword,
        },
    });

    // 4. Retornar dados ESTRUTURADOS (user + token separados)
    return {
        user: {
            id: user.id,
            name: user.name,
            handle: user.handle,
            email: user.email,
            avatarUrl: user.avatarUrl || null, // Garante que o campo vá, mesmo vazio
        },
        token: generateToken(user.id),
    };
};

export const loginUser = async (email, password) => {
    // 1. Buscar usuário pelo email
    const user = await prisma.user.findUnique({ where: { email } });

    if (!user) {
        throw new Error('Credenciais inválidas.');
    }

    // 2. Verificar se a senha bate
    const isMatch = await bcrypt.compare(password, user.password);

    if (!isMatch) {
        throw new Error('Credenciais inválidas.');
    }

    // 3. Retornar dados ESTRUTURADOS
    return {
        user: {
            id: user.id,
            name: user.name,
            handle: user.handle,
            email: user.email,
            avatarUrl: user.avatarUrl || null,
        },
        token: generateToken(user.id),
    };
};
</file>

<file path="server/src/utils/books.adapter.js">
import axios from 'axios';

const OPEN_LIBRARY_URL = 'https://openlibrary.org';
const GOOGLE_BOOKS_URL = 'https://www.googleapis.com/books/v1/volumes';

const getGoogleBooksKey = () =>
process.env.GOOGLE_BOOKS_API_KEY || process.env.GOOGLE_BOOKS_KEY || null;

const olClient = axios.create({ baseURL: OPEN_LIBRARY_URL });

const OL_LANG_BY_UI = {
    PT: 'por',
    EN: 'eng',
    ES: 'spa',
};

const GB_LANG_BY_UI = {
    PT: 'pt',
    EN: 'en',
    ES: 'es',
};

const BOOKS_ADAPTER_CONFIG = {
    MIN_EDITIONS_PER_LANG: 10,
    MAX_TOTAL_EDITIONS: 800,
    PAGE_SIZE: 200,
    STAGNANT_PAGES_LIMIT: 3,
};

const normalizeText = (s) =>
String(s || '')
.toLowerCase()
.normalize('NFD')
.replace(/[\u0300-\u036f]/g, '')
.replace(/[^a-z0-9\s]/g, ' ')
.replace(/\s+/g, ' ')
.trim();

const uniqStrings = (arr) => {
    const out = [];
    const seen = new Set();
    for (const v of arr || []) {
        if (typeof v !== 'string') continue;
        const t = v.trim();
        if (!t) continue;
        const k = t.toLowerCase();
        if (seen.has(k)) continue;
        seen.add(k);
        out.push(t);
    }
    return out;
};

const extractYear = (input) => {
    if (!input) return null;
    const m = String(input).match(/\d{4}/);
    if (!m) return null;
    const y = parseInt(m[0], 10);
    return Number.isFinite(y) ? y : null;
};

const olDescriptionToString = (desc) => {
    if (!desc) return null;
    if (typeof desc === 'string') return desc.trim() || null;
    if (typeof desc === 'object' && typeof desc.value === 'string') return desc.value.trim() || null;
    return null;
};

const getEditionLangKey = (edition) => {
    const langs = edition?.languages;
    if (!Array.isArray(langs) || langs.length === 0) return null;
    const key = langs[0]?.key || null;
    if (!key) return null;
    const parts = String(key).split('/');
    return parts[parts.length - 1] || null;
};

const extractIsbns = (edition) => {
    const out = [];
    const add = (v) => {
        if (!v) return;
        if (Array.isArray(v)) v.forEach(add);
        else out.push(String(v));
    };
        add(edition?.isbn_13);
        add(edition?.isbn_10);

        return uniqStrings(out)
        .map((x) => x.replace(/[^0-9Xx]/g, '').toUpperCase())
        .filter((x) => x.length === 10 || x.length === 13);
};

const splitCategoryTokens = (categories) => {
    const out = [];
    for (const c of categories || []) {
        if (typeof c !== 'string') continue;
        const trimmed = c.trim();
        if (!trimmed) continue;

        const parts = trimmed.split('/').map((p) => p.trim()).filter(Boolean);
        if (parts.length > 0) out.push(...parts);
        else out.push(trimmed);
    }
    return out;
};

const filterNoisyBookTokens = (tokens) => {
    const out = [];
    for (const t of tokens || []) {
        const n = normalizeText(t);
        if (!n) continue;

        if (n.includes('education') || n.includes('educacion') || n.includes('educacao')) continue;
        if (n.includes('study aid') || n.includes('study aids')) continue;
        if (n.includes('textbook') || n.includes('textbooks')) continue;
        if (n.includes('reference')) continue;
        if (n.includes('curriculum')) continue;
        if (n.includes('teaching')) continue;

        out.push(t);
    }
    return out;
};

const containsTieInTokens = (text) => {
    const t = normalizeText(text);
    if (!t) return false;

    const tokens = [
        'movie tie in',
        'film tie in',
        'motion picture',
        'official movie',
        'now a major motion picture',
        'part two',
        'part 2',
        'part one',
        'part 1',
        'graphic novel',
        'screenplay',
        'companion',
        'guide',
        'making of',
        'behind the scenes',
        'coloring book',
        'colouring book',
        'illustrated edition',
        'art and soul',
    ];

    return tokens.some((k) => t.includes(k));
};

const looksLikeFilmMarketing = (text) => {
    const t = normalizeText(text);
    if (!t) return false;

    const markers = [
        'denis villeneuve',
        'chalamet',
        'zendaya',
        'warner',
        'legendary',
        'in theaters',
        'in cinemas',
        'major motion picture',
        'motion picture',
        'directed by',
        'director',
        'part two',
        'part 2',
        'part one',
        'part 1',
    ];

    let count = 0;
    for (const m of markers) if (t.includes(m)) count += 1;

    return count >= 2;
};

const isPlausibleSynopsis = (text) => {
    if (!text) return false;
    const s = String(text).trim();
    if (!s) return false;

    if (s.length < 30) return false;
    if (looksLikeFilmMarketing(s)) return false;

    return true;
};

const getEditionPublishYear = (edition) => extractYear(edition?.publish_date);

const scoreEdition = (edition, targetLangKey, originalYear) => {
    let score = 0;

    const edLang = getEditionLangKey(edition);
    if (edLang && targetLangKey && edLang === targetLangKey) score += 60;

    const isbns = extractIsbns(edition);
    if (isbns.length > 0) score += 25;

    if (Array.isArray(edition?.covers) && edition.covers.length > 0) score += 10;

    const desc = olDescriptionToString(edition?.description);
    if (desc && isPlausibleSynopsis(desc)) score += 6;

    const pubYear = getEditionPublishYear(edition);
    if (originalYear && pubYear) {
        const dist = Math.abs(pubYear - originalYear);
        if (dist <= 2) score += 12;
        else if (dist <= 5) score += 8;
        else if (dist <= 15) score += 2;
        else if (dist >= 40) score -= 12;
    }

    const title = String(edition?.title || '');
    if (title) score += 5;
    if (containsTieInTokens(title)) score -= 35;

    return score;
};

const pickBestEdition = (editions, targetLangKey, originalYear) => {
    if (!Array.isArray(editions) || editions.length === 0) return null;

    const subset = targetLangKey ? editions.filter((e) => getEditionLangKey(e) === targetLangKey) : [];
    const pool = subset.length > 0 ? subset : editions;

    let best = null;
    let bestScore = -Infinity;

    for (const ed of pool) {
        const s = scoreEdition(ed, targetLangKey, originalYear);
        if (s > bestScore) {
            bestScore = s;
            best = ed;
        }
    }

    return best;
};

const inferCountryIso2 = (edition) => {
    const code = String(edition?.publish_country || '').toLowerCase().trim();
    if (code) {
        if (code.endsWith('u')) return 'US';
        if (code.endsWith('k')) return 'GB';
        if (code.endsWith('s')) return 'ES';
        if (code.endsWith('p')) return 'PT';
        if (code.endsWith('b')) return 'BR';
        if (code.endsWith('f')) return 'FR';
        if (code.endsWith('g')) return 'DE';
    }

    const places = Array.isArray(edition?.publish_places) ? edition.publish_places : [];
    const p = normalizeText(places.join(' '));
    if (!p) return null;

    if (p.includes('new york') || p.includes('boston') || p.includes('chicago')) return 'US';
    if (p.includes('london') || p.includes('oxford') || p.includes('cambridge')) return 'GB';
    if (p.includes('madrid') || p.includes('barcelona')) return 'ES';
    if (p.includes('lisbon') || p.includes('lisboa') || p.includes('porto')) return 'PT';
    if (p.includes('sao paulo') || p.includes('rio de janeiro') || p.includes('brasilia')) return 'BR';

    return null;
};

const pickCountryIso2 = (editions, originalYear) => {
    if (!Array.isArray(editions) || editions.length === 0) return null;

    const pool = editions.filter(
        (e) => e?.publish_country || (Array.isArray(e?.publish_places) && e.publish_places.length > 0)
    );

    if (pool.length === 0) return null;

    let best = null;
    let bestScore = -Infinity;

    for (const ed of pool) {
        let score = 0;
        const y = getEditionPublishYear(ed);
        if (originalYear && y) {
            const dist = Math.abs(y - originalYear);
            if (dist <= 2) score += 25;
            else if (dist <= 5) score += 15;
            else if (dist <= 15) score += 5;
            else if (dist >= 40) score -= 10;
        }

        if (ed?.publish_country) score += 15;
        if (Array.isArray(ed?.publish_places) && ed.publish_places.length > 0) score += 8;

        if (score > bestScore) {
            bestScore = score;
            best = ed;
        }
    }

    if (!best) return null;
    return inferCountryIso2(best);
};

const googleRequest = async (params) => {
    const key = getGoogleBooksKey();
    const finalParams = key ? { ...params, key } : params;
    const res = await axios.get(GOOGLE_BOOKS_URL, { params: finalParams });
    return res.data || {};
};

const getGoogleVolumeInfo = (item) => item?.volumeInfo || {};

const googleLanguageMatches = (item, expectedLang2) => {
    const lang = String(getGoogleVolumeInfo(item)?.language || '').toLowerCase().trim();
    if (!lang) return false;
    return lang === expectedLang2 || lang.startsWith(`${expectedLang2}-`);
};

const authorMatchesStrict = (authors, targetAuthor) => {
    if (!targetAuthor) return true;
    const target = normalizeText(targetAuthor);
    if (!target) return true;

    const first = normalizeText(Array.isArray(authors) ? authors[0] : '');
    if (!first) return false;

    return first.includes(target) || target.includes(first);
};

const scoreGoogleItem = (item, ctx) => {
    const info = getGoogleVolumeInfo(item);
    const title = String(info?.title || '').trim();
    if (!title) return -Infinity;

    const expectedLang2 = String(ctx?.expectedLang2 || '').toLowerCase();
    if (expectedLang2 && !googleLanguageMatches(item, expectedLang2)) return -Infinity;

    const authors = Array.isArray(info?.authors) ? info.authors : [];
    if (!authorMatchesStrict(authors, ctx?.targetAuthor)) return -1000;

    let score = 0;

    const titleNorm = normalizeText(title);
    const targetTitleNorm = normalizeText(ctx?.targetTitle || '');

    if (targetTitleNorm) {
        if (titleNorm === targetTitleNorm) score += 60;
        else if (titleNorm.includes(targetTitleNorm) || targetTitleNorm.includes(titleNorm)) score += 25;
        else score += 5;
    }

    if (authors.length > 0) score += 10;

    const year = extractYear(info?.publishedDate);
    if (ctx?.originalYear && year) {
        const dist = Math.abs(year - ctx.originalYear);
        if (dist <= 2) score += 12;
        else if (dist <= 5) score += 8;
        else if (dist <= 15) score += 2;
        else if (dist >= 40) score -= 20;
    }

    if (containsTieInTokens(title)) score -= 60;
    if (containsTieInTokens(info?.subtitle || '')) score -= 30;

    const desc = info?.description;
    if (typeof desc === 'string') {
        const d = desc.trim();
        if (looksLikeFilmMarketing(d)) score -= 60;
        if (isPlausibleSynopsis(d)) score += 18;
        else score -= 10;
        if (d.length > 200) score += 8;
    } else {
        score -= 12;
    }

    const bad = [
        'art and soul',
        'making of',
        'behind the scenes',
        'graphic novel',
        'screenplay',
        'companion',
        'guide',
        'coloring book',
        'colouring book',
    ];
    if (bad.some((k) => titleNorm.includes(k))) score -= 60;

    return score;
};

const googlePickBest = (items, ctx) => {
    if (!Array.isArray(items) || items.length === 0) return null;

    let best = null;
    let bestScore = -Infinity;

    for (const it of items) {
        const s = scoreGoogleItem(it, ctx);
        if (s > bestScore) {
            bestScore = s;
            best = it;
        }
    }

    if (bestScore < -200) return null;
    return best;
};

const googleGetBestByIsbns = async (isbns, ctx) => {
    const expectedLang2 = String(ctx?.expectedLang2 || '').toLowerCase();

    for (const isbn of (isbns || []).slice(0, 3)) {
        try {
            const data = await googleRequest({
                q: `isbn:${isbn}`,
                langRestrict: expectedLang2 || undefined,
                maxResults: 15,
                printType: 'books',
            });

            const items = Array.isArray(data.items) ? data.items : [];
            const best = googlePickBest(items, ctx);
            if (best) return best;
        } catch (e) {}
    }

    return null;
};

const googleSearchBestByTitleAuthor = async (titleCandidates, author, ctx) => {
    const expectedLang2 = String(ctx?.expectedLang2 || '').toLowerCase();
    const titles = Array.isArray(titleCandidates) ? titleCandidates : [titleCandidates];

    for (const t of titles) {
        const cleanTitle = String(t || '').trim();
        if (!cleanTitle) continue;

        const cleanAuthor = String(author || '').trim();
        const q = cleanAuthor
        ? `intitle:"${cleanTitle}" inauthor:"${cleanAuthor}"`
        : `intitle:"${cleanTitle}"`;

        try {
            const data = await googleRequest({
                q,
                langRestrict: expectedLang2 || undefined,
                maxResults: 20,
                printType: 'books',
                orderBy: 'relevance',
            });

            const items = Array.isArray(data.items) ? data.items : [];
            const best = googlePickBest(items, ctx);
            if (best) return best;
        } catch (e) {}
    }

    return null;
};

const upgradeGoogleCoverUrl = (url) => {
    if (!url) return null;
    let u = String(url).replace('http:', 'https:');
    u = u.replace(/zoom=1\b/g, 'zoom=2');
    return u;
};

const pickBestGoogleCoverUrl = (googleItems) => {
    for (const item of googleItems || []) {
        if (!item) continue;
        const info = getGoogleVolumeInfo(item);
        const links = info?.imageLinks || {};
        const candidates = [
            links.extraLarge,
            links.large,
            links.medium,
            links.small,
            links.thumbnail,
            links.smallThumbnail,
        ].filter(Boolean);

        if (candidates.length > 0) return upgradeGoogleCoverUrl(candidates[0]);
    }
    return null;
};

const buildOlCoverByIdUrl = (coverId, size = 'L', strict = true) => {
    if (!coverId) return null;
    const suffix = strict ? '?default=false' : '';
    return `https://covers.openlibrary.org/b/id/${coverId}-${size}.jpg${suffix}`;
};

const buildOlCoverByIsbnUrl = (isbn, size = 'L', strict = true) => {
    if (!isbn) return null;
    const clean = String(isbn).trim();
    if (!clean) return null;
    const suffix = strict ? '?default=false' : '';
    return `https://covers.openlibrary.org/b/isbn/${clean}-${size}.jpg${suffix}`;
};

const getEditionOlid = (edition) => {
    const key = String(edition?.key || '').trim();
    if (!key) return null;
    const parts = key.split('/');
    const last = parts[parts.length - 1] || null;
    if (!last) return null;
    if (!/^OL/i.test(last)) return null;
    return last;
};

const buildOlCoverByOlidUrl = (olid, size = 'L', strict = true) => {
    if (!olid) return null;
    const clean = String(olid).trim();
    if (!clean) return null;
    const suffix = strict ? '?default=false' : '';
    return `https://covers.openlibrary.org/b/olid/${clean}-${size}.jpg${suffix}`;
};

const isImageUrlReachable = async (url) => {
    if (!url) return false;
    try {
        const res = await axios.get(url, {
            responseType: 'stream',
            timeout: 2500,
            validateStatus: (s) => s >= 200 && s < 400,
                                    headers: {
                                        'User-Agent': 'Mazarbul/1.0 (+https://localhost)',
                                    Accept: 'image/avif,image/webp,image/apng,image/*,*/*;q=0.8',
                                    },
        });

        const ct = String(res.headers?.['content-type'] || '').toLowerCase();
        if (res.data && typeof res.data.destroy === 'function') res.data.destroy();

        return ct.startsWith('image/');
    } catch (e) {
        return false;
    }
};

const pickFirstReachableImage = async (candidates, maxChecks = 30) => {
    const list = uniqStrings((candidates || []).filter(Boolean)).slice(0, maxChecks);
    for (const url of list) {
        // eslint-disable-next-line no-await-in-loop
        const ok = await isImageUrlReachable(url);
        if (ok) return url;
    }
    return null;
};

const orderGenresForBooks = (tokens) => {
    const norm = tokens.map((t) => normalizeText(t)).join(' ');
    const ordered = [];

    const pushIf = (label, cond) => {
        if (cond) ordered.push(label);
    };

        pushIf(
            'Science Fiction',
            norm.includes('science fiction') ||
            norm.includes('sci fi') ||
            norm.includes('ficcao cientifica') ||
            norm.includes('ficcion cientifica') ||
            norm.includes('ciencia ficcion')
        );
        pushIf('Fantasy', norm.includes('fantasy') || norm.includes('fantasia'));
        pushIf('Horror', norm.includes('horror') || norm.includes('terror'));
        pushIf('Mystery', norm.includes('mystery') || norm.includes('crime') || norm.includes('detective'));
        pushIf('Romance', norm.includes('romance'));
        pushIf('History', norm.includes('history') || norm.includes('histor'));
        pushIf('Biography', norm.includes('biography') || norm.includes('biografia'));
        pushIf(
            'Nonfiction',
            norm.includes('nonfiction') ||
            norm.includes('non fiction') ||
            norm.includes('nao ficcao') ||
            norm.includes('no ficcion')
        );

        const rest = tokens.filter((t) => {
            const n = normalizeText(t);
            if (!n) return false;
            if (n.includes('science fiction') || n.includes('sci fi')) return false;
            if (n.includes('fantasy') || n.includes('fantasia')) return false;
            if (n.includes('horror') || n.includes('terror')) return false;
            if (n.includes('mystery') || n.includes('crime') || n.includes('detective')) return false;
            if (n.includes('romance')) return false;
            if (n.includes('history') || n.includes('histor')) return false;
            if (n.includes('biography') || n.includes('biografia')) return false;
            if (
                n.includes('nonfiction') ||
                n.includes('non fiction') ||
                n.includes('nao ficcao') ||
                n.includes('no ficcion')
            )
                return false;
                return true;
        });

        return uniqStrings([...ordered, ...rest]);
};

const fetchEditionsPaged = async (workId, opts = {}) => {
    const cfg = BOOKS_ADAPTER_CONFIG;

    const limit = Number.isFinite(opts.limit) ? opts.limit : cfg.PAGE_SIZE;
    const maxTotal = Number.isFinite(opts.maxTotal) ? opts.maxTotal : cfg.MAX_TOTAL_EDITIONS;
    const minPerLang = Number.isFinite(opts.minPerLang) ? opts.minPerLang : cfg.MIN_EDITIONS_PER_LANG;
    const stagnantPagesLimit = Number.isFinite(opts.stagnantPagesLimit)
    ? opts.stagnantPagesLimit
    : cfg.STAGNANT_PAGES_LIMIT;

    const capPagesByTotal = Math.ceil(maxTotal / limit);
    const maxPages = Number.isFinite(opts.maxPages) ? Math.min(opts.maxPages, capPagesByTotal) : capPagesByTotal;

    const all = [];
    let offset = 0;

    const counts = { eng: 0, por: 0, spa: 0 };
    let stagnantPages = 0;

    const meetsMin = () => counts.eng >= minPerLang && counts.por >= minPerLang && counts.spa >= minPerLang;

    for (let page = 0; page < maxPages; page += 1) {
        if (all.length >= maxTotal) break;
        if (meetsMin()) break;

        const res = await olClient.get(`/works/${workId}/editions.json`, {
            params: { limit, offset },
        });

        const entries = Array.isArray(res.data?.entries) ? res.data.entries : [];
        if (entries.length === 0) break;

        all.push(...entries);

        let pageLangSignals = 0;
        for (const ed of entries) {
            const lk = getEditionLangKey(ed);
            if (lk === 'eng') counts.eng += 1;
            if (lk === 'por') counts.por += 1;
            if (lk === 'spa') counts.spa += 1;
            if (lk) pageLangSignals += 1;
        }

        if (pageLangSignals === 0) stagnantPages += 1;
        else stagnantPages = 0;

        if (stagnantPages >= stagnantPagesLimit) break;

        if (entries.length < limit) break;
        offset += limit;
    }

    return all.slice(0, maxTotal);
};

export const searchBooks = async (query) => {
    const results = [];
    try {
        const response = await olClient.get('/search.json', {
            params: {
                q: query,
                limit: 20,
                fields: 'key,title,author_name,first_publish_year,cover_i',
            },
        });

        const docs = Array.isArray(response.data?.docs) ? response.data.docs : [];
        for (const book of docs) {
            const key = String(book.key || '').replace('/works/', '');
            if (!key) continue;

            results.push({
                id: `ol_${key}`,
                title: book.title || 'Sem Título',
                author: Array.isArray(book.author_name) ? book.author_name[0] : 'Autor Desconhecido',
                         year: book.first_publish_year || '?',
                         poster: book.cover_i ? `https://covers.openlibrary.org/b/id/${book.cover_i}-M.jpg` : null,
                         type: 'livro',
            });
        }

        return results;
    } catch (e) {
        console.error('[BooksAdapter] Erro na OpenLibrary Search:', e.message);
        return results;
    }
};

export const getBookData = async (externalId) => {
    if (!externalId) throw new Error('ID de livro inválido.');

    if (externalId.startsWith('google_') || externalId.startsWith('g_')) {
        const realId = externalId.replace(/^google_|^g_/, '');
        return await fetchGoogleBookDetails(realId);
    }

    const workId = externalId.replace(/^ol_/, '');
    return await fetchOpenLibraryWork(workId);
};

const fetchOpenLibraryWork = async (workId) => {
    try {
        const workRes = await olClient.get(`/works/${workId}.json`);
        const workData = workRes.data || {};

        let authorName = 'Autor Desconhecido';
        try {
            const authorEntry = Array.isArray(workData.authors) ? workData.authors[0] : null;
            const authorKey = authorEntry?.author?.key || authorEntry?.key || null;
            if (authorKey) {
                const authorRes = await olClient.get(`${authorKey}.json`);
                if (authorRes.data?.name) authorName = authorRes.data.name;
            }
        } catch (e) {}

        const editions = await fetchEditionsPaged(workId);

        const workYear = extractYear(workData.first_publish_date);
        let originalYear = workYear;

        if (!originalYear && editions.length > 0) {
            const years = editions.map(getEditionPublishYear).filter((y) => Number.isFinite(y));
            if (years.length > 0) originalYear = Math.min(...years);
        }

        const bestEditionPT = pickBestEdition(editions, OL_LANG_BY_UI.PT, originalYear);
        const bestEditionEN = pickBestEdition(editions, OL_LANG_BY_UI.EN, originalYear);
        const bestEditionES = pickBestEdition(editions, OL_LANG_BY_UI.ES, originalYear);

        const titles = {
            PT: bestEditionPT?.title || workData.title || null,
            EN: bestEditionEN?.title || workData.title || null,
            ES: bestEditionES?.title || workData.title || null,
        };
        titles.DEFAULT = titles.PT || titles.EN || titles.ES || workData.title || 'Título Indisponível';

        const ctxPT = {
            expectedLang2: GB_LANG_BY_UI.PT,
            targetTitle: titles.PT || workData.title,
            targetAuthor: authorName,
            originalYear,
        };
        const ctxEN = {
            expectedLang2: GB_LANG_BY_UI.EN,
            targetTitle: titles.EN || workData.title,
            targetAuthor: authorName,
            originalYear,
        };
        const ctxES = {
            expectedLang2: GB_LANG_BY_UI.ES,
            targetTitle: titles.ES || workData.title,
            targetAuthor: authorName,
            originalYear,
        };

        const googleItemPT =
        (await googleGetBestByIsbns(extractIsbns(bestEditionPT), ctxPT)) ||
        (await googleSearchBestByTitleAuthor([ctxPT.targetTitle, workData.title], authorName, ctxPT));

        const googleItemEN =
        (await googleGetBestByIsbns(extractIsbns(bestEditionEN), ctxEN)) ||
        (await googleSearchBestByTitleAuthor([ctxEN.targetTitle, workData.title], authorName, ctxEN));

        const googleItemES =
        (await googleGetBestByIsbns(extractIsbns(bestEditionES), ctxES)) ||
        (await googleSearchBestByTitleAuthor([ctxES.targetTitle, workData.title], authorName, ctxES));

        const synopsisPTCandidate =
        (getGoogleVolumeInfo(googleItemPT)?.description || null) ||
        (olDescriptionToString(bestEditionPT?.description) || null);

        const isLikelySpanish = (s) => {
            const raw = String(s || '');
            if (!raw.trim()) return false;

            const n = ` ${normalizeText(raw)} `;

            const esHits = [
                ' el ',
                ' la ',
                ' los ',
                ' las ',
                ' que ',
                ' y ',
                ' en ',
                ' de ',
                ' del ',
                ' al ',
                ' una ',
                ' un ',
                ' por ',
                ' para ',
                ' con ',
                ' se ',
                ' su ',
                ' sus ',
            ].filter((w) => n.includes(w)).length;

            const frHits = [
                ' le ',
                ' les ',
                ' des ',
                ' dans ',
                ' tout ',
                ' edition ',
                ' preface ',
                ' postface ',
                ' traduit ',
                ' traduction ',
                ' etats unis ',
            ].filter((w) => n.includes(w)).length;

            if (frHits >= 3 && frHits >= esHits) return false;
            return esHits >= 3;
        };

        const googleEsDesc = getGoogleVolumeInfo(googleItemES)?.description || null;
        const olEsDesc = olDescriptionToString(bestEditionES?.description) || null;

        const synopsisESCandidate =
        (isPlausibleSynopsis(googleEsDesc) && isLikelySpanish(googleEsDesc) ? String(googleEsDesc).trim() : null) ||
        (isPlausibleSynopsis(olEsDesc) && isLikelySpanish(olEsDesc) ? String(olEsDesc).trim() : null) ||
        null;

        const isLikelyEnglish = (s) => {
            const raw = String(s || '');
            if (!raw.trim()) return false;

            if (/[æøå]/i.test(raw)) return false;

            const n = ` ${normalizeText(raw)} `;
            const enHits = [' the ', ' and ', ' of ', ' to ', ' in ', ' that ', ' with ', ' from ', ' for '].filter((w) =>
            n.includes(w)
            ).length;

            const ptEsHits = [
                ' que ',
                ' para ',
                ' com ',
                ' uma ',
                ' nao ',
                ' não ',
                ' el ',
                ' la ',
                ' los ',
                ' las ',
                ' por ',
                ' una ',
            ].filter((w) => n.includes(w)).length;

            return enHits >= 3 && enHits > ptEsHits;
        };

        const olEnglishCandidatesStrict = (editions || [])
        .filter((ed) => getEditionLangKey(ed) === 'eng')
        .map((ed) => olDescriptionToString(ed?.description))
        .filter(Boolean)
        .map((s) => String(s).trim())
        .filter((s) => isPlausibleSynopsis(s));

        let bestOlEnglishSynopsis = olEnglishCandidatesStrict.sort((a, b) => b.length - a.length)[0] || null;

        if (!bestOlEnglishSynopsis) {
            const olEnglishCandidatesHeuristic = (editions || [])
            .map((ed) => olDescriptionToString(ed?.description))
            .filter(Boolean)
            .map((s) => String(s).trim())
            .filter((s) => isPlausibleSynopsis(s) && isLikelyEnglish(s));

            bestOlEnglishSynopsis = olEnglishCandidatesHeuristic.sort((a, b) => b.length - a.length)[0] || null;
        }

        const googleEnglishSynopsis = getGoogleVolumeInfo(googleItemEN)?.description || null;
        const synopsisENCandidate =
        bestOlEnglishSynopsis ||
        (isPlausibleSynopsis(googleEnglishSynopsis) ? String(googleEnglishSynopsis).trim() : null);

        const synopses = {
            PT: isPlausibleSynopsis(synopsisPTCandidate) ? String(synopsisPTCandidate).trim() : null,
            EN: synopsisENCandidate ? String(synopsisENCandidate).trim() : null,
            ES: isPlausibleSynopsis(synopsisESCandidate) ? String(synopsisESCandidate).trim() : null,
        };
        synopses.DEFAULT = synopses.PT || synopses.EN || synopses.ES || null;

        const countryIso2 = pickCountryIso2(editions, originalYear);

        const olSubjects = Array.isArray(workData.subjects) ? workData.subjects : [];

        const gbCatsPT = Array.isArray(getGoogleVolumeInfo(googleItemPT)?.categories)
        ? getGoogleVolumeInfo(googleItemPT).categories
        : [];
        const gbCatsEN = Array.isArray(getGoogleVolumeInfo(googleItemEN)?.categories)
        ? getGoogleVolumeInfo(googleItemEN).categories
        : [];
        const gbCatsES = Array.isArray(getGoogleVolumeInfo(googleItemES)?.categories)
        ? getGoogleVolumeInfo(googleItemES).categories
        : [];

        const tokensPT = filterNoisyBookTokens([...splitCategoryTokens(gbCatsPT), ...olSubjects]);
        const tokensEN = filterNoisyBookTokens([...splitCategoryTokens(gbCatsEN), ...olSubjects]);
        const tokensES = filterNoisyBookTokens([...splitCategoryTokens(gbCatsES), ...olSubjects]);

        const rawGenresPT = orderGenresForBooks(tokensPT);
        const rawGenresEN = orderGenresForBooks(tokensEN);
        const rawGenresES = orderGenresForBooks(tokensES);

        const genres = {
            PT: rawGenresPT.slice(0, 12),
            EN: rawGenresEN.slice(0, 12),
            ES: rawGenresES.slice(0, 12),
        };

        // CAPA: prioriza Open Library, só usa Google se não houver nenhuma alternativa.
        const candidatesOl = [];
        const candidatesGoogle = [];

        // 1) Open Library por OLID da edição escolhida (muito estável no browser)
        const olidPT = getEditionOlid(bestEditionPT);
        const olidEN = getEditionOlid(bestEditionEN);
        const olidES = getEditionOlid(bestEditionES);

        for (const olid of [olidPT, olidEN, olidES].filter(Boolean)) {
            candidatesOl.push(buildOlCoverByOlidUrl(olid, 'L', true));
            candidatesOl.push(buildOlCoverByOlidUrl(olid, 'M', true));
        }

        // 2) Open Library por cover ids do work
        if (Array.isArray(workData.covers)) {
            for (const cid of workData.covers) candidatesOl.push(buildOlCoverByIdUrl(cid, 'L', true));
            for (const cid of workData.covers) candidatesOl.push(buildOlCoverByIdUrl(cid, 'M', true));
        }

        // 3) Open Library por covers da edição (quando vierem)
        const editionCoverIds = [];
        const pushEditionCovers = (ed) => {
            if (!ed || !Array.isArray(ed.covers)) return;
            for (const c of ed.covers) {
                if (!editionCoverIds.includes(c)) editionCoverIds.push(c);
            }
        };
        pushEditionCovers(bestEditionPT);
        pushEditionCovers(bestEditionEN);
        pushEditionCovers(bestEditionES);

        for (const cid of editionCoverIds) candidatesOl.push(buildOlCoverByIdUrl(cid, 'L', true));
        for (const cid of editionCoverIds) candidatesOl.push(buildOlCoverByIdUrl(cid, 'M', true));

        // 4) Open Library por ISBN
        const isbns = uniqStrings([
            ...extractIsbns(bestEditionPT),
                                  ...extractIsbns(bestEditionEN),
                                  ...extractIsbns(bestEditionES),
        ]);
        for (const isbn of isbns) candidatesOl.push(buildOlCoverByIsbnUrl(isbn, 'L', true));
        for (const isbn of isbns) candidatesOl.push(buildOlCoverByIsbnUrl(isbn, 'M', true));

        // 5) Google Books (apenas se OL não fornecer nada)
        const googleCover = pickBestGoogleCoverUrl([googleItemPT, googleItemEN, googleItemES]);
        if (googleCover) candidatesGoogle.push(googleCover);

        let posterUrl = await pickFirstReachableImage(candidatesOl, 35);
        if (!posterUrl) {
            posterUrl = await pickFirstReachableImage(candidatesGoogle, 10);
        }

        // Fallback final que sempre gera uma imagem (mesmo se for placeholder do OL).
        if (!posterUrl) {
            if (isbns.length > 0) posterUrl = buildOlCoverByIsbnUrl(isbns[0], 'L', false);
            else if (Array.isArray(workData.covers) && workData.covers.length > 0)
                posterUrl = buildOlCoverByIdUrl(workData.covers[0], 'L', false);
            else if (olidPT || olidEN || olidES) posterUrl = buildOlCoverByOlidUrl(olidPT || olidEN || olidES, 'L', false);
            else posterUrl = 'https://via.placeholder.com/300x450?text=Cover+Not+Available';
        }

        return {
            id: `ol_${workId}`,
            type: 'livro',
            titles,
            synopses,
            posterUrl,
            backdropUrl: null,
            releaseYear: originalYear || null,
            runtime: null,
            director: authorName,
            genres,
            countries: countryIso2 ? [countryIso2] : null,
            details: null,
            tags: [],
            externalIds: {
                openLibraryWorkId: workId,
                googleBooksId: {
                    PT: googleItemPT?.id || null,
                    EN: googleItemEN?.id || null,
                    ES: googleItemES?.id || null,
                },
            },
        };
    } catch (error) {
        console.error(`[BooksAdapter] ERRO CRÍTICO no work ${workId}:`, error.message || error);
        return {
            id: `ol_${workId}`,
            type: 'livro',
            titles: { DEFAULT: 'Erro ao carregar detalhes', PT: null, EN: null, ES: null },
            synopses: {
                DEFAULT: 'Não foi possível carregar os dados completos deste livro.',
                PT: null,
                EN: null,
                ES: null,
            },
            posterUrl: null,
            backdropUrl: null,
            releaseYear: null,
            runtime: null,
            director: null,
            genres: null,
            countries: null,
            details: null,
            tags: [],
            externalIds: { openLibraryWorkId: workId },
        };
    }
};

const fetchGoogleBookDetails = async (googleId) => {
    try {
        const key = getGoogleBooksKey();
        const params = key ? { key } : undefined;

        const response = await axios.get(`${GOOGLE_BOOKS_URL}/${googleId}`, { params });
        const info = response.data?.volumeInfo || {};

        const year = extractYear(info.publishedDate);
        const desc = typeof info.description === 'string' ? info.description : null;
        const title = info.title || null;

        const categories = splitCategoryTokens(Array.isArray(info.categories) ? info.categories : []);

        const cover =
        info.imageLinks?.extraLarge ||
        info.imageLinks?.large ||
        info.imageLinks?.medium ||
        info.imageLinks?.small ||
        info.imageLinks?.thumbnail ||
        info.imageLinks?.smallThumbnail ||
        null;

        return {
            id: `google_${response.data?.id || googleId}`,
            type: 'livro',
            titles: { DEFAULT: title, PT: title, EN: title, ES: title },
            synopses: { DEFAULT: desc, PT: desc, EN: desc, ES: desc },
            posterUrl: cover ? upgradeGoogleCoverUrl(cover) : 'https://via.placeholder.com/300x450?text=Cover+Not+Available',
            backdropUrl: null,
            releaseYear: Number.isFinite(year) ? year : null,
            runtime: null,
            director: Array.isArray(info.authors) ? info.authors.join(', ') : 'Autor Desconhecido',
            genres: { PT: categories, EN: categories, ES: categories },
            countries: null,
            details: null,
            tags: [],
            externalIds: { googleBooksId: googleId },
        };
    } catch (error) {
        console.error('[BooksAdapter] Erro ao buscar detalhes no Google Books:', error.message || error);
        return {
            id: `google_${googleId}`,
            type: 'livro',
            titles: { DEFAULT: 'Erro ao carregar detalhes', PT: null, EN: null, ES: null },
            synopses: {
                DEFAULT: 'Não foi possível carregar os dados completos deste livro.',
                PT: null,
                EN: null,
                ES: null,
            },
            posterUrl: 'https://via.placeholder.com/300x450?text=Cover+Not+Available',
            backdropUrl: null,
            releaseYear: null,
            runtime: null,
            director: null,
            genres: null,
            countries: null,
            details: null,
            tags: [],
            externalIds: { googleBooksId: googleId },
        };
    }
};
</file>

<file path="server/src/utils/rawg.adapter.js">
import axios from 'axios';

const RAWG_API_URL = 'https://api.rawg.io/api';

const rawgClient = axios.create({
    baseURL: RAWG_API_URL
});

export const getGameData = async (rawgId) => {
    const apiKey = process.env.RAWG_API_KEY;
    if (!apiKey) throw new Error("RAWG_API_KEY não configurada");

    try {
        const response = await rawgClient.get(`/games/${rawgId}`, {
            params: { key: apiKey }
        });

        const data = response.data;
        const releaseYear = data.released ? new Date(data.released).getFullYear() : null;

        // === TAGS INTERNAS (Gamificação) ===
        // Juntamos tags e gêneros para o sistema de troféus
        const tags = data.tags ? data.tags.map(t => `tag.${t.slug}`) : [];
        if (data.genres) {
            data.genres.forEach(g => tags.push(`tag.${g.slug}`));
        }

        // === DADOS TÉCNICOS ===
        // Desenvolvedora Principal (equivale a Diretor em filmes)
        const developer = data.developers && data.developers.length > 0 ? data.developers[0].name : null;

        // Gêneros para exibição (RAWG retorna em inglês)
        const genreNames = data.genres ? data.genres.map(g => g.name) : [];

        // Plataformas (Ex: ["PC", "PlayStation 5", "Xbox Series S/X"])
        const platforms = data.platforms ? data.platforms.map(p => p.platform.name) : [];

        // Duração: RAWG manda em horas, convertemos para minutos
        const runtimeMinutes = data.playtime ? data.playtime * 60 : null;

        return {
            id: `rawg_${data.id}`,
            type: 'jogo',

            titles: {
                EN: data.name,
                PT: data.name // RAWG raramente traduz títulos, usamos o original
            },
            synopses: {
                EN: data.description_raw || data.description,
                PT: data.description_raw || data.description // Fallback para EN
            },

            posterUrl: data.background_image,
            // Jogos usam a mesma imagem para backdrop ou uma adicional se existir
            backdropUrl: data.background_image_additional || data.background_image,

            releaseYear,
            runtime: runtimeMinutes,
            director: developer, // Mapeado para Developer

            // === NOVOS CAMPOS ===
            genres: {
                EN: genreNames,
                PT: genreNames // Usamos EN como fallback visual para não quebrar a tela
            },

            countries: null, // Jogos raramente têm "país de origem" claro na API básica

            // Campo flexível para dados específicos de jogos
            details: {
                "Plataformas": platforms,
                "Metacritic": data.metacritic
            },

            tags,
            externalIds: {
                rawg: data.id.toString(),
                website: data.website
            }
        };

    } catch (error) {
        console.error("Erro no RAWG Adapter:", error.message);
        throw new Error("Falha ao buscar jogo.");
    }
};

export const searchGames = async (query) => {
    const apiKey = process.env.RAWG_API_KEY;
    if (!apiKey) throw new Error("RAWG_API_KEY não configurada");

    const response = await rawgClient.get('/games', {
        params: {
            key: apiKey,
            search: query,
            page_size: 10
        }
    });

    return response.data.results.map(game => ({
        id: `rawg_${game.id}`,
        title: game.name,
        year: game.released ? game.released.split('-')[0] : '?',
                                              poster: game.background_image,
                                              type: 'jogo'
    }));
};
</file>

<file path="server/src/utils/tmdb.adapter.js">
import axios from 'axios';

const TMDB_API_URL = 'https://api.themoviedb.org/3';

// Criamos o cliente sem a chave por enquanto
const tmdbClient = axios.create({
    baseURL: TMDB_API_URL
});

/**
 * Busca detalhes completos de um filme em múltiplos idiomas
 */
export const getMovieData = async (tmdbId) => {
    // LER A CHAVE AGORA (RUNTIME) - Garante que o .env já carregou
    const apiKey = process.env.TMDB_API_KEY;
    if (!apiKey) throw new Error("TMDB_API_KEY não configurada no .env");

    try {
        // Adicionamos a api_key em cada requisição explicitamente
        const params = { api_key: apiKey };

        // Requisições paralelas para pegar dados localizados
        // append_to_response: 'credits' traz o diretor na chamada PT
        const [ptRes, enRes, esRes] = await Promise.all([
            tmdbClient.get(`/movie/${tmdbId}`, {
                params: { ...params, language: 'pt-BR', append_to_response: 'credits' }
            }),
            tmdbClient.get(`/movie/${tmdbId}`, { params: { ...params, language: 'en-US' } }),
                                                        tmdbClient.get(`/movie/${tmdbId}`, { params: { ...params, language: 'es-ES' } })
        ]);

        const ptData = ptRes.data;
        const enData = enRes.data;
        const esData = esRes.data;

        const releaseYear = ptData.release_date ? new Date(ptData.release_date).getFullYear() : null;

        // Tags baseadas no Inglês (Padrão do sistema para Gamificação/Troféus)
        // Mantemos isso para lógica interna.
        const tags = enData.genres.map(g => `tag.${g.name.toLowerCase().replace(/\s+/g, '-')}`);

        // Extração do Diretor (da resposta PT)
        const director = ptData.credits?.crew?.find(person => person.job === 'Director')?.name || null;

        // === FUNÇÕES AUXILIARES ===
        const getGenresList = (data) => data.genres?.map(g => g.name) || [];

        // MUDANÇA AQUI: Pegamos o código ISO (ex: "US", "BR") em vez do nome em inglês
        const getCountriesList = (data) => data.production_countries?.map(c => c.iso_3166_1) || [];

        return {
            id: `tmdb_${tmdbId}`,
            type: 'filme',

            // Dados Traduzidos (Títulos e Sinopses)
            titles: {
                PT: ptData.title,
                EN: enData.title,
                ES: esData.title
            },
            synopses: {
                PT: ptData.overview,
                EN: enData.overview,
                ES: esData.overview
            },

            // === NOVOS DADOS PARA EXIBIÇÃO ===
            genres: {
                PT: getGenresList(ptData),
                EN: getGenresList(enData),
                ES: getGenresList(esData)
            },
            // Salvamos códigos universais para o país
            countries: {
                PT: getCountriesList(ptData),
                EN: getCountriesList(enData),
                ES: getCountriesList(esData)
            },

            posterUrl: `https://image.tmdb.org/t/p/w500${ptData.poster_path}`,
            backdropUrl: `https://image.tmdb.org/t/p/w1280${ptData.backdrop_path}`,

            releaseYear: releaseYear,
            runtime: ptData.runtime, // Duração em minutos
            director: director,      // Nome do Diretor

            tags: tags,
            externalIds: {
                tmdb: tmdbId.toString(),
                imdb: ptData.imdb_id
            }
        };

    } catch (error) {
        console.error("Erro no TMDB Adapter:", error.message);
        throw new Error("Falha ao buscar dados do filme no TMDB.");
    }
};

/**
 * Busca filmes pelo nome
 */
export const searchMovies = async (query) => {
    const apiKey = process.env.TMDB_API_KEY;
    if (!apiKey) throw new Error("TMDB_API_KEY não configurada");

    const response = await tmdbClient.get('/search/movie', {
        params: {
            api_key: apiKey,
            query,
            language: 'pt-BR',
            page: 1
        }
    });

    return response.data.results.map(movie => ({
        id: `tmdb_${movie.id}`,
        title: movie.title,
        year: movie.release_date ? movie.release_date.split('-')[0] : '?',
                                               poster: movie.poster_path ? `https://image.tmdb.org/t/p/w92${movie.poster_path}` : null,
                                               type: 'filme'
    }));
};
</file>

<file path="server/src/server.js">
import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import authRoutes from './routes/auth.routes.js';
import mediaRoutes from './routes/media.routes.js';
import reviewRoutes from './routes/review.routes.js'; // <--- NOVO IMPORT

const app = express();
const PORT = process.env.PORT || 3000;

app.use(cors());
app.use(express.json());

// Rotas
app.use('/api/auth', authRoutes);
app.use('/api/media', mediaRoutes);
app.use('/api/reviews', reviewRoutes); // <--- NOVA ROTA

app.get('/', (req, res) => {
    res.json({ status: 'online', message: 'Mazarbul API v1' });
});

app.listen(PORT, () => {
    console.log(`🚀 Servidor rodando na porta ${PORT}`);
});
</file>

<file path="server/package.json">
{
  "name": "mazarbul-server",
  "version": "1.0.0",
  "description": "API Backend para o projeto Mazarbul",
  "main": "src/server.js",
  "type": "module",
  "scripts": {
    "dev": "node --watch src/server.js",
    "start": "node src/server.js"
  },
  "dependencies": {
    "@prisma/client": "^5.14.0",
    "axios": "^1.13.2",
    "bcryptjs": "^3.0.3",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.3",
    "prisma": "^5.14.0",
    "zod": "^3.23.8"
  }
}
</file>

<file path="client/src/components/media/TechnicalDetails/TechnicalDetails.jsx">
import React from "react";

// Componente para exibir a "Ficha Técnica" de uma mídia.
export default function TechnicalDetails({ details, type, t, lang }) {
  if (!details) {
    return null;
  }

  const safeLang = (lang || "PT").split("-")[0].toUpperCase();

  const albumArtistLabel =
  safeLang === "EN" ? "Artist" : safeLang === "ES" ? "Artista" : "Artista";

  const albumTracksLabel =
  safeLang === "EN" ? "Tracks" : safeLang === "ES" ? "Pistas" : "Faixas";

  // Helper: pega o primeiro valor existente dentre várias chaves possíveis
  const getValue = (keys) => {
    for (const k of keys) {
      if (k == null) continue;
      if (details[k] != null) return details[k];
    }
    return null;
  };

  // Função para renderizar um par de chave-valor da ficha técnica
  const renderDetailItem = (labelKey, value) => {
    // Se o valor não existir, não renderiza a linha
    if (value == null || value === "") {
      return null;
    }

    let displayValue = value;

    // Lida com arrays de tags (Gênero, Plataformas)
    if (Array.isArray(value)) {
      displayValue = value
      .map((item) => {
        // Verifica se é uma string estilo "tag.action" para traduzir, ou texto puro
        if (item && item.includes && item.includes("tag.")) return t(item);
        return item;
      })
      .filter(Boolean)
      .join(", ");
    } else if (
      // Lida com objetos localizados (ex.: { PT: "EUA", EN: "USA" })
      typeof value === "object" &&
      value !== null &&
      value[safeLang]
    ) {
      displayValue = value[safeLang];
    }

    return (
      <div
      key={labelKey}
      className="flex justify-between border-b border-neutral-200 dark:border-neutral-800 py-3"
      >
      <dt className="text-sm text-neutral-500 dark:text-neutral-400">
      {/* Se a chave tiver ponto (ex: details.year), tenta traduzir. Se for texto puro, exibe direto */}
      {labelKey.includes(".") ? t(labelKey) : labelKey}
      </dt>
      <dd className="text-sm font-medium text-neutral-800 dark:text-neutral-200 text-right">
      {displayValue}
      </dd>
      </div>
    );
  };

  return (
    <div>
    <h2 className="text-xl font-bold text-neutral-800 dark:text-neutral-100 mb-2">
    {t("section.techDetails") || "Ficha Técnica"}
    </h2>

    <dl>
    {/* --- DETALHES PARA FILMES --- */}
    {type === "filme" && (
      <>
      {renderDetailItem(
        "details.director",
        getValue(["Direção", "Diretor", "director"])
      )}
      {renderDetailItem("details.duration", getValue(["Duração", "duration"]))}
      {renderDetailItem(
        "details.genre",
        getValue(["Gêneros", "Gênero", "genres"])
      )}
      {renderDetailItem("details.year", getValue(["Ano", "year"]))}
      {renderDetailItem("details.country", getValue(["País", "country"]))}
      </>
    )}

    {/* --- DETALHES PARA LIVROS --- */}
    {type === "livro" && (
      <>
      {/* Apenas as categorias decididas: Autor, Gênero, Ano, País */}
      {renderDetailItem("details.author", getValue(["author", "Autor"]))}
      {renderDetailItem(
        "details.genre",
        getValue(["genres", "Gêneros", "Gênero"])
      )}
      {renderDetailItem("details.year", getValue(["year", "Ano"]))}
      {renderDetailItem("details.country", getValue(["country", "País"]))}
      </>
    )}

    {/* --- DETALHES PARA JOGOS --- */}
    {type === "jogo" && (
      <>
      {renderDetailItem("Desenvolvedora", getValue(["Desenvolvedora"]))}
      {renderDetailItem("Plataformas", getValue(["Plataformas"]))}
      {renderDetailItem("Metacritic", getValue(["Metacritic"]))}

      {renderDetailItem("details.duration", getValue(["Duração", "duration"]))}
      {renderDetailItem(
        "details.genre",
        getValue(["Gêneros", "Gênero", "genres"])
      )}
      {renderDetailItem("details.year", getValue(["Ano", "year"]))}
      </>
    )}

    {/* --- DETALHES PARA ÁLBUNS --- */}
    {type === "album" && (
      <>
      {renderDetailItem(albumArtistLabel, getValue(["Artista"]))}
      {renderDetailItem(albumTracksLabel, getValue(["Faixas"]))}

      {renderDetailItem(
        "details.genre",
        getValue(["Gêneros", "Gênero", "genres"])
      )}
      {renderDetailItem("details.year", getValue(["Ano", "year"]))}
      </>
    )}
    </dl>
    </div>
  );
}
</file>

<file path="server/src/controllers/media.controller.js">
import prisma from '../lib/prisma.js';

import * as tmdb from '../utils/tmdb.adapter.js';
import * as rawg from '../utils/rawg.adapter.js';
import * as books from '../utils/books.adapter.js';
import * as lastfm from '../utils/lastfm.adapter.js';

import { searchUnifiedMedia } from '../services/mediaSearch.service.js';
import { hydrateMediaReferenceByQid } from '../services/mediaHydration.service.js';
import { isQid } from '../utils/wikidata.adapter.js';

const isTruthy = (value) => {
    const v = String(value ?? '').trim().toLowerCase();
    return v === '1' || v === 'true' || v === 'yes' || v === 'y';
};

export const searchMedia = async (req, res) => {
    const { q, type, lang, canonical, limit } = req.query;

    if (!q) {
        return res.status(400).json({ error: "Query 'q' é obrigatória" });
    }

    const useCanonical = isTruthy(canonical) || !type || type === 'all';

    try {
        if (useCanonical) {
            const parsedLimit = Number.parseInt(String(limit ?? ''), 10);
            const finalLimit = Number.isFinite(parsedLimit) ? Math.max(1, Math.min(parsedLimit, 30)) : 20;

            const results = await searchUnifiedMedia({
                query: q,
                uiLang: lang || 'PT',
                type: type && type !== 'all' ? type : null,
                limit: finalLimit
            });

            return res.json(results);
        }

        let results = [];

        switch (type) {
            case 'filme':
                results = await tmdb.searchMovies(q);
                break;
            case 'jogo':
                results = await rawg.searchGames(q);
                break;
            case 'livro':
                results = await books.searchBooks(q);
                break;
            case 'album':
                results = await lastfm.searchAlbums(q);
                break;
            default:
                results = await tmdb.searchMovies(q);
        }

        return res.json(results);
    } catch (error) {
        console.error('Erro na busca:', error);
        return res.status(500).json({ error: 'Falha ao buscar mídia' });
    }
};

export const getMediaDetails = async (req, res) => {
    const { id } = req.params;

    const refreshParam = String(req.query.refresh || '').toLowerCase();
    const forceRefresh = refreshParam === '1' || refreshParam === 'true' || refreshParam === 'yes';

    try {
        if (isQid(id)) {
            const cachedMedia = await prisma.mediaReference.findUnique({
                where: { id },
                include: {
                    reviews: {
                        include: { user: true },
                        orderBy: { createdAt: 'desc' },
                        take: 5
                    },
                    _count: {
                        select: { favoritedBy: true }
                    }
                }
            });

            if (cachedMedia && cachedMedia.isStub === false && !forceRefresh) {
                await prisma.mediaReference.update({
                    where: { id },
                    data: { lastAccessedAt: new Date() }
                });

                return res.json(cachedMedia);
            }

            await hydrateMediaReferenceByQid(id, { forceRefresh });

            const hydrated = await prisma.mediaReference.findUnique({
                where: { id },
                include: {
                    reviews: {
                        include: { user: true },
                        orderBy: { createdAt: 'desc' },
                        take: 5
                    },
                    _count: {
                        select: { favoritedBy: true }
                    }
                }
            });

            if (!hydrated) {
                return res.status(404).json({ error: 'Mídia não encontrada.' });
            }

            return res.json(hydrated);
        }

        const cachedMedia = await prisma.mediaReference.findUnique({
            where: { id },
            include: {
                reviews: {
                    include: { user: true },
                    orderBy: { createdAt: 'desc' },
                    take: 5
                },
                _count: {
                    select: { favoritedBy: true }
                }
            }
        });

        if (cachedMedia && !forceRefresh) {
            await prisma.mediaReference.update({
                where: { id },
                data: { lastAccessedAt: new Date() }
            });

            return res.json(cachedMedia);
        }

        const [prefix, ...rest] = id.split('_');
        const externalId = rest.join('_');

        let externalData = null;

        if (prefix === 'tmdb') {
            externalData = await tmdb.getMovieData(externalId);
        } else if (prefix === 'rawg') {
            externalData = await rawg.getGameData(externalId);
        } else if (prefix === 'google' || prefix === 'ol') {
            externalData = await books.getBookData(id);
        } else if (prefix === 'lastfm') {
            externalData = await lastfm.getAlbumData(externalId);
        } else {
            return res.status(400).json({ error: 'Fonte de mídia desconhecida.' });
        }

        if (!externalData) {
            return res.status(404).json({ error: 'Mídia não encontrada na fonte externa.' });
        }

        const at = new Date();

        await prisma.mediaReference.upsert({
            where: { id: externalData.id },
            create: {
                id: externalData.id,
                type: externalData.type,
                titles: externalData.titles,
                synopses: externalData.synopses,
                posterUrl: externalData.posterUrl,
                backdropUrl: externalData.backdropUrl,
                releaseYear: externalData.releaseYear,
                tags: externalData.tags || [],
                externalIds: externalData.externalIds || {},

                runtime: externalData.runtime,
                director: externalData.director,
                genres: externalData.genres,
                countries: externalData.countries,
                details: externalData.details,

                isStub: false,
                lastFetchedAt: at,
                lastAccessedAt: at,
                countrySource: null
            },
            update: {
                type: externalData.type,
                titles: externalData.titles,
                synopses: externalData.synopses,
                posterUrl: externalData.posterUrl,
                backdropUrl: externalData.backdropUrl,
                releaseYear: externalData.releaseYear,
                tags: externalData.tags || [],
                externalIds: externalData.externalIds || {},

                runtime: externalData.runtime,
                director: externalData.director,
                genres: externalData.genres,
                countries: externalData.countries,
                details: externalData.details,

                isStub: false,
                lastFetchedAt: at,
                lastAccessedAt: at
            }
        });

        const hydrated = await prisma.mediaReference.findUnique({
            where: { id: externalData.id },
            include: {
                reviews: {
                    include: { user: true },
                    orderBy: { createdAt: 'desc' },
                    take: 5
                },
                _count: {
                    select: { favoritedBy: true }
                }
            }
        });

        return res.json(hydrated);
    } catch (error) {
        const msg = String(error?.message || '');

        if (msg.toLowerCase().includes('não encontrado')) {
            return res.status(404).json({ error: msg });
        }

        if (msg.toLowerCase().includes('qid inválido') || msg.toLowerCase().includes('tipo de mídia não definido')) {
            return res.status(400).json({ error: msg });
        }

        console.error('Erro ao buscar detalhes da mídia:', error);
        return res.status(500).json({ error: 'Erro interno ao processar mídia.' });
    }
};
</file>

<file path="server/src/utils/lastfm.adapter.js">
import axios from 'axios';

const LASTFM_API_URL = 'https://ws.audioscrobbler.com/2.0/';

const lastFmClient = axios.create({
    baseURL: LASTFM_API_URL,
    timeout: 15000,
});

const MUSICBRAINZ_API_URL = 'https://musicbrainz.org/ws/2/';
const MUSICBRAINZ_USER_AGENT =
process.env.MUSICBRAINZ_USER_AGENT ||
'Mazarbul/1.0.0 (https://github.com/0zzmandias/Mazarbul)';

const musicBrainzClient = axios.create({
    baseURL: MUSICBRAINZ_API_URL,
    timeout: 15000,
    headers: {
        'User-Agent': MUSICBRAINZ_USER_AGENT,
        'Accept': 'application/json',
    },
});

const MBID_REGEX = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;
const looksLikeMbid = (value) => MBID_REGEX.test(String(value || '').trim());

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

let mbQueue = Promise.resolve();
let mbLastRequestAt = 0;
const MB_MIN_INTERVAL_MS = 1100;

const mbGet = (path, params) => {
    const task = async () => {
        const now = Date.now();
        const delta = now - mbLastRequestAt;
        if (delta < MB_MIN_INTERVAL_MS) {
            await sleep(MB_MIN_INTERVAL_MS - delta);
        }

        try {
            return await musicBrainzClient.get(path, { params });
        } finally {
            mbLastRequestAt = Date.now();
        }
    };

    const run = mbQueue.then(task, task);
    mbQueue = run.catch(() => undefined);
    return run;
};

const CACHE_TTL_MS = 1000 * 60 * 60 * 24 * 7;

const cacheGet = (map, key) => {
    const k = String(key || '').trim();
    if (!k) return null;
    const entry = map.get(k);
    if (!entry) return null;
    if (Date.now() > entry.expiresAt) {
        map.delete(k);
        return null;
    }
    return entry.value;
};

const cacheSet = (map, key, value) => {
    const k = String(key || '').trim();
    if (!k) return;
    map.set(k, { value, expiresAt: Date.now() + CACHE_TTL_MS });
};

const rgByAnyMbidCache = new Map();
const rgBasicsCache = new Map();
const rgReleasesCache = new Map();
const releaseTracklistCache = new Map();

const getApiKey = () => {
    const apiKey = process.env.LASTFM_API_KEY;
    if (!apiKey) throw new Error('LASTFM_API_KEY não configurada');
    return apiKey;
};

const extractYear = (input) => {
    if (!input) return null;
    const m = String(input).match(/\b(19\d{2}|20\d{2})\b/);
    if (!m) return null;
    const y = parseInt(m[1], 10);
    return Number.isFinite(y) ? y : null;
};

const stripHtml = (text) => {
    if (!text) return null;
    return String(text)
    .replace(/<[^>]*>/g, ' ')
    .replace(/\s+/g, ' ')
    .trim() || null;
};

const cleanupSummary = (text) => {
    const s = stripHtml(text);
    if (!s) return null;
    return s.replace(/\bRead\s+more\b.*$/i, '').trim() || null;
};

const pickBestImage = (images) => {
    if (!Array.isArray(images)) return null;

    const bySize = (size) => images.find((i) => i && i.size === size && i['#text']);
    return (
        bySize('mega')?.['#text'] ||
        bySize('extralarge')?.['#text'] ||
        bySize('large')?.['#text'] ||
        bySize('medium')?.['#text'] ||
        images.find((i) => i && i['#text'])?.['#text'] ||
        null
    );
};

const normalizeTagToInternal = (tagName) => {
    const raw = String(tagName || '').trim();
    if (!raw) return null;

    const slug = raw
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-z0-9\s-]/g, ' ')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');

    if (!slug) return null;
    return `tag.${slug}`;
};

const b64urlEncode = (value) => {
    const s = String(value || '');
    return Buffer.from(s, 'utf8')
    .toString('base64')
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/g, '');
};

const b64urlDecode = (value) => {
    const raw = String(value || '').trim();
    if (!raw) return '';

    const base64 = raw.replace(/-/g, '+').replace(/_/g, '/');
    const padLen = (4 - (base64.length % 4)) % 4;
    const padded = base64 + '='.repeat(padLen);
    return Buffer.from(padded, 'base64').toString('utf8');
};

const buildAlbumExternalIdFromArtistAlbum = (artist, album) => {
    return `aa_${b64urlEncode(artist)}.${b64urlEncode(album)}`;
};

const parseAlbumExternalId = (externalId) => {
    const raw = String(externalId || '').trim();
    if (!raw) return { mode: 'unknown' };

    if (raw.startsWith('rg_')) {
        const rg = raw.slice(3);
        return looksLikeMbid(rg) ? { mode: 'release_group', releaseGroupMbid: rg } : { mode: 'unknown' };
    }

    if (raw.startsWith('mb_')) {
        const mb = raw.slice(3);
        return looksLikeMbid(mb) ? { mode: 'mbid', mbid: mb } : { mode: 'unknown' };
    }

    if (raw.startsWith('aa_')) {
        const payload = raw.slice(3);
        const parts = payload.split('.');
        if (parts.length === 2) {
            const artist = b64urlDecode(parts[0]).trim();
            const album = b64urlDecode(parts[1]).trim();
            if (artist && album) {
                return { mode: 'artist_album', artist, album, canonicalExternalId: raw };
            }
        }
        return { mode: 'unknown' };
    }

    if (looksLikeMbid(raw)) return { mode: 'mbid', mbid: raw };

    return { mode: 'unknown' };
};

const formatDurationFromSeconds = (secondsValue) => {
    const n = parseInt(String(secondsValue || '0'), 10);
    if (!Number.isFinite(n) || n <= 0) return null;
    const mm = Math.floor(n / 60);
    const ss = n % 60;
    return `${mm}:${String(ss).padStart(2, '0')}`;
};

const formatDurationFromMilliseconds = (msValue) => {
    const n = parseInt(String(msValue || '0'), 10);
    if (!Number.isFinite(n) || n <= 0) return null;
    const totalSeconds = Math.round(n / 1000);
    const mm = Math.floor(totalSeconds / 60);
    const ss = totalSeconds % 60;
    return `${mm}:${String(ss).padStart(2, '0')}`;
};

const normalizeTitleKey = (value) => {
    return String(value || '')
    .trim()
    .toLowerCase()
    .replace(/\s+/g, ' ');
};

const EDITION_KEYWORDS = /(?:remaster(?:ed)?|deluxe|expanded|anniversary|reissue|special edition|bonus|collector(?:'s)? edition|extended)/i;

const isCdFormats = (formats) => {
    const list = Array.isArray(formats) ? formats : [];
    return list.some((f) => String(f || '').toLowerCase().includes('cd'));
};

const isYearLikeTag = (value) => {
    const s = String(value || '').trim();
    if (!s) return false;

    const now = new Date().getFullYear() + 1;

    if (/^\d{4}$/.test(s)) {
        const y = parseInt(s, 10);
        return Number.isFinite(y) && y >= 1900 && y <= now;
    }

    if (/^\d{4}s$/i.test(s)) {
        const y = parseInt(s.slice(0, 4), 10);
        return Number.isFinite(y) && y >= 1900 && y <= now;
    }

    if (/^\d{2}s$/i.test(s)) {
        return true;
    }

    return false;
};

const shouldDropGenreTag = (value) => {
    const s = String(value || '').trim();
    if (!s) return true;

    if (/^\d+$/.test(s)) {
        return true;
    }

    if (isYearLikeTag(s)) {
        return true;
    }

    return false;
};

const resolveReleaseGroupMbid = async (anyMbid) => {
    const mbid = String(anyMbid || '').trim();
    if (!looksLikeMbid(mbid)) return null;

    const cached = cacheGet(rgByAnyMbidCache, mbid);
    if (cached !== null) return cached;

    try {
        await mbGet(`release-group/${mbid}`, { fmt: 'json' });
        cacheSet(rgByAnyMbidCache, mbid, mbid);
        return mbid;
    } catch (e) {
    }

    try {
        const res = await mbGet(`release/${mbid}`, { inc: 'release-groups', fmt: 'json' });
        const rgid = res.data?.['release-group']?.id;
        if (looksLikeMbid(rgid)) {
            cacheSet(rgByAnyMbidCache, mbid, rgid);
            return rgid;
        }
    } catch (e) {
    }

    cacheSet(rgByAnyMbidCache, mbid, null);
    return null;
};

const lookupReleaseGroupBasics = async (releaseGroupMbid) => {
    const rgid = String(releaseGroupMbid || '').trim();
    if (!looksLikeMbid(rgid)) return null;

    const cached = cacheGet(rgBasicsCache, rgid);
    if (cached !== null) return cached;

    try {
        const res = await mbGet(`release-group/${rgid}`, { inc: 'artists', fmt: 'json' });
        const data = res.data || {};

        const title = String(data.title || '').trim() || null;
        const firstReleaseYear = extractYear(data['first-release-date']) || null;

        let artist = null;
        const ac = data['artist-credit'];
        if (Array.isArray(ac) && ac.length > 0) {
            const first = ac[0];
            artist =
            (typeof first?.name === 'string' && first.name.trim()) ||
            (typeof first?.artist?.name === 'string' && first.artist.name.trim()) ||
            null;
        }

        const basics = { title, artist, firstReleaseYear };
        cacheSet(rgBasicsCache, rgid, basics);
        return basics;
    } catch (e) {
        cacheSet(rgBasicsCache, rgid, null);
        return null;
    }
};

const lookupReleaseGroupReleases = async (releaseGroupMbid) => {
    const rgid = String(releaseGroupMbid || '').trim();
    if (!looksLikeMbid(rgid)) return [];

    const cached = cacheGet(rgReleasesCache, rgid);
    if (cached !== null) return cached || [];

    try {
        const releases = [];

        let offset = 0;
        const limit = 100;

        for (let page = 0; page < 2; page++) {
            const res = await mbGet('release', {
                'release-group': rgid,
                limit,
                offset,
                fmt: 'json',
            });

            const batch = Array.isArray(res.data?.releases) ? res.data.releases : [];
            for (const r of batch) releases.push(r);

            const total = typeof res.data?.['release-count'] === 'number' ? res.data['release-count'] : null;
            offset += batch.length;

            if (!batch.length) break;
            if (!total) break;
            if (offset >= total) break;
        }

        cacheSet(rgReleasesCache, rgid, releases);
        return releases;
    } catch (e) {
        cacheSet(rgReleasesCache, rgid, []);
        return [];
    }
};

const fetchReleaseTracklist = async (releaseMbid) => {
    const rid = String(releaseMbid || '').trim();
    if (!looksLikeMbid(rid)) return null;

    const cached = cacheGet(releaseTracklistCache, rid);
    if (cached !== null) return cached;

    try {
        const res = await mbGet(`release/${rid}`, { inc: 'recordings', fmt: 'json' });
        const media = Array.isArray(res.data?.media) ? res.data.media : [];

        const formats = [];
        const tracksOut = [];

        let offset = 0;

        for (const medium of media) {
            const format = String(medium?.format || '').trim();
            if (format) formats.push(format);

            const tracks = Array.isArray(medium?.tracks) ? medium.tracks : [];
            for (let i = 0; i < tracks.length; i++) {
                const t = tracks[i];

                const posRaw =
                (typeof t?.position === 'number' ? t.position : parseInt(String(t?.position || ''), 10)) ||
                (typeof t?.number === 'string' ? parseInt(t.number, 10) : null) ||
                (i + 1);

                const pos = Number.isFinite(posRaw) ? posRaw : (i + 1);

                const title = String(t?.title || t?.recording?.title || '').trim();
                if (!title) continue;

                const length = formatDurationFromMilliseconds(t?.length);

                tracksOut.push({
                    no: offset + pos,
                    title,
                    length,
                });
            }

            offset += tracks.length;
        }

        const uniqFormats = Array.from(new Set(formats.map((f) => String(f || '').trim()).filter(Boolean)));

        const normalized = tracksOut
        .filter((t) => t && t.title)
        .sort((a, b) => (a.no || 0) - (b.no || 0))
        .map((x, idx) => ({
            no: Number.isFinite(x.no) ? x.no : (idx + 1),
                          title: x.title,
                          length: x.length,
        }));

        const payload = { tracks: normalized, trackCount: normalized.length, formats: uniqFormats };
        cacheSet(releaseTracklistCache, rid, payload);
        return payload;
    } catch (e) {
        cacheSet(releaseTracklistCache, rid, null);
        return null;
    }
};

const pickBaseReleaseCd = async (releases, rgTitle) => {
    const list = Array.isArray(releases) ? releases : [];
    if (!list.length) return { baseRelease: null, baseTracklist: null };

    const titleKey = normalizeTitleKey(rgTitle);

    const byDateAsc = [...list].sort((a, b) => {
        const da = String(a?.date || '').trim();
        const db = String(b?.date || '').trim();
        if (!da && !db) return 0;
        if (!da) return 1;
        if (!db) return -1;
        return da.localeCompare(db);
    });

    const preferExactTitle = byDateAsc.filter((r) => normalizeTitleKey(r?.title) === titleKey);
    const rest = byDateAsc.filter((r) => normalizeTitleKey(r?.title) !== titleKey);
    const pool = [...preferExactTitle, ...rest].filter((r) => r?.id);

    for (const r of pool.slice(0, 14)) {
        const tl = await fetchReleaseTracklist(r.id);
        if (!tl || !tl.trackCount) continue;
        if (!isCdFormats(tl.formats)) continue;
        if (tl.trackCount < 5 || tl.trackCount > 30) continue;
        return { baseRelease: r, baseTracklist: tl };
    }

    for (const r of pool.slice(0, 14)) {
        const tl = await fetchReleaseTracklist(r.id);
        if (!tl || !tl.trackCount) continue;
        if (tl.trackCount < 5 || tl.trackCount > 30) continue;
        return { baseRelease: r, baseTracklist: tl };
    }

    return { baseRelease: null, baseTracklist: null };
};

const pickBestBonusCdRelease = async (releases, baseRelease, baseTracklist) => {
    const list = Array.isArray(releases) ? releases : [];
    if (!list.length || !baseRelease?.id || !baseTracklist?.tracks?.length) return null;

    const baseCount = baseTracklist.tracks.length;

    const baseTitleSet = new Set(
        baseTracklist.tracks.map((t) => normalizeTitleKey(t?.title)).filter(Boolean)
    );

    const byDateDesc = [...list].sort((a, b) => {
        const da = String(a?.date || '').trim();
        const db = String(b?.date || '').trim();
        if (!da && !db) return 0;
        if (!da) return 1;
        if (!db) return -1;
        return db.localeCompare(da);
    });

    let best = null;

    const candidates = byDateDesc
    .filter((r) => r?.id && r.id !== baseRelease.id)
    .slice(0, 18);

    for (const r of candidates) {
        const tl = await fetchReleaseTracklist(r.id);
        if (!tl || !tl.tracks || tl.tracks.length === 0) continue;
        if (!isCdFormats(tl.formats)) continue;

        const candCount = tl.tracks.length;
        if (candCount <= baseCount) continue;
        if (candCount > baseCount + 8) continue;

        const candTitleSet = new Set(tl.tracks.map((t) => normalizeTitleKey(t?.title)).filter(Boolean));

        let hits = 0;
        for (const bt of baseTitleSet) {
            if (candTitleSet.has(bt)) hits += 1;
        }

        const coverage = baseCount > 0 ? (hits / baseCount) : 0;
        if (coverage < 0.85) continue;

        const extras = tl.tracks.filter((t) => !baseTitleSet.has(normalizeTitleKey(t?.title)));
        if (!extras.length) continue;
        if (extras.length > 5) continue;

        const isOfficial = String(r?.status || '').toLowerCase() === 'official';
        const title = String(r?.title || '').trim();
        const year = extractYear(r?.date);

        let score = coverage * 1000;
        if (isOfficial) score += 25;
        if (candCount === baseCount + 1) score += 60;
        score -= extras.length * 8;
        if (EDITION_KEYWORDS.test(title)) score += 12;
        if (year) score += Math.min(10, Math.max(0, (year - 1970) / 10));

        if (!best || score > best.score) {
            best = {
                release: r,
                tracklist: tl,
                extras,
                score,
            };
        }
    }

    if (!best) return null;

    const baseNextNo = baseCount + 1;

    const normalizedExtras = best.extras.map((x, idx) => ({
        no: baseNextNo + idx,
        title: String(x?.title || '').trim(),
                                                          length: String(x?.length || '').trim() || null,
    })).filter((x) => x.title);

    if (!normalizedExtras.length) return null;

    const year = extractYear(best.release?.date);
    const title = String(best.release?.title || '').trim();
    const country = String(best.release?.country || '').trim();

    let sectionTitle = 'CD Bonus Tracks';
    if (year) sectionTitle = `${year} ${sectionTitle}`;
    if (title && EDITION_KEYWORDS.test(title)) sectionTitle = year ? `${year} ${title}` : title;
    if (country) sectionTitle = `${sectionTitle} (${country})`;

    return {
        title: sectionTitle,
        tracks: normalizedExtras,
    };
};

const buildBonusSectionsFromReleaseGroup = async (releaseGroupMbid, rgTitle) => {
    const releases = await lookupReleaseGroupReleases(releaseGroupMbid);
    if (!releases.length) {
        return { baseTracks: null, bonusSections: [] };
    }

    const { baseRelease, baseTracklist } = await pickBaseReleaseCd(releases, rgTitle);
    if (!baseRelease || !baseTracklist?.tracks?.length) {
        return { baseTracks: null, bonusSections: [] };
    }

    const bonus = await pickBestBonusCdRelease(releases, baseRelease, baseTracklist);
    const bonusSections = bonus ? [bonus] : [];

    return { baseTracks: baseTracklist.tracks, bonusSections };
};

const fetchLastFmAlbumInfoByArtistAlbum = async ({ artist, album, lang = 'pt' }) => {
    const apiKey = getApiKey();
    const response = await lastFmClient.get('', {
        params: {
            method: 'album.getinfo',
            api_key: apiKey,
            artist,
            album,
            autocorrect: 1,
            format: 'json',
                lang,
        },
    });
    return response.data?.album || null;
};

const fetchLastFmAlbumInfoByMbid = async ({ mbid, lang = 'pt' }) => {
    const apiKey = getApiKey();
    const response = await lastFmClient.get('', {
        params: {
            method: 'album.getinfo',
            api_key: apiKey,
            mbid,
            format: 'json',
                lang,
        },
    });
    return response.data?.album || null;
};

const buildTracklistFromLastFm = (album) => {
    const rawTracks = album?.tracks?.track;
    const trackArr = Array.isArray(rawTracks) ? rawTracks : rawTracks ? [rawTracks] : [];

    const out = [];
    for (let i = 0; i < trackArr.length; i++) {
        const t = trackArr[i];

        const title = String((typeof t === 'string' ? t : t?.name) || '').trim();
        if (!title) continue;

        const rankRaw = (typeof t === 'object' && t?.['@attr']?.rank) ? t['@attr'].rank : null;
        const rank = rankRaw ? parseInt(String(rankRaw), 10) : null;

        const no = Number.isFinite(rank) ? rank : i + 1;
        const length = formatDurationFromSeconds(typeof t === 'object' ? t?.duration : null);

        out.push({ no, title, length });
    }

    return out
    .map((x, idx) => ({
        no: Number.isFinite(x.no) ? x.no : idx + 1,
                      title: x.title,
                      length: x.length,
    }))
    .sort((a, b) => (a.no || 0) - (b.no || 0));
};

export const getAlbumData = async (externalId) => {
    try {
        const parsed = parseAlbumExternalId(externalId);

        let releaseGroupMbid = null;
        let artistForLastFm = null;
        let albumForLastFm = null;
        let lastfmAlbumMbid = null;
        let album = null;
        let firstReleaseYearFromMb = null;

        let mbBaseTracks = null;
        let mbBonusSections = [];

        if (parsed.mode === 'release_group') {
            releaseGroupMbid = parsed.releaseGroupMbid;

            const basics = await lookupReleaseGroupBasics(releaseGroupMbid);
            if (!basics?.artist || !basics?.title) {
                throw new Error('Release group inválido ou incompleto no MusicBrainz.');
            }

            artistForLastFm = basics.artist;
            albumForLastFm = basics.title;
            firstReleaseYearFromMb = basics.firstReleaseYear || null;

            const rgTracks = await buildBonusSectionsFromReleaseGroup(releaseGroupMbid, basics.title);
            mbBaseTracks = rgTracks.baseTracks;
            mbBonusSections = rgTracks.bonusSections || [];

            album = await fetchLastFmAlbumInfoByArtistAlbum({
                artist: artistForLastFm,
                album: albumForLastFm,
                lang: 'pt',
            });
        } else if (parsed.mode === 'mbid') {
            lastfmAlbumMbid = parsed.mbid;
            album = await fetchLastFmAlbumInfoByMbid({ mbid: lastfmAlbumMbid, lang: 'pt' });
            if (!album) throw new Error('Álbum não encontrado no LastFM.');

            const candidateMbid = String(album.mbid || lastfmAlbumMbid || '').trim();
            releaseGroupMbid = await resolveReleaseGroupMbid(candidateMbid);

            if (releaseGroupMbid) {
                const basics = await lookupReleaseGroupBasics(releaseGroupMbid);
                firstReleaseYearFromMb = basics?.firstReleaseYear || null;

                if (basics?.title) {
                    const rgTracks = await buildBonusSectionsFromReleaseGroup(releaseGroupMbid, basics.title);
                    mbBaseTracks = rgTracks.baseTracks;
                    mbBonusSections = rgTracks.bonusSections || [];
                }
            }

            const albumName = String(album.name || '').trim();
            const artistName =
            (typeof album.artist === 'string' && album.artist.trim()) ||
            (typeof album.artist?.name === 'string' && album.artist.name.trim()) ||
            null;

            artistForLastFm = artistName;
            albumForLastFm = albumName;
        } else if (parsed.mode === 'artist_album') {
            artistForLastFm = parsed.artist;
            albumForLastFm = parsed.album;

            album = await fetchLastFmAlbumInfoByArtistAlbum({
                artist: artistForLastFm,
                album: albumForLastFm,
                lang: 'pt',
            });
            if (!album) throw new Error('Álbum não encontrado no LastFM.');

            const candidateMbid = String(album.mbid || '').trim();
            if (looksLikeMbid(candidateMbid)) {
                releaseGroupMbid = await resolveReleaseGroupMbid(candidateMbid);
                if (releaseGroupMbid) {
                    const basics = await lookupReleaseGroupBasics(releaseGroupMbid);
                    firstReleaseYearFromMb = basics?.firstReleaseYear || null;

                    if (basics?.title) {
                        const rgTracks = await buildBonusSectionsFromReleaseGroup(releaseGroupMbid, basics.title);
                        mbBaseTracks = rgTracks.baseTracks;
                        mbBonusSections = rgTracks.bonusSections || [];
                    }
                }
            }
        } else {
            throw new Error('ID de álbum inválido.');
        }

        if (!album) throw new Error('Álbum não encontrado no LastFM.');

        const albumName = String(album.name || albumForLastFm || '').trim() || 'Sem Título';
        const artistName =
        (typeof album.artist === 'string' && album.artist.trim()) ||
        (typeof album.artist?.name === 'string' && album.artist.name.trim()) ||
        artistForLastFm ||
        'Artista Desconhecido';

            const releaseYear =
            firstReleaseYearFromMb ||
            extractYear(album.releasedate) ||
            extractYear(album.wiki?.published) ||
            extractYear(album.wiki?.content) ||
            null;

            const rawTags = album.tags?.tag;
            const tagsListRaw = Array.isArray(rawTags)
            ? rawTags.map((t) => (typeof t === 'string' ? t : t?.name)).filter(Boolean)
            : rawTags
            ? [typeof rawTags === 'string' ? rawTags : rawTags?.name].filter(Boolean)
            : [];

            const tagsList = (() => {
                const out = [];
                const seen = new Set();
                for (const t of tagsListRaw) {
                    const name = String(t || '').trim();
                    if (!name) continue;
                    if (shouldDropGenreTag(name)) continue;

                    const key = name.toLowerCase();
                    if (seen.has(key)) continue;
                    seen.add(key);
                    out.push(name);
                }
                return out;
            })();

            const tags = tagsList.map(normalizeTagToInternal).filter(Boolean);

            const posterUrl = pickBestImage(album.image);
            const synopsisCandidate = cleanupSummary(album.wiki?.summary) || cleanupSummary(album.wiki?.content);

            const canonicalExternalId = releaseGroupMbid
            ? `rg_${releaseGroupMbid}`
            : buildAlbumExternalIdFromArtistAlbum(artistName, albumName);

            const id = `lastfm_${canonicalExternalId}`;

            const titles = {
                PT: albumName,
                EN: albumName,
                ES: albumName,
                DEFAULT: albumName,
            };

            const synopses = {
                PT: synopsisCandidate || 'Sem descrição disponível.',
                EN: synopsisCandidate || 'No description available.',
                ES: synopsisCandidate || 'Sin descripción disponible.',
                DEFAULT: synopsisCandidate || 'Sem descrição disponível.',
            };

            const genres = {
                PT: tagsList,
                EN: tagsList,
                ES: tagsList,
                DEFAULT: tagsList,
            };

            const mainTracks =
            (Array.isArray(mbBaseTracks) && mbBaseTracks.length > 0)
            ? mbBaseTracks
            : buildTracklistFromLastFm(album);

            const bonusSections =
            Array.isArray(mbBonusSections) && mbBonusSections.length > 0
            ? mbBonusSections
            : [];

            return {
                id,
                type: 'album',

                titles,
                synopses,

                posterUrl,
                backdropUrl: null,

                releaseYear,
                runtime: null,

                director: artistName,

                genres,
                countries: null,

                details: {
                    Artista: artistName,
                    Faixas: Array.isArray(mainTracks) ? mainTracks.length : null,
                    Tracklist: Array.isArray(mainTracks) ? mainTracks : [],
                    BonusSections: bonusSections,
                },

                tags,
                externalIds: {
                    mbid: String(album.mbid || lastfmAlbumMbid || '').trim() || null,
                    releaseGroupMbid: releaseGroupMbid || null,
                    lastfm: album.url || null,
                    artist: artistName,
                    album: albumName,
                },
            };
    } catch (error) {
        console.error('Erro no LastFM Adapter:', error.message);
        throw new Error('Falha ao buscar álbum.');
    }
};

export const searchAlbums = async (query) => {
    const apiKey = getApiKey();

    const q = String(query || '').trim();
    if (!q) return [];

    try {
        const response = await lastFmClient.get('', {
            params: {
                method: 'album.search',
                api_key: apiKey,
                album: q,
                format: 'json',
                    limit: 10,
            },
        });

        const raw = response.data?.results?.albummatches?.album;
        const list = Array.isArray(raw) ? raw : raw ? [raw] : [];

        const dedup = new Map();
        for (const item of list) {
            const title = String(item?.name || '').trim();
            const artist = String(item?.artist || '').trim();
            const mbid = String(item?.mbid || '').trim();

            if (!title || !artist) continue;

            let canonicalExternalId = null;
            if (looksLikeMbid(mbid)) {
                const rgid = await resolveReleaseGroupMbid(mbid);
                if (rgid) {
                    canonicalExternalId = `rg_${rgid}`;
                }
            }

            if (!canonicalExternalId) {
                canonicalExternalId = buildAlbumExternalIdFromArtistAlbum(artist, title);
            }

            const id = `lastfm_${canonicalExternalId}`;

            const existing = dedup.get(id);
            const poster = pickBestImage(item?.image);

            if (!existing) {
                dedup.set(id, {
                    id,
                    title,
                    artist,
                    year: '?',
                    poster,
                    type: 'album',
                });
            } else if (!existing.poster && poster) {
                existing.poster = poster;
            }
        }

        return Array.from(dedup.values());
    } catch (error) {
        console.error('Erro no LastFM Adapter (search):', error.message);
        return [];
    }
};
</file>

<file path="client/src/pages/MediaDetailsPage/MediaDetailsPage.jsx">
import React, { useEffect, useState } from "react";
import { useParams } from "react-router-dom";
import { motion } from "framer-motion";
import { Heart, Loader2, AlertCircle } from "lucide-react";

import { cx } from "../../utils/formatters";
import HeaderBar from "../../components/layout/HeaderBar/HeaderBar.jsx";
import TechnicalDetails from "../../components/media/TechnicalDetails/TechnicalDetails.jsx";
import UserReviewEditor from "../../components/media/UserReviewEditor/UserReviewEditor.jsx";
import CommunityReviewsFeed from "../../components/media/CommunityReviewsFeed/CommunityReviewsFeed.jsx";

import api from "../../services/api";
import { useAuth } from "../../contexts/AuthContext";

import { translateGenre, getBookGenresTop3 } from "../../constants/genres";

export default function MediaDetailsPage({ theme, setTheme, lang, setLang, t }) {
  const { mediaId } = useParams();
  const [mediaData, setMediaData] = useState(null);

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const { currentUser } = useAuth();
  const [isFavorited, setIsFavorited] = useState(false);

  useEffect(() => {
    async function fetchMedia() {
      if (!mediaId) return;
      try {
        setLoading(true);
        setError(null);
        const response = await api.get(`/media/${mediaId}`);
        setMediaData(response.data);
      } catch (err) {
        console.error("Erro ao carregar mídia:", err);
        setError("Não foi possível carregar os detalhes desta mídia.");
      } finally {
        setLoading(false);
      }
    }
    fetchMedia();
  }, [mediaId]);

  const handleFavoriteClick = () => {
    setIsFavorited(!isFavorited);
  };

  if (loading) {
    return (
      <div className={cx(theme === "dark" ? "dark" : "", "font-sans")}>
      <div className="min-h-screen bg-neutral-50 text-neutral-900 dark:bg-neutral-950 dark:text-neutral-100">
      <HeaderBar theme={theme} setTheme={setTheme} lang={lang} setLang={setLang} t={t} />
      <main className="max-w-7xl mx-auto px-4 pt-40 pb-16 flex justify-center items-center">
      <Loader2 className="w-10 h-10 text-amber-500 animate-spin" />
      </main>
      </div>
      </div>
    );
  }

  if (error || !mediaData) {
    return (
      <div className={cx(theme === "dark" ? "dark" : "", "font-sans")}>
      <div className="min-h-screen bg-neutral-50 text-neutral-900 dark:bg-neutral-950 dark:text-neutral-100">
      <HeaderBar theme={theme} setTheme={setTheme} lang={lang} setLang={setLang} t={t} />
      <main className="max-w-7xl mx-auto px-4 pt-40 pb-16 flex flex-col items-center justify-center gap-4 text-center">
      <AlertCircle className="w-12 h-12 text-neutral-400" />
      <h2 className="text-xl font-bold">{error || "Mídia não encontrada"}</h2>
      </main>
      </div>
      </div>
    );
  }

  const safeLang = (lang || "PT").split("-")[0].toUpperCase();

  const getLocalizedList = (sourceObj) => {
    if (!sourceObj) return null;
    if (Array.isArray(sourceObj)) return sourceObj;
    return sourceObj[safeLang] || sourceObj["DEFAULT"] || sourceObj["EN"] || sourceObj["PT"] || null;
  };

  const notInformedFallback =
  safeLang === "EN" ? "Not informed" : safeLang === "ES" ? "No informado" : "Não informado";

  const tracklistTitleFallback =
  safeLang === "EN" ? "Tracks" : safeLang === "ES" ? "Pistas" : "Faixas";

  const tracklistNoFallback = "No.";

  const tracklistTitleColFallback =
  safeLang === "EN" ? "Title" : safeLang === "ES" ? "Título" : "Título";

  const tracklistLengthFallback =
  safeLang === "EN" ? "Length" : safeLang === "ES" ? "Duración" : "Duração";

  const tracklistBonusFallback =
  safeLang === "EN" ? "Bonus Tracks" : safeLang === "ES" ? "Pistas extra" : "Faixas bônus";

  const noTracklistFallback =
  safeLang === "EN"
  ? "Track listing unavailable."
  : safeLang === "ES"
  ? "Lista de pistas no disponible."
  : "Lista de faixas indisponível.";

  let titleText = "Título Indisponível";
  if (mediaData.titles) {
    titleText =
    mediaData.titles[safeLang] ||
    mediaData.titles["DEFAULT"] ||
    mediaData.titles["EN"] ||
    mediaData.titles["PT"] ||
    Object.values(mediaData.titles).find(Boolean) ||
    titleText;
  } else if (mediaData.title) {
    titleText = mediaData.title;
  }

  const rawYear =
  mediaData.releaseYear || mediaData.year || mediaData.release_date?.split("-")[0] || null;
  const displayYear = rawYear || "N/A";
  const headerYear =
  mediaData.type === "livro"
  ? rawYear || t("details.not_informed", notInformedFallback)
  : displayYear;

  let synopsisText = t("details.no_synopsis", "Sem sinopse.");
  let isSynopsisAvailableForSelectedLang = true;

  if (mediaData.type === "livro") {
    const candidate = mediaData.synopses ? mediaData.synopses[safeLang] : null;
    if (candidate && String(candidate).trim()) {
      synopsisText = String(candidate).trim();
      isSynopsisAvailableForSelectedLang = true;
    } else {
      synopsisText = null;
      isSynopsisAvailableForSelectedLang = false;
    }
  } else {
    if (mediaData.synopses) {
      synopsisText =
      mediaData.synopses[safeLang] ||
      mediaData.synopses["DEFAULT"] ||
      mediaData.synopses["EN"] ||
      mediaData.synopses["PT"] ||
      synopsisText;
    } else if (mediaData.overview) {
      synopsisText = mediaData.overview;
    }
  }

  const synopsisNotAvailableFallback =
  safeLang === "EN"
  ? "Synopsis not available in this language."
  : safeLang === "ES"
  ? "Sinopsis no disponible en este idioma."
  : "Sinopse não disponível neste idioma.";

  let genresList = [];

  let rawGenresList = getLocalizedList(mediaData.genres);
  if (!rawGenresList && Array.isArray(mediaData.genres)) {
    rawGenresList = mediaData.genres;
  }

  if (mediaData.type === "livro") {
    if (rawGenresList && Array.isArray(rawGenresList)) {
      genresList = getBookGenresTop3(rawGenresList, safeLang, 3);
    } else if (rawGenresList && typeof rawGenresList === "string") {
      genresList = getBookGenresTop3([rawGenresList], safeLang, 3);
    } else {
      genresList = [];
    }
  } else {
    if (rawGenresList && Array.isArray(rawGenresList)) {
      genresList = rawGenresList
      .map((g) => {
        const name = typeof g === "object" && g !== null && g.name ? g.name : g;
        if (mediaData.type === "album") return name;
        return translateGenre(name, safeLang);
      })
      .filter(Boolean);
    }

    if (genresList.length === 0 && mediaData.tags && Array.isArray(mediaData.tags)) {
      genresList = mediaData.tags.map((tag) => {
        const tagName = typeof tag === "object" && tag !== null && tag.name ? tag.name : tag;
        if (mediaData.type === "album") return tagName;
        return translateGenre(tagName, safeLang);
      });
    }
  }

  let countriesList = getLocalizedList(mediaData.countries);
  if (!countriesList && Array.isArray(mediaData.countries)) {
    countriesList = mediaData.countries;
  }

  let translatedCountries = null;
  if (countriesList && Array.isArray(countriesList)) {
    try {
      const regionNames = new Intl.DisplayNames([lang || "pt"], { type: "region" });
      translatedCountries = countriesList.map((code) => {
        try {
          return code.length === 2 ? regionNames.of(code) : code;
        } catch (e) {
          return code;
        }
      });
    } catch (e) {
      translatedCountries = countriesList;
    }
  }

  const genresDisplay = Array.isArray(genresList) ? genresList.join(", ") : genresList;
  const countriesDisplay = Array.isArray(translatedCountries)
  ? translatedCountries.join(", ")
  : translatedCountries;

  const principalCredit =
  mediaData.director ||
  mediaData.credits?.crew?.find((c) => c.job === "Director")?.name ||
  null;

  let directorLabel = "Direção";
  if (mediaData.type === "livro") directorLabel = "Autor";
  if (mediaData.type === "jogo") directorLabel = "Desenvolvedora";
  if (mediaData.type === "album") directorLabel = "Artista";

  let technicalDetails = {
    Ano: displayYear,
    Duração: mediaData.runtime ? `${mediaData.runtime} min` : null,
    Gêneros: genresDisplay,
    [directorLabel]:
    mediaData.director || mediaData.credits?.crew?.find((c) => c.job === "Director")?.name || null,
    País: countriesDisplay,
    ...(mediaData.details || {}),
  };

  if (mediaData.type === "album") {
    let trackCount = null;

    const fromDetails = mediaData.details ? mediaData.details.Faixas : null;
    if (typeof fromDetails === "number" && Number.isFinite(fromDetails)) {
      trackCount = fromDetails;
    } else if (typeof fromDetails === "string") {
      const m = fromDetails.match(/\d+/);
      if (m) {
        const n = parseInt(m[0], 10);
        if (Number.isFinite(n)) trackCount = n;
      }
    }

    const tl = mediaData.details ? mediaData.details.Tracklist : null;
    if ((trackCount == null || trackCount === 0) && Array.isArray(tl)) {
      trackCount = tl.length;
    }

    if (trackCount != null) {
      technicalDetails = {
        ...technicalDetails,
        Faixas: trackCount,
      };
    }
  }

  const albumTracksRaw =
  mediaData.type === "album" ? (mediaData.details ? mediaData.details.Tracklist : null) : null;
  const albumBonusRaw =
  mediaData.type === "album" ? (mediaData.details ? mediaData.details.BonusSections : null) : null;

  const normalizeTrackRows = (tracks) => {
    const list = Array.isArray(tracks) ? tracks : [];
    return list
    .map((t, idx) => {
      const no = typeof t?.no === "number" && Number.isFinite(t.no) ? t.no : idx + 1;
      const title = String(t?.title || "").trim();
      const length = String(t?.length || "").trim();
      return { no, title, length };
    })
    .filter((t) => t.title);
  };

  const albumTracks = normalizeTrackRows(albumTracksRaw);
  const albumBonusSections = Array.isArray(albumBonusRaw) ? albumBonusRaw : [];

  const TrackListAligned = ({ rows }) => {
    if (!rows || rows.length === 0) return null;

    return (
      <div className="w-full">
      <div className="grid grid-cols-[3.5rem,1fr,5rem] gap-3 px-2 py-2 text-xs font-semibold text-neutral-700 dark:text-neutral-200 bg-neutral-100 dark:bg-neutral-900/40 rounded-md">
      <div className="text-left">{t("tracklist.no", tracklistNoFallback)}</div>
      <div className="text-left">{t("tracklist.title", tracklistTitleColFallback)}</div>
      <div className="text-right">{t("tracklist.length", tracklistLengthFallback)}</div>
      </div>

      <div className="mt-1">
      {rows.map((tr) => (
        <div
        key={`${tr.no}-${tr.title}`}
        className="grid grid-cols-[3.5rem,1fr,5rem] gap-3 px-2 py-2 text-sm border-b border-neutral-200 dark:border-neutral-800"
        >
        <div className="text-neutral-500 dark:text-neutral-400 tabular-nums">{tr.no}.</div>
        <div className="text-neutral-800 dark:text-neutral-200">{tr.title}</div>
        <div className="text-right text-neutral-600 dark:text-neutral-300 tabular-nums">
        {tr.length || ""}
        </div>
        </div>
      ))}
      </div>
      </div>
    );
  };

  if (mediaData.type === "livro") {
    technicalDetails = {
      ...(mediaData.details || {}),
      author: (mediaData.director || null) || t("details.not_informed", notInformedFallback),
      genres: (genresDisplay || null) || t("details.not_informed", notInformedFallback),
      year: (rawYear || null) || t("details.not_informed", notInformedFallback),
      country: (countriesDisplay || null) || t("details.not_informed", notInformedFallback),
    };
  }

  return (
    <div className={cx(theme === "dark" ? "dark" : "", "font-sans")}>
    <div className="min-h-screen bg-neutral-50 text-neutral-900 dark:bg-neutral-950 dark:text-neutral-100">
    <HeaderBar theme={theme} setTheme={setTheme} lang={lang} setLang={setLang} t={t} />

    <main className="max-w-5xl mx-auto px-4 pt-24 pb-16 flex flex-col gap-8">
    <section className="relative rounded-2xl overflow-hidden border border-neutral-200 dark:border-neutral-800">
    <div className="absolute inset-0">
    {mediaData.backdropUrl ? (
      <img
      src={mediaData.backdropUrl}
      alt=""
      className="w-full h-full object-cover object-center filter blur-lg scale-110 opacity-60"
      />
    ) : (
      <div className="w-full h-full bg-neutral-800" />
    )}
    <div className="absolute inset-0 bg-gradient-to-t from-neutral-900 via-neutral-900/60 to-transparent" />
    </div>

    <div className="relative p-6 md:p-8 flex flex-col md:flex-row gap-6 md:gap-8 items-end md:items-start">
    <div className="w-40 md:w-1/4 flex-shrink-0 mx-auto md:mx-0 shadow-2xl">
    <img
    src={mediaData.posterUrl || "https://via.placeholder.com/300x450"}
    alt={`Pôster de ${titleText}`}
    className="w-full h-auto rounded-lg border-2 border-white/10 bg-neutral-800"
    />
    </div>

    <div className="flex-1 text-white pt-0 md:pt-4 text-center md:text-left z-10">
    <h1 className="text-3xl md:text-4xl font-extrabold tracking-tight drop-shadow-md mb-2">
    {titleText}
    </h1>

    <div className="flex flex-col gap-1 items-center md:items-start text-neutral-300">
    {principalCredit && (
      <div className="text-lg">
      {principalCredit}
      </div>
    )}

    {headerYear && (
      <div className="text-lg">
      {headerYear}
      </div>
    )}

    <div className="mt-1">
    <span className="bg-white/10 px-2 py-0.5 rounded text-sm font-medium backdrop-blur-md uppercase">
    {t(`badge.${mediaData.type}`) || mediaData.type}
    </span>
    </div>
    </div>

    <motion.button
    whileTap={{ scale: 1.2 }}
    onClick={handleFavoriteClick}
    className="mt-6 p-3 rounded-full bg-white/10 hover:bg-white/20 backdrop-blur-sm inline-flex transition-colors border border-white/10"
    aria-label={t(isFavorited ? "a11y.remove_favorite" : "a11y.add_favorite")}
    >
    <Heart
    className={cx(
      "w-6 h-6 transition-colors",
      isFavorited ? "text-red-500 fill-current" : "text-white"
    )}
    />
    </motion.button>
    </div>
    </div>
    </section>

    <section className="grid grid-cols-1 lg:grid-cols-12 gap-8">
    <div className="lg:col-span-7 flex flex-col gap-8">
    <div>
    {mediaData.type === "album" ? (
      <>
      <h2 className="text-xl font-bold text-neutral-800 dark:text-neutral-100 mb-2">
      {t("section.tracklist", tracklistTitleFallback)}
      </h2>

      {albumTracks.length > 0 ? (
        <TrackListAligned rows={albumTracks} />
      ) : (
        <p className="text-base text-neutral-600 dark:text-neutral-300 leading-relaxed">
        {t("details.no_tracklist", noTracklistFallback)}
        </p>
      )}

      {albumBonusSections.length > 0 && (
        <div className="mt-6 flex flex-col gap-6">
        {albumBonusSections.map((section, idx) => {
          const title =
          String(section?.title || "").trim() ||
          t("tracklist.bonus", tracklistBonusFallback);

          const rows = normalizeTrackRows(section?.tracks);
          if (!rows.length) return null;

          return (
            <div key={`${title}-${idx}`}>
            <h3 className="text-base font-semibold text-neutral-800 dark:text-neutral-100 mb-2">
            {title}
            </h3>
            <TrackListAligned rows={rows} />
            </div>
          );
        })}
        </div>
      )}
      </>
    ) : (
      <>
      <h2 className="text-xl font-bold text-neutral-800 dark:text-neutral-100 mb-2">
      {t("section.synopsis")}
      </h2>

      {mediaData.type === "livro" ? (
        <p className="text-base text-neutral-600 dark:text-neutral-300 leading-relaxed">
        {isSynopsisAvailableForSelectedLang
          ? synopsisText
          : t("details.synopsis_not_available", synopsisNotAvailableFallback)}
          </p>
      ) : (
        <p className="text-base text-neutral-600 dark:text-neutral-300 leading-relaxed">
        {synopsisText}
        </p>
      )}
      </>
    )}
    </div>

    <TechnicalDetails details={technicalDetails} type={mediaData.type} t={t} lang={lang} />
    </div>

    <div className="lg:col-span-5">
    <UserReviewEditor communityAverage={mediaData.voteAverage || mediaData.score || 0} t={t} />
    </div>
    </section>

    <CommunityReviewsFeed reviews={mediaData.communityReviews || mediaData.reviews || []} t={t} />
    </main>
    </div>
    </div>
  );
}
</file>

<file path="server/prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==========================================
// USUÁRIOS E PERFIL
// ==========================================

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String?
  handle    String   @unique
  password  String

  bio       String?  @db.Text
  avatarUrl String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reviews       Review[]
  achievements  UserAchievement[]
  favorites     MediaReference[] @relation("UserFavorites")
}

// ==========================================
// MÍDIA (CACHE & CATALOGO)
// ==========================================

model MediaReference {
  // ID canônico (QID) ou ID legado (ex: "tmdb_550", "ol_OL123W", "lastfm_xxx")
  id          String   @id

  // "filme" | "livro" | "jogo" | "album"
  type        String

  // { "PT": "...", "EN": "...", "ES": "...", "DEFAULT": "..." }
  titles      Json

  synopses    Json?

  posterUrl   String?
  backdropUrl String?

  releaseYear Int?

  runtime     Int?
  director    String?

  // UI-friendly (pode ser legado enquanto migramos)
  genres      Json?
  countries   Json?

  details     Json?

  tags        String[]
  externalIds Json?

  // Canonicalização/performance
  isStub         Boolean   @default(false)
  lastFetchedAt  DateTime?
  lastAccessedAt DateTime?
  countrySource  String?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relacionamentos
  favoritedBy User[]   @relation("UserFavorites")
  reviews     Review[]

  aliases     MediaAlias[]
  mediaGenres MediaGenre[]

  @@index([type])
  @@index([type, releaseYear])
  @@index([lastAccessedAt])
}

// ==========================================
// BUSCA / ALIASES (DB-first)
// ==========================================

model MediaAlias {
  id              String   @id
  canonicalId     String
  canonical       MediaReference @relation(fields: [canonicalId], references: [id], onDelete: Cascade)

  type            String   // "filme" | "livro" | "jogo" | "album"
  lang            String   // "PT" | "EN" | "ES"

  title           String
  titleRaw        String
  titleNormalized String

  source          String   // "wikidata.label" | "wikidata.alias" | etc
  lastAccessedAt  DateTime @default(now())

  createdAt       DateTime @default(now())

  @@index([lastAccessedAt])
  @@index([type, lang, titleNormalized])
}

// ==========================================
// GÊNERO CANÔNICO (para troféus)
// ==========================================

model Genre {
  // Sugestão: usar o QID do gênero como id (ex: "Q132311")
  id        String   @id

  // slug limpo (ex: "fantasy")
  slug      String   @unique

  // { "PT": "Fantasia", "EN": "Fantasy", "ES": "Fantasía" }
  titles    Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  mediaGenres MediaGenre[]
}

model MediaGenre {
  mediaId   String
  genreId   String

  media     MediaReference @relation(fields: [mediaId], references: [id], onDelete: Cascade)
  genre     Genre          @relation(fields: [genreId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@id([mediaId, genreId])
  @@index([genreId])
  @@index([mediaId])
}

// ==========================================
// REVIEWS E AVALIAÇÕES
// ==========================================

model Review {
  id        String   @id @default(uuid())

  rating    Float
  content   String?  @db.Text
  tags      String[]
  containsSpoilers Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId    String
  user      User     @relation(fields: [userId], references: [id])

  mediaId   String
  media     MediaReference @relation(fields: [mediaId], references: [id])
}

// ==========================================
// GAMIFICAÇÃO (TROFÉUS)
// ==========================================

model UserAchievement {
  id            String   @id @default(uuid())
  achievementId String
  unlockedAt    DateTime @default(now())
  progress      Int      @default(0)

  userId        String
  user          User     @relation(fields: [userId], references: [id])

  @@unique([userId, achievementId])
}
</file>

</files>
